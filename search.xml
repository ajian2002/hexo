<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Test</title>
    <url>/test/</url>
    <content><![CDATA[<p>tetttt</p>
]]></content>
  </entry>
  <entry>
    <title>记一次参与Matrixone社区的经历</title>
    <url>/%E5%AD%A6%E4%B9%A0/2022-03-14-%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8F%82%E4%B8%8Ematrixone%E7%A4%BE%E5%8C%BA%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>最初是从朋友那里听说,他有一个很厉害的朋友在一个叫 <a href="https://github.com/matrixorigin/matrixone">matrixone</a>的社区贡献代码,并且社区的前景很好,这便是我对<code>matrixone</code>对最初印象了.</p>
<h1 id="参与"><a href="#参与" class="headerlink" title="参与"></a>参与</h1><p>偶然间,看到了 <a href="https://github.com/matrixorigin/matrixone/labels/good%20first%20issue">good first issue</a>的<code>labels</code>,发现我完全有能力去解决其中一些问题,于是在朋友的建议下,带着初次参与社区的好奇与热爱,第一次开始了参与开源社区并且为之贡献代码的精力.</p>
<h1 id="开始coding"><a href="#开始coding" class="headerlink" title="开始coding"></a>开始coding</h1><p>很快,我选择了一个比较简单的<code>issue</code> [Feature Request]: Mathematical Built-in function pi() #1821](<a href="https://github.com/matrixorigin/matrixone/issues/1821">https://github.com/matrixorigin/matrixone/issues/1821</a>) ,为<code>sql</code>实现内置的<code>pi()</code>函数,这个功能从实现上来说没有任何难度,所以更方便我把重点放在学习如何把内置函数嵌入到<code>sql</code>查询中,并直观的显示返回给使用者</p>
<p>根据<a href="https://github.com/matrixorigin/matrixone/issues/1821#issue-1161068080">https://github.com/matrixorigin/matrixone/issues/1821#issue-1161068080</a>提到的 开发文档<a href="https://docs.matrixorigin.io/0.3.0/MatrixOne/Contribution-Guide/Tutorial/develop_builtin_functions/"><strong>开发内置函数</strong></a>,我便开始照猫画虎的去修改样例来实现我的功能.</p>
<p>首先是要求具备一定的<code>golang</code>语言能力,这个恰好在几个月前学过一阵子,虽然平时不怎么用,但是看代码还是能改改的,复习的话也很快就能回忆起来,这个不是难点</p>
<p>其次,文档介绍到</p>
<blockquote>
<p>  数据库中有两种函数，内置函数是数据库自带的函数，而自定义函数是用户自定义的。内置函数可以根据它们操作的数据类型进行分类，即字符串、日期和数字内置函数。</p>
</blockquote>
<p> 并且给出了执行开发内置函数的步骤</p>
<h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><p> 第一步：注册功能</p>
<ol>
<li><p>函数名注册</p>
<p>这一部分简单,只需要在 <code>pkg/builtin/types.go</code>中添加函数名即可</p>
</li>
<li><p>声明函数参数类型和返回类型。</p>
<p>开始有一点点复杂了,</p>
<blockquote>
<p>  在 Golang 中，初始化包时会调用 init 函数。我们将 all 的功能包装<code>ABS()</code>在这个 init 函数中，因此我们不需要显式调用它。</p>
</blockquote>
<p>在 <code>init</code>中,我们要按照案例的写法,根据不同函数和参数返回值的情况,去注册不同的函数</p>
<p>有个坑点是 </p>
<blockquote>
<p>  在该目录<code>pkg/builtin/unary</code>中，创建一个新的 go 文件<code>abs.go</code>。</p>
<p>  目录下的函数<code>unary</code>只接受一个值作为输入。目录下的函数<code>binary</code>只接受两个值作为输入。其他形式的函数放在<code>multi</code>目录下。</p>
</blockquote>
</li>
</ol>
<pre><code>所以,在注册时,要根据输入值的不同数目,在不同的个目录下新建文件,并且将
`extend.UnaryReturnTypes[builtin.Abs]`等改换成`extend.BinaryReturnTypes[builtin.xxx]`

确实是个不容易注意到的地方呢.
</code></pre>
<ol start="3">
<li><p>函数调用准备</p>
<p>重点到了,也是整个卡了我很久的地方</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">overload.UnaryOps[builtin.Abs] = []*overload.UnaryOp&#123;</span><br><span class="line">	Typ:        types.T_float32,</span><br><span class="line">     ReturnType: types.T_float32,</span><br><span class="line">     Fn: <span class="function"><span class="keyword">func</span><span class="params">(origVec *vector.Vector, proc *process.Process, _ <span class="type">bool</span>)</span></span> (*vector.Vector, <span class="type">error</span>) &#123;</span><br><span class="line">                origVecCol := origVec.Col.([]<span class="type">float32</span>)</span><br><span class="line">                resultVector, err := process.Get(proc, <span class="number">4</span>*<span class="type">int64</span>(<span class="built_in">len</span>(origVecCol)), types.Type&#123;Oid: types.T_float32, Size: <span class="number">4</span>&#125;) <span class="comment">// get a new types.T_float32 vector to store the result vector</span></span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">                results := encoding.DecodeFloat32Slice(resultVector.Data)</span><br><span class="line">                results = results[:<span class="built_in">len</span>(origVecCol)]</span><br><span class="line">                resultVector.Col = results</span><br><span class="line">                nulls.Set(resultVector.Nsp, origVec.Nsp)                         <span class="comment">// the new vector&#x27;s nulls are the same as the original vector</span></span><br><span class="line">                vector.SetCol(resultVector, abs.AbsFloat32(origVecCol, results)) <span class="comment">// set the vector col with the return value from abs.AbsFloat32 function</span></span><br><span class="line">                <span class="keyword">return</span> resultVector, <span class="literal">nil</span></span><br><span class="line">            &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个部分的文档写的非常晦涩,很难理解,于是我根据其他已经实现的内置函数的写法,推测这个部分的写法.</p>
</li>
</ol>
<p>   不过运气不是很好,因为几乎没有与我的功能相似的情况,所以没有现成的解决方案可以借鉴.</p>
<p>   于是我开始放弃借鉴,直接点进去看上下文逻辑,看源码,然后修改,编译运行,其客户端去测试,看报错,看日志,总的来说,过程很复杂,很麻烦,但是离终点非常接近了,我可不想放弃</p>
<p>   解决,不知道试了多少次,终于正确结果出来了,我很难忘记当时的激动和欣喜.</p>
<p>   虽然不知道是否时最适合的写法,但是 ~~~能跑就行 (dog~~ </p>
<p>其他步骤,编译运行什么的,都是再正常不过的逻辑了,不需要多费口舌,</p>
<h1 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h1><p>很快,提了pr,通过了review,终于merge进了主分支,期间我也感受到了社区的issue回复速度和pr的审查速度,大家都是很热情积极的关注并解决,整个社区看起来充满了活力.</p>
<p>最后,也和<code>matrixone</code>社区的运营人员交流了一下对社区和这次任务的感受,感觉还是很棒的氛围,以后有机会也会继续参与社区的.</p>
<p><img src="https://tu.yegetables.com/images/2022/03/14/image-20220314233457000.png" alt="image-20220314233457000"></p>
<p><img src="https://tu.yegetables.com/images/2022/03/14/image-20220314233521009.png" alt="image-20220314233521009"></p>
<p>开心~~~~</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次Chrome同步错误</title>
    <url>/%E5%AD%A6%E4%B9%A0/2022-03-07-%E8%AE%B0%E4%B8%80%E6%AC%A1chrome%E5%90%8C%E6%AD%A5%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>遇到了一件怪事,chrome除了密码不能同步以外,其他一切正常<br>尝试了几次的登陆注销之后发现没有用,然后在<br><a href="chrome://sync-internals/">同步信息页</a>找到了问题 </p>
<blockquote>
</blockquote>
<p>Error: MergeDataAndStartSyncing@..&#x2F;..&#x2F;components&#x2F;password_manager&#x2F;core&#x2F;browser&#x2F;sync&#x2F;password_syncable_service.cc:190, datatype error was encountered: Failed to get passwords from store.</p>
<p>然后知道了问题就好解决了</p>
<p><a href="https://support.google.com/chrome/thread/9947763/error-syncing-passwords?hl=en">Error syncing passwords</a></p>
<p>在<a href="chrome://version/">chrome版本信息页</a><br>找到  个人资料路径<code>/home/ajian/.config/google-chrome/Profile 1</code><br>删除目录下的所有 <code>Login Data</code>开始的文件<br>重启chrome解决问题</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>目录</tag>
        <tag>问题</tag>
        <tag>同步</tag>
        <tag>error</tag>
        <tag>chrome</tag>
        <tag>passwords</tag>
        <tag>sync</tag>
        <tag>syncing</tag>
      </tags>
  </entry>
  <entry>
    <title>Ssm整合步骤</title>
    <url>/%E5%AD%A6%E4%B9%A0/2022-01-29-ssm%E6%95%B4%E5%90%88%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>整体文件目录</p>
<h2 id="1-maven"><a href="#1-maven" class="headerlink" title="1.maven"></a>1.maven</h2><p><img src="https://tu.yegetables.com/images/2022/01/29/image-20220129150932260.png" alt="image-20220129150932260"></p>
<p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.3.15<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.14.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--spring--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--        Database--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mariadb.jdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mariadb-java-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--other--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-web-xml"><a href="#2-web-xml" class="headerlink" title="2. web.xml"></a>2. web.xml</h2><p><img src="https://tu.yegetables.com/images/2022/01/29/image-20220129151002983.png" alt="image-20220129151002983"></p>
<p><code>webapp/WEB_INNF/web.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!-- 配置DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SSM_demo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置springMVC需要加载的配置文件</span></span><br><span class="line"><span class="comment">        spring-dao.xml,spring-service.xml,spring-web.xml</span></span><br><span class="line"><span class="comment">               Mybatis - &gt; spring -&gt; springmvc</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-web.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        应该在 Web 应用程序启动时加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SSM_demo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-dao层（mybatis持久层框架-druid连接池）"><a href="#3-dao层（mybatis持久层框架-druid连接池）" class="headerlink" title="3. dao层（mybatis持久层框架+druid连接池）"></a>3. dao层（mybatis持久层框架+druid连接池）</h2><p><img src="https://tu.yegetables.com/images/2022/01/29/image-20220129190824037.png" alt="image-20220129190824037"></p>
<h3 id="3-1-spring-dao-xml"><a href="#3-1-spring-dao-xml" class="headerlink" title="3.1 spring-dao.xml"></a>3.1 <code>spring-dao.xml</code></h3><p><code>resources/sprig/spring-dao.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- #1.配置 db的资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:alidb.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #2.配置bean  datasource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        连接池属性        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.jdbcUrl&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        druid连接池私有属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxActive&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWait&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxWait&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--                关闭连接后不自动commit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultAutoCommit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--                获取连接超时时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queryTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--#3.配置SqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        mybatis 的全局配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--                  扫描并使用pojo的别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.yegetables.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--                  扫描mapper需要的xml--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--#4.扫描mapper接口，动态实现接口，并注入ioc中    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        注入sqlSessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        给出需要扫描Dao接口包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.yegetables.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-mybatis-connfig-xml"><a href="#3-2-mybatis-connfig-xml" class="headerlink" title="3.2 mybatis-connfig.xml"></a>3.2 <code>mybatis-connfig.xml</code></h3><p><code>resources/mybatis-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置全局属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 使用列别名替换列名 默认:true --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-properties"><a href="#3-3-properties" class="headerlink" title="3.3 properties"></a>3.3 properties</h3><p>在resources文件夹下存放<code>db.properties</code>的数据库连接资源文件</p>
<p><code>resources/db.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.jdbcUrl</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/mybatis</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">mybatis</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">*******</span></span><br><span class="line"><span class="attr">jdbc.driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">jdbc.maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">jdbc.maxWait</span>=<span class="string">2000</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-数据库表"><a href="#3-4-数据库表" class="headerlink" title="3.4 数据库表"></a>3.4 数据库表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> books</span><br><span class="line">(</span><br><span class="line">    number   <span class="type">int</span> auto_increment comment <span class="string">&#x27;书ID&#x27;</span></span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    name     <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;书名&#x27;</span>,</span><br><span class="line">    <span class="keyword">language</span> <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;语言&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h3 id="3-5-pojo类"><a href="#3-5-pojo类" class="headerlink" title="3.5 pojo类"></a>3.5 pojo类</h3><p> pojo层定义跟数据库表对应的pojo类</p>
<p><code>src/java/com/pojo/Books.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yegetables.pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Books</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String language;</span><br><span class="line">	<span class="comment">//setter ,getter, 无参构造，有参构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-dao层接口"><a href="#3-6-dao层接口" class="headerlink" title="3.6 dao层接口"></a>3.6 dao层接口</h3><p> dao层的操作pojo接口</p>
<p><code>src/java/com/dao/BooksMapper.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yegetables.dao;</span><br><span class="line"><span class="keyword">import</span> com.yegetables.pojo.Books;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BooksMapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertBook</span><span class="params">(Books book)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBookByNumber</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateBook</span><span class="params">(Books book)</span>;</span><br><span class="line">    Books <span class="title function_">getBookByNumber</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line">    List&lt;Books&gt; <span class="title function_">getBooks</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  <strong>提示</strong>：为什么要给方法的参数添加<code>@Param</code>注解呢？是因为该方法有两个或以上的参数，一定要加，不然mybatis识别不了。方法只有一个参数<code>book_id</code>，所以可以不用加 <code>@Param</code>注解，当然加了也无所谓~</p>
<p>  ​	int insertAppointment(@Param(“bookId”) long bookId, @Param(“studentId”) long studentId);</p>
</blockquote>
<h3 id="3-7-编写sql"><a href="#3-7-编写sql" class="headerlink" title="3.7 编写sql"></a>3.7 编写sql</h3><p>编写dao层mapper接口对应的sql语句</p>
<p><code>resources/mapper/BooksMapper.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.yegetables.dao.BooksMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">        insert</span><br><span class="line">        into books (number, name, language)</span><br><span class="line">        values (#&#123;number&#125;, #&#123;name&#125;, #&#123;language&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBookByNumber&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete</span><br><span class="line">        from books</span><br><span class="line">        where number = #&#123;number&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">        update books</span><br><span class="line">        set name=#&#123;name&#125;,</span><br><span class="line">            language=#&#123;language&#125;</span><br><span class="line">        where number = #&#123;number&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getBookByNumber&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">        select number, name, language</span><br><span class="line">        from books</span><br><span class="line">        where number = #&#123;number&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getBooks&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">        select number, name, language</span><br><span class="line">        from books;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-services-层"><a href="#4-services-层" class="headerlink" title="4. services 层"></a>4. services 层</h2><h3 id="4-1-spring-services-xml"><a href="#4-1-spring-services-xml" class="headerlink" title="4.1 spring-services.xml"></a>4.1 spring-services.xml</h3><p><code>resources/spring/sprinng-services.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    扫描注解@Service--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yegetables.service&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置事务管理器，把事务管理交由spring来完成--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   默认启用：配置基于注解的声明式事务，可以直接在方法上@Transaction--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;--&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-src-x2F-services"><a href="#4-2-src-x2F-services" class="headerlink" title="4.2 src&#x2F;services"></a>4.2 src&#x2F;services</h3><p><img src="https://tu.yegetables.com/images/2022/01/29/image-20220129160329970.png" alt="image-20220129160329970"></p>
<p>分两个目录</p>
<p>一个是<code>service</code>目录下的业务<code>接口</code></p>
<p>一个是<code>services.impl</code> 目录下的<code>接口实现类</code></p>
<h2 id="5-web层"><a href="#5-web层" class="headerlink" title="5. web层"></a>5. web层</h2><p><code>resources/spring/spring-web.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.扫描web层 @Controller--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.yegetables.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.开启SpringMVC注解模式</span></span><br><span class="line"><span class="comment">        (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter</span></span><br><span class="line"><span class="comment">        (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3.静态资源默认servlet配置</span></span><br><span class="line"><span class="comment">        (1)加入对静态资源的处理：js,gif,png</span></span><br><span class="line"><span class="comment">        (2)允许使用&quot;/&quot;做整体映射</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4.jsp视图解析器  ： 可以更换成 模板  thymeleaf 等  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Junit5"><a href="#Junit5" class="headerlink" title="Junit5"></a>Junit5</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yegetables.service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations = &#123;&quot;classpath:spring/spring-dao.xml&quot;, &quot;classpath:spring/spring-web.xml&quot;, &quot;classpath:spring/spring-service.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BooksMapper bookMapper;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="junit4"><a href="#junit4" class="headerlink" title="junit4"></a>junit4</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//引入Spring配置</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;classpath:spring/spring-dao.xml&quot;, &quot;classpath:spring/spring-web.xml&quot;, &quot;classpath:spring/spring-service.xml&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="themleaf"><a href="#themleaf" class="headerlink" title="themleaf"></a>themleaf</h2><p><code>spring-web.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--    配置thymeleaf模板解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        是否设置缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        模板的类型 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--模板引擎--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;engine&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;templateResolver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;resolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;engine&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 4.jsp 视图解析器  ： 可以更换成 模板  thymeleaf 等  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>test.html</code>添加名命名空间<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p>特别感谢 <a href="https://blog.csdn.net/qq598535550/article/details/51703190">手把手教你整合最优雅SSM框架：SpringMVC + Spring + MyBatis</a></p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">mybatis官方文档</a></p>
<p><a href="https://www.bilibili.com/video/BV1aE41167Tu?p=17">【狂神说Java】SpringMVC最新教程IDEA版通俗易懂</a></p>
<p><a href="https://www.bilibili.com/video/BV1Vf4y127N5">尚硅谷Spring框架视频教程（spring5源码级讲解）</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql</tag>
        <tag>java</tag>
        <tag>mysql</tag>
        <tag>mybatis</tag>
        <tag>xml</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--堆（完全二叉树，线性表实现）</title>
    <url>/%E5%AD%A6%E4%B9%A0/2022-01-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%A0%86%EF%BC%88%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="heap-堆"><a href="#heap-堆" class="headerlink" title="heap 堆"></a>heap 堆</h1><p>堆其实就是一种特殊的队列——优先队列。</p>
<ol>
<li><p>堆序性 (heap order): 任意节点都<strong>优于</strong>它的<strong>所有孩子</strong>。</p>
<p>a. 如果是任意节点都<strong>大于</strong>它的所有孩子，这样的堆叫<strong>大顶堆</strong>，Max Heap;</p>
<p>b. 如果是任意节点都<strong>小于</strong>它的所有孩子，这样的堆叫<strong>小顶堆</strong>，Min Heap;</p>
</li>
</ol>
<p>大顶堆    节点  右 元素  优先于 左元素   </p>
<p>用 <code>ArrayList</code>  来  实现 堆   ， 完全二叉树   </p>
<p>父节点     <code>(i - 1) / 2</code></p>
<p>子节点        左： <code>2 * i + 1</code>     	 右：<code>2 * i + 2</code>  </p>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">       list.add(element);</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">       size++;</span><br><span class="line">       <span class="keyword">while</span> (((i - <span class="number">1</span>) / <span class="number">2</span>) &gt; -<span class="number">1</span> &amp;&amp; c.compare(element, list.get((i - <span class="number">1</span>) / <span class="number">2</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//有父节点并且大于父节点 交换</span></span><br><span class="line">           swap((i - <span class="number">1</span>) / <span class="number">2</span>, i);</span><br><span class="line">           i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">        list.set(<span class="number">0</span>, list.get(i));</span><br><span class="line">        list.remove(i);</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有子节点并且小于子节点     与较大子节点 交换</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//两个节点 第二个大</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">2</span> &lt; size &amp;&amp; c.compare(list.get(<span class="number">2</span> * i + <span class="number">2</span>), list.get(<span class="number">2</span> * i + <span class="number">1</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c.compare(list.get(i), list.get(<span class="number">2</span> * i + <span class="number">2</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(i, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">                    i = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//第一个大</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(list.get(i), list.get(<span class="number">2</span> * i + <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(i, <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">                    i = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="完整类"><a href="#完整类" class="headerlink" title="完整类"></a>完整类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;E&gt;();</span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;E&gt; c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(Comparator&lt;E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">()</span> &#123;</span><br><span class="line">        c = (e1, e2) -&gt; ((Comparable&lt;E&gt;) e1).compareTo(e2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(E[] arr, Comparator&lt;E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">        <span class="keyword">for</span> (E e : arr) add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) c = (e1, e2) -&gt; ((Comparable&lt;E&gt;) e1).compareTo(e2);</span><br><span class="line">        <span class="keyword">for</span> (E e : arr) add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">temp</span> <span class="operator">=</span> list.get(index1);</span><br><span class="line">        list.set(index1, list.get(index2));</span><br><span class="line">        list.set(index2, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span> &#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">while</span> (((i - <span class="number">1</span>) / <span class="number">2</span>) &gt; -<span class="number">1</span> &amp;&amp; c.compare(element, list.get((i - <span class="number">1</span>) / <span class="number">2</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有父节点并且大于父节点 交换</span></span><br><span class="line">            swap((i - <span class="number">1</span>) / <span class="number">2</span>, i);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">        list.set(<span class="number">0</span>, list.get(i));</span><br><span class="line">        list.remove(i);</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有子节点并且小于子节点     与较大子节点 交换</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//两个节点 第二个大</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">2</span> &lt; size &amp;&amp; c.compare(list.get(<span class="number">2</span> * i + <span class="number">2</span>), list.get(<span class="number">2</span> * i + <span class="number">1</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c.compare(list.get(i), list.get(<span class="number">2</span> * i + <span class="number">2</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(i, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">                    i = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//第一个大</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(list.get(i), list.get(<span class="number">2</span> * i + <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(i, <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">                    i = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;heap&#123;   size=&quot;</span> + size + <span class="string">&quot;   list=\n&quot;</span> + list + <span class="string">&quot;\n&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java动态代理方式</title>
    <url>/%E5%AD%A6%E4%B9%A0/2022-01-10-java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><h5 id="1-有接口-JDK动态代理"><a href="#1-有接口-JDK动态代理" class="headerlink" title="1. 有接口  JDK动态代理"></a>1. 有接口  JDK动态代理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">web</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">implements</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">web</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;server really work&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  -----------------------接口和实现类     </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyServerFactory</span> &#123;</span><br><span class="line">    <span class="type">Server</span> <span class="variable">ser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Server</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> work <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//返回将方法调用分派到指定调用处理程序的指定接口的代理实例。</span></span><br><span class="line">        <span class="comment">//如果违反以下任何限制，将抛出IllegalArgumentException ：</span></span><br><span class="line">        <span class="comment">//给定interfaces数组中的所有Class对象都必须表示接口，而不是类或原始类型。</span></span><br><span class="line">        <span class="comment">//interfaces数组中的任何两个元素都不能引用相同的Class对象。</span></span><br><span class="line">        <span class="comment">//所有接口类型都必须通过指定的类加载器按名称可见。 换句话说，对于类加载器cl和每个接口i ，以下表达式必须为真：</span></span><br><span class="line">        <span class="comment">//Class.forName(i.getName(), false, cl) == i</span></span><br><span class="line">        <span class="comment">//指定接口的所有公共方法签名引用的所有类型以及由它们的超接口继承的类型必须通过指定的类加载器按名称可见。</span></span><br><span class="line">        <span class="comment">//所有非公共接口必须在同一个包和模块中，由指定的类加载器定义，并且非公共接口的模块可以访问所有的接口类型； 否则，代理类不可能实现所有接口，无论它定义在哪个包中。</span></span><br><span class="line">        <span class="comment">//对于具有相同签名的指定接口的任何成员方法集：</span></span><br><span class="line">        <span class="comment">//如果任何方法的返回类型是原始类型或 void，则所有方法都必须具有相同的返回类型。</span></span><br><span class="line">        <span class="comment">//否则，其中一个方法必须具有可分配给其余方法的所有返回类型的返回类型。</span></span><br><span class="line">        <span class="comment">//生成的代理类不得超过虚拟机对类施加的任何限制。 例如，VM 可能会限制一个类可以实现的接口数量为 65535； 在这种情况下， interfaces数组的大小不得超过 65535。</span></span><br><span class="line">        <span class="comment">//请注意，指定代理接口的顺序很重要：对具有相同接口组合但顺序不同的代理类的两个请求将导致两个不同的代理类。</span></span><br><span class="line">        <span class="comment">//参形：</span></span><br><span class="line">        <span class="comment">//loader – 定义代理类的类加载器</span></span><br><span class="line">        <span class="comment">//interfaces – 代理类要实现的接口列表</span></span><br><span class="line">        <span class="comment">//h - 将方法调用分派到的调用处理程序</span></span><br><span class="line">        <span class="comment">//返回值：</span></span><br><span class="line">        <span class="comment">//具有代理类的指定调用处理程序的代理实例，该代理类由指定的类加载器定义并实现指定的接口</span></span><br><span class="line">        <span class="comment">//抛出：</span></span><br><span class="line">        <span class="comment">//IllegalArgumentException – 如果违反了对参数的任何限制</span></span><br><span class="line">        <span class="comment">//SecurityException – 如果存在安全管理器s并且满足以下任何条件：</span></span><br><span class="line">        <span class="comment">//给定的loader为null并且调用者的类加载器不为null并且使用RuntimePermission(&quot;getClassLoader&quot;)权限调用s.checkPermission拒绝访问；</span></span><br><span class="line">        <span class="comment">//对于每个代理接口intf ，调用者的类加载器与intf的类加载器的祖先不同，并且调用s.checkPackageAccess()拒绝访问intf ；</span></span><br><span class="line">        <span class="comment">//任何给定的代理接口都是非公共的，并且调用者类与非公共接口不在同一个运行时包中， s.checkPermission使用ReflectPermission(&quot;newProxyInPackage.&#123;package name&#125;&quot;)权限调用s.checkPermission拒绝访问。</span></span><br><span class="line">        <span class="comment">//NullPointerException – 如果interfaces数组参数或其任何元素为null ，或者调用处理程序h为null</span></span><br><span class="line">        <span class="comment">//请参阅：</span></span><br><span class="line">        <span class="comment">//代理类的包和模块成员资格</span></span><br><span class="line">        <span class="comment">//    @CallerSensitive</span></span><br><span class="line">        <span class="comment">//    public static Object newProxyInstance(ClassLoader loader,</span></span><br><span class="line">        <span class="comment">//                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line">        <span class="comment">//                                          InvocationHandler h)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (work) Proxy.newProxyInstance(ser.getClass().getClassLoader(), ser.getClass().getInterfaces(), <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;proxychains working&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(ser, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyServerFactory</span>().getObject();</span><br><span class="line">        proxy.web();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-cglib动态代理"><a href="#2-cglib动态代理" class="headerlink" title="2. cglib动态代理"></a>2. cglib动态代理</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGLibProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="type">Server</span> <span class="variable">ser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Server</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个新的Enhancer 。 每个生成的对象都应该使用一个新的Enhancer对象，并且不应跨线程共享。 要创建生成类的其他实例，请使用Factory接口。</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置生成的类将扩展的类。 为方便起见，如果提供的超类实际上是一个接口，则将使用适当的参数调用setInterfaces 。 非接口参数不得声明为 final，并且必须具有可访问的构造函数。</span></span><br><span class="line">        enhancer.setSuperclass(Server.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置要使用的单个Callback 。 如果您使用createClass()则忽略。</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如有必要，生成一个新类并使用指定的回调（如果有）来创建一个新的对象实例。 使用超类的无参数构造函数</span></span><br><span class="line">        <span class="type">Server</span> <span class="variable">newser</span> <span class="operator">=</span> (Server) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有生成的代理方法都调用此方法而不是原始方法。 原始方法可以使用 Method 对象通过正常反射调用，也可以使用 MethodProxy（更快）调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           “this”，增强对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      拦截方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objects     参数数组； 原始类型被包装</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用 super（非拦截方法）； 可以根据需要多次调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与代理方法的签名兼容的任何值。 返回 void 的方法将忽略此值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是 intercept &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(ser, objects);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">ser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CGLibProxyFactory</span>().getObject();</span><br><span class="line">        ser.web();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的官方文档阅读理解</title>
    <url>/%E5%AD%A6%E4%B9%A0/2022-01-07-mybatis%E7%9A%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="mybatis整体架构"><a href="#mybatis整体架构" class="headerlink" title="mybatis整体架构"></a>mybatis整体架构</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><img src="https://tu.yegetables.com/images/2021/12/01/image-20211201184013265a5403b89708a7273.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyBatis 的核心组件分为 4 个部分 :</span><br><span class="line"></span><br><span class="line">SqlSessionFactoryBuilder(构造器)：它会根据配置或者代码来生成 SqlSessionFactory，采用的是分步构建的 Builder 模式。</span><br><span class="line"></span><br><span class="line">SqlSessionFactory(工厂接口):依靠它来生成 SqlSession , 使用的是工厂模式。</span><br><span class="line"></span><br><span class="line">SqlSession (会话):  一个既可以发送 SQL 执行返回结果，也可以获取 Mapper 的接口。在现有的技术中， 一般我们会让其在业务逻辑代码中“消失”，而使用的是My Batis 提供的 SQLMapper接口编程技术，它能提高代码的可读性和可维护性 。</span><br><span class="line"></span><br><span class="line">SQL  Mapper  (映射器)： MyBatis 新设计存在的组件，它由一个 Java 接口和 XML文件（或注解〉构成，需要给出对应的 SQL 和映射规则。它负责发送 SQL 去执行，并返回结果 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="创建Factory"><a href="#创建Factory" class="headerlink" title="创建Factory"></a>创建Factory</h2><h3 id="1-xml"><a href="#1-xml" class="headerlink" title="1.xml"></a>1.xml</h3><p>在 MyBatis 中的 XML 分为两类，</p>
<p>一类是基础配置文件，通常只有一个，主要 是配置一些最基本的上下文参数和运行环境 ；</p>
<p> 另一类是映射文件，它可以配置映射关系、SQL 、 参数等信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>	</span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span><span class="comment">&lt;!-- 别名 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">typeAlias</span>  <span class="attr">alias</span>= <span class="string">&quot;role&quot;</span> <span class="attr">type</span>= <span class="string">&quot;com.learn.ssm.chapter3.pojo.Role&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 数据库环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://ip:port/jsp&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;......&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;......&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><typeAliases><!-- 别名 -->  这样定义后，在 MyBatis 上下文中就可以使用别名去代替全限定名了。</p>
<p><environment>元素的定义, 这里描述的是数据库。 它里面的<transactionManager>元素是配置事务管理器，这里采用的是 MyBatis 的 JDBC 管理器方式。然后采用<dataSource>元素配置数据库，其中属性 type＝”POOLED”代表采用 MyBatis 内部提供的连接池方式，最后定义一些关于 JDBC 的属性信息。</p>
<p><mapper>元素代表引入的那些映射器</p>
<p>从配置文件创建Factory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">getFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">Factory_Xml</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputStream = Resources.getResourceAsStream(Factory_Xml);</span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mySqlSessionFactory</span>().getFactory_FromXml();</span><br><span class="line">    <span class="type">var</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">    <span class="type">var</span> <span class="variable">con</span> <span class="operator">=</span> session.getConnection();</span><br><span class="line">    System.out.println(<span class="string">&quot;connection&quot;</span> + con);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-配合properties文件"><a href="#2-配合properties文件" class="headerlink" title="2.配合properties文件"></a>2.配合properties文件</h3><h4 id="3-1-正常上下文配置"><a href="#3-1-正常上下文配置" class="headerlink" title="3.1 正常上下文配置"></a><strong>3.1 正常上下文配置</strong></h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbcUrl</span>=<span class="string">jdbc:mysql://ip:3306</span></span><br><span class="line"><span class="attr">database</span>=<span class="string">jsp</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">jsp</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;archdb.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span><span class="comment">&lt;!-- 别名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;book&quot;</span> <span class="attr">type</span>=<span class="string">&quot;pojo.Book&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbcUrl&#125;/$&#123;database&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbcUrl&#125;/$&#123;database&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="3-2-properties文件不写敏感信息"><a href="#3-2-properties文件不写敏感信息" class="headerlink" title="3.2 properties文件不写敏感信息"></a>3.2 properties文件不写敏感信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inputStream = Resources.getResourceAsStream(Factory_Xml);</span><br><span class="line"><span class="comment">// properties 文件可以不写敏感信息，程序中动态添加</span></span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;archdb.properties&quot;</span>));</span><br><span class="line">properties.setProperty(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;ajian&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">// build方法用properties替换原先xml的dataBase配置</span></span><br><span class="line">sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream, properties);    </span><br><span class="line"><span class="keyword">return</span> sqlSessionFactory;</span><br></pre></td></tr></table></figure>





<h2 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h2><p>映射器是 MyBatis 中最重要、最复杂的组件，它由一个接口和对应的 XML 文件（或 注解〉组成。它可以配置以下内容 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">描述映射规则 </span><br><span class="line">提供 SQL 语句，并可以配置 SQL 参数类型、返回类型、缓存刷新等信息。</span><br><span class="line">配置缓存</span><br><span class="line">提供动态 SQL </span><br></pre></td></tr></table></figure>

<p>映射器的主要作用就是将 SQL 查询到的结果映射为一个 POJO，或者将 POJO 的数据 插入到数据库中 ， 并定义一些关于缓存等的重要内容。</p>
<p>注意 ， 开发只是一个接口 ， 而不是一个实现类。接口不能直接运行 。 MyBatis 运用了动态代理技术使 得接口能运行起来 </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们有一个book的POJO 类</p>
<h4 id="1-xml-1"><a href="#1-xml-1" class="headerlink" title="1.xml"></a>1.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;pojo/BookMapper.xml&quot;</span>/&gt;</span>  //指定 使用的mapper.xml文件路径</span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在 pojo/BookMapper.xml  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;pojo.BookMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;pojo.Book&quot;</span>&gt;</span></span><br><span class="line">        select number, name, language</span><br><span class="line">        from books</span><br><span class="line">        where number = #&#123;number&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--在 pojo/BookMapper.java  --&gt;</span></span><br><span class="line">public interface BookMapper &#123;</span><br><span class="line">    public Book getBook(int number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- test.java  --&gt;</span></span><br><span class="line">   Book book1 = (Book) session.selectOne(&quot;pojo.BookMapper.getBook&quot;, 1);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper&gt;元素中的属性 namespace 所对应的是一个接口的全限定名 ， 于是 MyBatis 上下文就可以通过它找到对应的接口。</span><br><span class="line"></span><br><span class="line">&lt;select&gt;元素表明这是一条查询语旬 ， 而属性 id 标识了这条 SQL，属性</span><br><span class="line">parameterType= &quot;long” 说明传递给 SQL 的是一个 long型的参数 ，而 resultType＝”role”</span><br><span class="line">表示返回的是一个 role 类型的返回值。而 role 是之前配置文件 mybatis-config.xml</span><br><span class="line">配置的别名，指代的是 com.pojo.Role</span><br><span class="line"></span><br><span class="line">这条 SQL 中的＃&#123;id&#125;表示传递进去的参数。</span><br></pre></td></tr></table></figure>
<p>注意，我们并没有配置 SQL 执行后和 role 的对应关系  其实这里采用的是一种被称为自动映射的功能， MyBatis在默认情况下提供自动映射 ， 只要 SQL 返回的列名能和 POJO 对应起来即可。这里 SQL 返回的列名 id 和 note 是可以和之前定义的POJO 的属性对应起来的 ，而表里的列 role_name通过 SQL别名的改写 ，使其成为 roleName,<br>也是和 POJO 对应起来的，所以此时 MyBatis 就可以把 SQL 查询的结果通过自动映射的功<br>能映射成为一个 POJO 。</p>
<h4 id="2-注解"><a href="#2-注解" class="headerlink" title="2.注解"></a>2.注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  pojo.UserMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id, username, password from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// mybatis-config.xml</span></span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper class=<span class="string">&quot;pojo.UserMapper&quot;</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">            </span><br><span class="line"><span class="comment">// test.java        </span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) session.selectOne(<span class="string">&quot;pojo.UserMapper.getUser&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="使用SqlSession"><a href="#使用SqlSession" class="headerlink" title="使用SqlSession"></a>使用SqlSession</h2><p><code> SqlSessionFactory</code> 是一个接口，在 MyBatis 中它存在两个实现类 ：<br>       <code>SqlSessionManager</code>和<code>DefaultSqlSessionFactory</code> 。<br>        一般而言，具体是由 <code>DefaultSqlSessionFactory</code> 去实现的，而 <code>SqlSessionManager</code>使用在多线程的环境中，它的具体实现依靠 <code>DefaultSqlSessionFactory</code></p>
<p><img src="https://tu.yegetables.com/images/2021/12/01/image-20211201185546386.png"></p>
<p><code>SqlSessionFactory</code> 唯一的作用就是生产 <code>MyBatis</code> 的核心接口对象 <code>SqlSession</code>，所以它的责任<br>是唯一的 。 我们往往会采用单例模式处理它</p>
<p>作用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取 Mapper 接口。</span><br><span class="line">发送 SQL 给数据库。</span><br><span class="line">控制数据库事务。</span><br></pre></td></tr></table></figure>



<h3 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 SqlSession</span></span><br><span class="line"><span class="type">SqlSession</span>  <span class="variable">sqlSession</span>  <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">	<span class="comment">//打开 SqlSession会话</span></span><br><span class="line">	sqlSession  = SqlSessionFactory.openSession() ; </span><br><span class="line">	</span><br><span class="line">    <span class="comment">//some  code </span></span><br><span class="line">	</span><br><span class="line">    sqlSession. commit() ; <span class="comment">//提交事务</span></span><br><span class="line">    </span><br><span class="line">&#125;  <span class="keyword">catch</span>(Exception  ex) &#123; </span><br><span class="line">    </span><br><span class="line">	sqlSession.rollback();<span class="comment">//回滚事务</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//在finally语句中确保资源被顺利关闭</span></span><br><span class="line">	<span class="keyword">if</span>  ( sqlSession != <span class="literal">null</span>) &#123; </span><br><span class="line">		sqlSession.close(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 SqlSession 的获取 Mapper 接口和发送 SQL 的功能需要先实现映射器的功能，而<br>映射器接口也可以实现发送 SQL 的功能</p>
<h3 id="发送sql"><a href="#发送sql" class="headerlink" title="发送sql"></a>发送sql</h3><h4 id="用-Mapper接口发送-SQL-好"><a href="#用-Mapper接口发送-SQL-好" class="headerlink" title="用 Mapper接口发送 SQL (好)"></a>用 Mapper接口发送 SQL (好)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mySqlSessionFactory</span>().getFactory_FromXml();</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">    <span class="comment">// 提供mapper的class 名，获取mapper接口对象</span></span><br><span class="line">    <span class="type">BookMapper</span> <span class="variable">bookmapper</span> <span class="operator">=</span> session.getMapper(BookMapper.class);</span><br><span class="line">    <span class="comment">// 用接口的方法获取pojo</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> bookmapper.getBook(<span class="number">1</span>);</span><br><span class="line">    System.out.println(book1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>目的是为了创建SqlSessionFactoy，创建完成后销毁</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象，需要一直存在，以单例模式创建</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory</p>
<p>try…catch .. . finally …语句来保证其正确关闭</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>生命周期应该小于等于 Sq!Session 的生命周期</p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mySqlSessionFactory</span>().getFactory_FromXml();</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> factory.openSession();</span><br><span class="line">        <span class="type">BookMapper</span> <span class="variable">bookmapper</span> <span class="operator">=</span> session.getMapper(BookMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//select</span></span><br><span class="line">        <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> bookmapper.getBook(<span class="number">1</span>);</span><br><span class="line">        System.out.println(book1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//insert</span></span><br><span class="line">        <span class="type">Book</span> <span class="variable">book2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book2.setName(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        book2.setLanguage(<span class="string">&quot;chinese&quot;</span>);</span><br><span class="line">        book2.setNumber(<span class="number">2</span>);</span><br><span class="line">        bookmapper.insertBook(book2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Book</span> <span class="variable">book3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book3.setName(<span class="string">&quot;jsp&quot;</span>);</span><br><span class="line">        book3.setLanguage(<span class="string">&quot;chinese&quot;</span>);</span><br><span class="line">        book3.setNumber(<span class="number">3</span>);</span><br><span class="line">        bookmapper.insertBook(book3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//update</span></span><br><span class="line">        book1.setLanguage(<span class="string">&quot;english&quot;</span>);</span><br><span class="line">        bookmapper.updateBook(book1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//delete</span></span><br><span class="line">        bookmapper.deleteBook(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="BookMapper-xml"><a href="#BookMapper-xml" class="headerlink" title="BookMapper.xml"></a>BookMapper.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;pojo.book.BookMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;pojo.book.Book&quot;</span>&gt;</span></span><br><span class="line">        select number, name, language</span><br><span class="line">        from books</span><br><span class="line">        where number = #&#123;number&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;pojo.book.Book&quot;</span>&gt;</span></span><br><span class="line">        insert into books (name, number, language)</span><br><span class="line">        values (#&#123;name&#125;, #&#123;number&#125;, #&#123;language&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;pojo.book.Book&quot;</span>&gt;</span></span><br><span class="line">        update books</span><br><span class="line">        set name=#&#123;name&#125;,</span><br><span class="line">            language=#&#123;language&#125;</span><br><span class="line">        where number = #&#123;number&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        delete</span><br><span class="line">        from books</span><br><span class="line">        where number = #&#123;number&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="BookMapper"><a href="#BookMapper" class="headerlink" title="BookMapper"></a>BookMapper</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getBook</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertBook</span><span class="params">(Book book)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteBook</span><span class="params">(<span class="type">int</span> number)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h2><h3 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h3><h4 id="seetings"><a href="#seetings" class="headerlink" title="seetings"></a>seetings</h4><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">mybatis-配置</a>	</p>
<p><img src="https://tu.yegetables.com/images/2021/12/02/20211202230704.png"></p>
<p><img src="https://tu.yegetables.com/images/2021/12/02/20211202230646.png"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;key&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h4 id="类型别名（typeAliases）"><a href="#类型别名（typeAliases）" class="headerlink" title="类型别名（typeAliases）"></a>类型别名（typeAliases）</h4><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    //每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。</span><br><span class="line">      <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line">    //@Alias(&quot;author&quot;)</span><br><span class="line">    //public class Author &#123;</span><br><span class="line">    //	...</span><br><span class="line">    //&#125;</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="类型处理器（typeHandlers）"><a href="#类型处理器（typeHandlers）" class="headerlink" title="类型处理器（typeHandlers）"></a>类型处理器（typeHandlers）</h4><p>MyBatis 在设置预处理语句（<code>PreparedStatement</code>）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。</p>
<p>在<code> typeHandler</code> 中，分为<code> jdbcType</code> 和 <code>javaType </code>， 其中 <code>jdbcType </code>用于定义数据库类型，而 <code>javaType </code>用于定义 Java 类型，那么  <code>typeHandler  </code>的作用就是承担 <code>jdbcType </code>和<code> javaType</code> 之间的相互转换</p>
<p>自定义枚举或者特殊数据类型 需要自定义handler来处理</p>
<p><img src="https://tu.yegetables.com/images/2021/12/02/20211202230553.png"></p>
<p><img src="https://tu.yegetables.com/images/2021/12/02/20211202230605.png"></p>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>在绝大多数情况下 ， typeHandler 因为枚举而使用， MyBatis 已经定义了两个类作为枚举类型的支持，这两个类分别是 ：</p>
<p>• EnumOrdinalTypeHandler 。	&#x2F;&#x2F; 表存 枚举值（0,1,2）</p>
<p>• EnumTypeHandler 。		    	&#x2F;&#x2F; 表存字面量</p>
<h4 id="Blob文件"><a href="#Blob文件" class="headerlink" title="Blob文件"></a>Blob文件</h4><p>byte[]   —–&gt; blob</p>
<p>可以使用系统注册的   <code>typeHandle</code>  —–&gt;   <code>BlobTypeHandler</code> 来转换</p>
<p>为了减轻jvm的压力，一般采用文件流的形式，将<code> byte[]</code> 类型转为<code> InputStream</code>的形式，  <code>Mybatis</code> 使用 <code>BloblnputStream</code> <code>TypeHandler</code>为你转换结果</p>
<p> 但实际最好用路径存文件,不要用 数据库存纯文件信息</p>
<h4 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h4><p>在 MyBatis 中，运行环境主要的作用是配置数据库信息</p>
<p>他下面分为两个可配置元素  ： 事物管理器<code>transactionmanager</code> 和 数据源 <code>dataSource</code></p>
<p><strong>尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境</strong></p>
<p>如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例</p>
<p>指定环境创建Factory，不写则加载默认环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment, properties);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development1&quot;</span>&gt;</span><span class="comment">&lt;!--      配置环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development1&quot;</span>&gt;</span><span class="comment">&lt;!--    环境变量           --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span><span class="comment">&lt;!--           事务管理器     --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span><span class="comment">&lt;!--           数据源     --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbcUrl&#125;/$&#123;database&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h5 id="事物管理器-transactionManager"><a href="#事物管理器-transactionManager" class="headerlink" title="事物管理器 transactionManager"></a>事物管理器 transactionManager</h5><p>transactionManager 提供了两个实现类（  JdbcTransaction  ， ManagedTransaction  ），它需要实现接口 Transaction </p>
<p><img src="https://tu.yegetables.com/images/2021/12/06/20211206151803.png"></p>
<p>于是它对应着两种工厂 ： JdbcTransactionF actory 和 ManagedTransactionFactory ， 这个工<br>厂需要实现 TransactionFactory 接口，通过它们会生成对应的 Transaction对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span>  <span class="attr">type</span>= <span class="string">&quot; JDBC &quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span>  <span class="attr">type</span>=<span class="string">&quot; MANAGED &quot;</span> /&gt;</span>        </span><br></pre></td></tr></table></figure>



<p>JDBC 使用 JdbcTransactionFactory 生成的 JdbcTransaction 对象实现。它是以 JDBC的方式对数据库的提交和回滚进行操作。</p>
<p>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。</p>
<p>如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</p>
<h5 id="dataSource数据源"><a href="#dataSource数据源" class="headerlink" title="dataSource数据源"></a>dataSource数据源</h5><p>有三种内建的数据源类型（也就是 type&#x3D;”[UNPOOLED|POOLED|JNDI]”）：</p>
<h6 id="UNPOOLED"><a href="#UNPOOLED" class="headerlink" title="UNPOOLED"></a><strong>UNPOOLED</strong></h6><p> 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。</p>
<ul>
<li><code>driver</code> – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。</li>
<li><code>url</code> – 这是数据库的 JDBC URL 地址。</li>
<li><code>username</code> – 登录数据库的用户名。</li>
<li><code>password</code> – 登录数据库的密码。</li>
<li><code>defaultTransactionIsolationLevel</code> – 默认的连接事务隔离级别。</li>
<li><code>defaultNetworkTimeout</code> – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。查看 <code>java.sql.Connection#setNetworkTimeout()</code> 的 API 文档以获取更多信息。</li>
</ul>
<h6 id="POOLED"><a href="#POOLED" class="headerlink" title="POOLED"></a><strong>POOLED</strong></h6><p> 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。</p>
<p>除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：</p>
<ul>
<li><code>poolMaximumActiveConnections</code> – 在任意时间可存在的活动（正在使用）连接数量，默认值：10</li>
<li><code>poolMaximumIdleConnections</code> – 任意时间可能存在的空闲连接数。</li>
<li><code>poolMaximumCheckoutTime</code> – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）</li>
<li><code>poolTimeToWait</code> – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。</li>
<li><code>poolMaximumLocalBadConnectionTolerance</code> – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程。 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 <code>poolMaximumIdleConnections</code> 与 <code>poolMaximumLocalBadConnectionTolerance</code> 之和。 默认值：3（新增于 3.4.5）</li>
<li><code>poolPingQuery</code> – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动出错时返回恰当的错误消息。</li>
<li><code>poolPingEnabled</code> – 是否启用侦测查询。若开启，需要设置 <code>poolPingQuery</code> 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。</li>
<li><code>poolPingConnectionsNotUsedFor</code> – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。</li>
</ul>
<h6 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a><strong>JNDI</strong></h6><p> 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性：</p>
<ul>
<li><p><code>initial_context</code> – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。</p>
</li>
<li><p><code>data_source</code> – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。</p>
</li>
</ul>
<h4 id="数据库厂商标识（databaseIdProvider）"><a href="#数据库厂商标识（databaseIdProvider）" class="headerlink" title="数据库厂商标识（databaseIdProvider）"></a>数据库厂商标识（databaseIdProvider）</h4><p>MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 <code>databaseId</code> 属性。 MyBatis 会加载带有匹配当前数据库 <code>databaseId</code> 属性和所有不带 <code>databaseId</code> 属性的语句。 如果同时找到带有 <code>databaseId</code> 和不带 <code>databaseId</code> 的相同语句，则后者会被舍弃。 为支持多厂商特性，只要像下面这样在 mybatis-config.xml 文件中加入 <code>databaseIdProvider</code> 即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>databaseIdProvider 对应的 DB_VENDOR 实现会将 databaseId 设置为 <code>DatabaseMetaData#getDatabaseProductName()</code> 返回的字符串。</p>
<p>改造Mapper.xml，添加厂商id</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>  <span class="attr">id</span>= <span class="string">&quot;getRole&quot;</span> <span class="attr">parameterType</span>= <span class="string">&quot; long&quot;</span>  <span class="attr">resultType</span>= <span class="string">&quot;role&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;oracle &quot;</span> &gt;</span></span><br><span class="line">select  id,  role  name  as  roleName, note  from  t role  where  id = # &#123;id&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们知道使用多数据库 SQL 时需要配置 databaseldProvidertype 的属性。当 <code>databaseldProvidetype</code> 属性被配置时，系统会优先取到和数据库配置一致的 SQL 。</p>
<p>如果没有，则取没有 databaseId 的 SQL ， 可以把它当作默认值。如果还是取不到， 则会抛出异常，说明无法匹配到对应的 SQL 。</p>
<h4 id="config-mapper"><a href="#config-mapper" class="headerlink" title="config.mapper"></a>config.mapper</h4><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。</p>
<p> 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句</p>
<p>最好的办法是直接告诉 MyBatis 到哪里去找映射文件。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/06/20211206153613.png"></p>
<h3 id="Mapper-1"><a href="#Mapper-1" class="headerlink" title="Mapper"></a>Mapper</h3><p>它由一个接口加上 XML 文件（或者注解）组成</p>
<p>在映射器中可以配置参数、各类的 SQL语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的 POJO 或者其他对象上，映射器能有效消除 JDBC底层的代码。</p>
<p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p>
<ul>
<li><code>cache</code> – 该命名空间的缓存配置。</li>
<li><code>cache-ref</code> – 引用其它命名空间的缓存配置。</li>
<li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li>
<li><code>sql</code> – 可被其它语句引用的可重用语句块。</li>
<li><code>insert</code> – 映射插入语句。</li>
<li><code>update</code> – 映射更新语句。</li>
<li><code>delete</code> – 映射删除语句。</li>
<li><code>select</code> – 映射查询语句。</li>
</ul>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPerson&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>





<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>id</code></td>
<td align="left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td align="left"><code>parameterType</code></td>
<td align="left">将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td>
</tr>
<tr>
<td align="left"><del><code>parameterMap</code></del></td>
<td align="left">用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</td>
</tr>
<tr>
<td align="left"><code>resultType</code></td>
<td align="left">期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td>
</tr>
<tr>
<td align="left"><code>resultMap</code></td>
<td align="left">对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td>
</tr>
<tr>
<td align="left"><code>flushCache</code></td>
<td align="left">将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。</td>
</tr>
<tr>
<td align="left"><code>useCache</code></td>
<td align="left">将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td align="left"><code>fetchSize</code></td>
<td align="left">这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。</td>
</tr>
<tr>
<td align="left"><code>statementType</code></td>
<td align="left">可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="left"><code>resultSetType</code></td>
<td align="left">FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。</td>
</tr>
<tr>
<td align="left"><code>databaseId</code></td>
<td align="left">如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td>
</tr>
<tr>
<td align="left"><code>resultOrdered</code></td>
<td align="left">这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：<code>false</code>。</td>
</tr>
<tr>
<td align="left"><code>resultSets</code></td>
<td align="left">这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。</td>
</tr>
</tbody></table>
<h5 id="自动映射-驼峰映射"><a href="#自动映射-驼峰映射" class="headerlink" title="自动映射 驼峰映射"></a>自动映射 驼峰映射</h5><p>在 settting 元素中有两个可以配置的选项 </p>
<p><code>autoMappingBehavior</code> 和 <code>mapUnderscoreToCamel Case</code>，</p>
<p>它们是控制自动映射和驼峰映射的开关。</p>
<p> 一般而言，自动映射会使用得多一些 ，因为可以通过 SQL 别名机制处理一些细节，比较灵活，而驼峰映射则要求比较严苛，所以在实际中应用不算太广 。</p>
<p>autoMappingBehavior选项的取值范围是 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• NONE ， 不进行自动映射。</span><br><span class="line">• PARTIAL，默认值，只对没有嵌套结果集进行自动映射。</span><br><span class="line">• FULL，对所有的结果集进行自动映射，包括嵌套结果集。</span><br><span class="line"></span><br><span class="line">在默认情况下，使用默认的 PARTIAL 级别就可以了。</span><br></pre></td></tr></table></figure>

<p>如果编写的SQL 列名和属性名保持一致，那么它就会形成自动映射，</p>
<p>如果系统都严格按照驼峰命名法</p>
<p>db列名     role_name        pojo属性名  roleName</p>
<p>比如可能有些字段 有主表 和  从表关联 的 级联， 又如 <code>typeHandler</code> 的复杂转换规则，此时 resultType 元素是无法满足这些需求的。如果需要更为强大的映射规则，则需要考虑使用<code> resultMap</code></p>
<p><strong>缺点</strong>  如果值为 null   必须指定 类型处理器</p>
<p>或者用别名来    利用 自动映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    user_id             as &quot;id&quot;,</span><br><span class="line">    user_name           as &quot;userName&quot;,</span><br><span class="line">    hashed_password     as &quot;hashedPassword&quot;</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="多个传参"><a href="#多个传参" class="headerlink" title="多个传参"></a>多个传参</h5><h6 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h6><p>＠Param ( org.apache. atis .annotations.Param)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Role&gt;  <span class="title function_">findRolesByAnnotation</span></span><br><span class="line">    <span class="params">(<span class="meta">@Param</span> (<span class="string">&quot;roleName&quot;</span>)</span>String rolename , <span class="meta">@Param</span> (<span class="string">&quot;note&quot;</span> ) String note)    </span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>  <span class="attr">id</span>=<span class="string">&quot;findRolesByAnnotation&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span> &gt;</span></span><br><span class="line">    </span><br><span class="line">		select id , role  name  as roleName , note  from  t_role where role  name  like  concat （&#x27;%&#x27;，＃&#123; roleName ｝ ，&#x27;%&#x27;） and  note  like  concat （ &#x27;%&#x27;， ＃｛ note ｝ ，&#x27;%&#x27;）</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>此时并不需要给出 parameterType 属性，让 MyBatis 自动探索便可以了 </p>
<p>如果 SQL 很 复杂，拥有大于 10 个参数，那么接口方法的参数个数就多了，使用起来就很不容易</p>
<h6 id="javaBean"><a href="#javaBean" class="headerlink" title="javaBean"></a>javaBean</h6><ol>
<li><p>将参数组合成一个javabean</p>
</li>
<li><p>接口方法参数定义为此 bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Role&gt; <span class="title function_">findRolesByBean</span><span class="params">(RoleParams roleParam)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mapper.xml 中填写 select 语句 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>  <span class="attr">id</span>=<span class="string">&quot;findRolesByAnnotation&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;role&quot;</span>  <span class="attr">parameterType</span>= <span class="string">&quot; bean.RoleParams  &quot;</span>&gt;</span></span><br><span class="line">		select id , role  name  as roleName , note  from  t_role where role  name  like  concat （&#x27;%&#x27;，＃&#123; roleName ｝ ，&#x27;%&#x27;） and  note  like  concat （ &#x27;%&#x27;， ＃｛ note ｝ ，&#x27;%&#x27;）</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>4.使用时构建bean对象填充参数，调用接口方法</p>
</li>
</ol>
<h6 id="ex-混合使用-（-bean，分页器-）"><a href="#ex-混合使用-（-bean，分页器-）" class="headerlink" title="ex  :混合使用 （  bean，分页器  ）"></a>ex  :混合使用 （  bean，分页器  ）</h6><p><img src="https://tu.yegetables.com/images/2021/12/06/20211206182816.png"></p>
<h5 id="分页-RowBounds"><a href="#分页-RowBounds" class="headerlink" title="分页 RowBounds"></a>分页 RowBounds</h5><p>RowBounds 中 <code>offset</code> 属性是偏移量，即从第几行开始读取记录。<code>limit</code>是限制条数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Role&gt; <span class="title function_">findByRowBounds</span><span class="params">(<span class="meta">@Param(&quot;roleName&quot;)</span>String rolename, <span class="meta">@Param</span> (<span class="string">&quot;note&quot;</span>)</span> String note , RowBounds rowBounds) ;</span><br></pre></td></tr></table></figure>

<p>​	mapper  中 mybatis 自动识别  RowBounds 对象</p>
<pre><code> RowBounds 分页的原理是执行 SQL 的查 询后，按照偏移量和限制条数返回查询结果，
</code></pre>
<p>​	所以对于大量的数据查询，它的性能并不佳， 此时可以通过分页插件去处理，</p>
<h4 id="insert-update-delete"><a href="#insert-update-delete" class="headerlink" title="insert update delete"></a>insert update delete</h4><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>id</code></td>
<td align="left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td align="left"><code>parameterType</code></td>
<td align="left">将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td>
</tr>
<tr>
<td align="left"><del><code>parameterMap</code></del></td>
<td align="left">用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</td>
</tr>
<tr>
<td align="left"><code>flushCache</code></td>
<td align="left">将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。</td>
</tr>
<tr>
<td align="left"><code>timeout</code></td>
<td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td align="left"><code>statementType</code></td>
<td align="left">可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="left"><code>useGeneratedKeys</code></td>
<td align="left">（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td>
</tr>
<tr>
<td align="left"><code>keyProperty</code></td>
<td align="left">（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td>
</tr>
<tr>
<td align="left"><code>keyColumn</code></td>
<td align="left">（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td>
</tr>
<tr>
<td align="left"><code>databaseId</code></td>
<td align="left">如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td>
</tr>
</tbody></table>
<h5 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h5><p><strong>取得自增主键</strong></p>
<p>JDBC 中的 <code>Statement</code> 对象在执行插入的 SQL 后，可以通过 <code>getGeneratedKeys</code> 方法获得 数据库生成的主键（需要数据库驱动支持） ，这样便能达到获取主键的功能。 </p>
<p> insett 语句中有一个开关属性 <code>useGeneratedKeys</code>，用来控制是否打开这个功能，它的默认值为false 。</p>
<p>当打开了这个开关，还要配置其属性 keyPrope  即或   keyColumn ， 告诉系统把生成的主键放入哪个属性中，如果存在多个主键，就要用逗号（，）将它们隔开 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertRole&quot;</span>  <span class="attr">parameterType</span>=<span class="string">&quot;role&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true &quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> &gt;</span></span><br><span class="line">insert into t_role(role name, note) values( #&#123;roleName&#125; , #&#123;note&#125; )</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--useGeneratedKeys=&quot;true&quot; 打开了自增主键开关  ，keyProperty=&quot;id&quot; 将主键赋值给pojo的id字段 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>​		<strong>主键自定义生成</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>= <span class="string">&quot;insertRole&quot;</span> <span class="attr">parameterType</span>= <span class="string">&quot;role&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>= <span class="string">&quot;id&quot;</span> <span class="attr">result_Type</span>= <span class="string">&quot;long&quot;</span> <span class="attr">order</span>= <span class="string">&quot;BEFORE&quot;</span> &gt;</span></span><br><span class="line">          select if (max(id) =null, 1, max(id) + 3) from t_role </span><br><span class="line">		<span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into t role(id, role name , note) values(#&#123;id&#125; , #&#123;roleName&#125;, #&#123;note&#125;) </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义了 selectKey 元素，它的<code> keyPrope</code>  即指定了采用哪个属性作为 <code>POJO 的主键</code>。</p>
<p>resultType 告诉 MyBatis 将返回一个 long 型的结果集，而 order 设置为 BEFORE,说明它将于当前定义的 SQL 前执行。通过这样就可以自定义主键的规则，可见 MyBatis 十分灵活。这里的 order 配置为 BEFORE， 说明它会在插入之前会先执行生成主键的 SQL, 然后插入数据。如果有一些特殊需要，可以把它设置为 AFTER，比如一些插入语句内部可<br>能有嵌入索引调用，这样它就会在插入语句之后执行了。</p>
<h4 id="SQL元素（预编写语句）"><a href="#SQL元素（预编写语句）" class="headerlink" title="SQL元素（预编写语句）"></a>SQL元素（预编写语句）</h4><p>sql 元素的作用在于可以定义一条 SQL 的一部分，方便后面的 SQL 引用它，比如最典 型的列名。 通常情况下要在 select 、insert 等语句中反复编写它们，特别是那些字段较多的表更是如此</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapper.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;roleCols&quot;</span> &gt;</span></span><br><span class="line">	id,name,language</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”getRole</span> ” <span class="attr">parameterType</span>=<span class="string">&quot; long&quot;</span> <span class="attr">resultMap</span>=<span class="string">”</span> <span class="attr">roleMap</span> ” &gt;</span></span><br><span class="line">		select    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>＝&quot;<span class="attr">roleCols</span>&quot; /&gt;</span> 	from t_role where id=#&#123;id&#125;       </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并且可以定义变量</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207001546403.png" alt="image-20211207001546403"></p>
<p>在 include 元素中定义了 一个命名为 alias 的变量，其值是 SQL 中表 t_role 的别名 ，然后 sql 元素就能够使用这个变量名了。</p>
<h4 id="字符串替换-columns｝"><a href="#字符串替换-columns｝" class="headerlink" title="字符串替换 $ {columns｝"></a>字符串替换 $ {columns｝</h4><p>比如为 了减缓数据库表的压力 ， 有些企业会将一张很大 的数据库表按年份拆分，比如购买记录表（ t_purchase <em>records ) 。 现实中由于记录 比较多 ， 可能为了方便按年份拆分为 t_purchase_records</em> 2016 、t_purchase_records_ 2017 、<br>t_purchase_reco时s_2018 等，这时往往需要构建动态表名</p>
<p>构建动态列名常常要传递类似于字符串的 columns＝” coll , col2, col3 … ”给 SQL ，让其组装成为 SQL 语句。</p>
<p>可以写成 select $ {columns｝from t_tablename ，这样 MyBatis 就不会转译 columns ，而不是作为 SQL 的参数进行设置了，而变为直出，这句 SQL 就会变为 select coll , col2, col3 … from t_tablename 。</p>
<h4 id="ResultMap"><a href="#ResultMap" class="headerlink" title="ResultMap"></a>ResultMap</h4><p>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p>
<h5 id="Pojo存储结果集"><a href="#Pojo存储结果集" class="headerlink" title="Pojo存储结果集"></a>Pojo存储结果集</h5><p><img src="https://tu.yegetables.com/images/2021/12/09/image-20211209100628809.png" alt="image-20211209100628809"></p>
<p>在学习了上面的知识后，你会发现上面的例子没有一个需要显式配置 <code>ResultMap</code>，这就是 <code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。 虽然上面的例子不用显式配置 <code>ResultMap</code>。 但为了讲解，我们来看看如果在刚刚的示例中，显式使用外部的 <code>resultMap</code> 会怎样，这也是解决列名不匹配的另外一种方式。</p>
<p>resultMap 元素的属性 id 代表这个 resultMap 的标识，  type 代表着需要映射的 POJO,<br>这里可以使用 MyBatis 定义好的类的别名，也可以使用自定义的类的全限定名。</p>
<p>在映射关系中 ， id 元素表示这个对象的主键， propety 代表着 POJO 的属性名称， column 表示数据库 SQL 的列名，于是 POJO 就和数据库 SQL 的结果一一对应起来了</p>
<p><id> 为主键 							         <result> 为普通列  </p>
<p><property> 为  <code>pojo</code>  的属性        <column>为表列名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;roleResultMap&quot;</span> <span class="attr">type</span>&quot;<span class="attr">com.Role</span>&quot; &gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>＝ &quot;<span class="attr">id</span>&quot; <span class="attr">column</span> ＝ &quot;<span class="attr">id</span>&quot; /&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;roleName&quot;</span>  <span class="attr">column</span>= <span class="string">&quot;role_name &quot;</span> /&gt;</span></span><br><span class="line">			    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">”</span> <span class="attr">note</span> ” <span class="attr">column</span>=<span class="string">”</span> <span class="attr">note</span> ”/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//然后在引用它的语句中设置 resultMap 属性就行了（注意我们去掉了 resultType 属性）。比如:</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">parameterType</span>=<span class="string">”</span> <span class="attr">long</span> ” <span class="attr">id</span>=<span class="string">”getRole</span> ” <span class="attr">resultMap</span> = <span class="string">”</span> <span class="attr">roleResultMap</span>”&gt;</span></span><br><span class="line">		select id , role name, note from t role where id =#&#123;id&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/12/09/image-20211209102328905.png" alt="image-20211209102328905"></p>
<h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><p> constructor 元素用于配置构造方法。 一个 POJO 没有无参构造方法 可以使用 constructor 进行配置。</p>
<pre><code> idArg 标识主键 
</code></pre>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">......</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">&quot;role_name&quot;</span> <span class="attr">javaType</span>= <span class="string">&quot;string&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="C:/Users/Ajian/AppData/Roaming/Typora/typora-user-images/image-20211207003553367.png" alt="image-20211207003553367"></p>
<h5 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h5><p>一个角色可能有多个用户，这就是一对多的级联：</p>
<p>还有一对一 的级联， 比如身份证和公民是一对一 的关系。</p>
<p>在 MyBatis 中还有一种被称为鉴别器的级联，它是一种可以选择具体实现类的级联，比如要查找雇员及其体检表的信息 ，但是雇员有性别之分，而根据性别的不同，其体检表的项目也会不一样，那么体检表就应该分为男性和女性两种，从而根据雇员 性别区分关联。</p>
<p>级联不是必须的，级联的好处是获取关联数据十分便捷，但是级联过多会增加系统的<br>复杂度，同时降低系统的性能，此增彼减，所以当级联的层级超过 3 层时，就不要考虑使<br>用级联了，因为这样会造成多个对象的关联，导致系统的精合、复杂和难以维护</p>
<p>My Batis 的级联分为 3 种。</p>
<p>·鉴别器（ discriminator ）：它是一个根据某些条件决定采用具体实现类级联的方案，<br>比如体检表要根据性别去区分。</p>
<p>·一对一（ association ）：比如学生证和学生就是一种一对一的级联，雇员和工牌表也<br>是一种一对一 的级联。</p>
<p>·一对多（ collection ）：比如班主任和学生就是一种一对多的级联。</p>
<h6 id="association-一对一"><a href="#association-一对一" class="headerlink" title="association  一对一"></a><strong>association  一对一</strong></h6><p>你需要告诉 MyBatis 如何加载关联。MyBatis 有两种不同的方式加载关联：</p>
<ul>
<li><p>嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。</p>
</li>
<li><p>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。</p>
</li>
</ul>
<p>java代码中      <code>pojo1</code> 的一个 属性为 <code>pojo2</code></p>
<p>但是表中         <code>table1</code> 的 某个列 为 <code>table2</code>  的主键 id</p>
<p>已知   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeTask</span>&#123;</span><br><span class="line">   id , empid,</span><br><span class="line">    Task,   </span><br><span class="line">    name ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>&#123;</span><br><span class="line">    ..........</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------</span></span><br><span class="line">table1       id,empid,id_2,name</span><br><span class="line">    </span><br><span class="line">table2       id_2, xxx </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>####### select 嵌套查询</p>
<p>查询填充pojo1时 , 若其中一个元素 需要再次查询, 使用 <code>association</code> 关联</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span>   <span class="attr">type</span>=<span class="string">&quot;EmployeeTask&quot;</span> <span class="attr">id</span>=<span class="string">&quot;EmployeeTaskMap&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>= <span class="string">”</span> <span class="attr">id</span>” <span class="attr">property</span>= <span class="string">”</span> <span class="attr">id</span>” /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>= <span class="string">”</span> <span class="attr">emp_id</span>” <span class="attr">property</span>= <span class="string">”</span> <span class="attr">empid</span>” / &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>= <span class="string">”</span> <span class="attr">task</span> <span class="attr">name</span> ” <span class="attr">property</span>= <span class="string">”</span> <span class="attr">taskName</span> ” / &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>= <span class="string">”</span> <span class="attr">note</span> ” <span class="attr">property</span>= <span class="string">”</span> <span class="attr">note</span> ” /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>＝&quot;<span class="attr">task</span>&quot;  <span class="attr">column</span>＝&quot;<span class="attr">task_id</span>&quot;   <span class="attr">select</span>=<span class="string">&quot;selectid2&quot;</span>/&gt;</span></span><br><span class="line">// 此时  第一次查询出来的列结果为 task_id  , 本意为 Task的主键   </span><br><span class="line">//  但 pojo1不存 pojo2的主键id ,而是直接对应的 pojo2 ,</span><br><span class="line">//  所以指定 association 指定 两个 pojo的关系 , 将第一次查询结果 task_id 作为 第二次查询的参数</span><br><span class="line">//  property 填写为 pojo2 , 并且指定 select的id 用 task_id为参数 调用 select填充 pojo2</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;id1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">         </span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;id2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其它所有的属性将会被自动加载，只要它们的列名和属性名相匹配。</p>
<p>这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。 概括地讲，N+1 查询问题是这样子的：</p>
<ul>
<li>你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。</li>
<li>对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。</li>
</ul>
<p>这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。</p>
<p>####### 关联结果的嵌套映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    B.id            as blog_id,</span><br><span class="line">    B.title         as blog_title,</span><br><span class="line">    B.author_id     as blog_author_id,</span><br><span class="line">    A.id            as author_id,</span><br><span class="line">    A.username      as author_username,</span><br><span class="line">    A.password      as author_password,</span><br><span class="line">    A.email         as author_email,</span><br><span class="line">    A.bio           as author_bio</span><br><span class="line">  from Blog B left outer join Author A on B.author_id = A.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">//  注意查询中的连接，以及为确保结果能够拥有唯一且清晰的名字，我们设置的别名。 这使得进行映射非常简单。现在我们可以映射这个结果：</span><br><span class="line">//  使用 join 并给 所有结果设置别名 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在pojo1 的 resultmap 映射规则中 调用 pojo2 的 resultmap id</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    // column 为pojo2的主键 </span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;authorResult&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;authorResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用 join一次查找所有的列 ,用多个 resultmap来 填充pojo</p>
<p>上面的示例使用了外部的结果映射元素来映射关联。这使得 Author 的结果映射可以被重用</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>resultMap</code></td>
<td align="left">结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 <code>ResultSet</code>。这样的 <code>ResultSet</code> 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。</td>
</tr>
<tr>
<td align="left"><code>columnPrefix</code></td>
<td align="left">当连接多个表时，你可能会不得不使用列别名来避免在 <code>ResultSet</code> 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。</td>
</tr>
<tr>
<td align="left"><code>notNullColumn</code></td>
<td align="left">默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。</td>
</tr>
<tr>
<td align="left"><code>autoMapping</code></td>
<td align="left">如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配 <code>select</code> 或 <code>resultMap</code> 元素使用。默认值：未设置（unset）。</td>
</tr>
</tbody></table>
<p>####### resultSet</p>
<h6 id="collection-一对多"><a href="#collection-一对多" class="headerlink" title="collection 一对多"></a>collection 一对多</h6><p><img src="https://pic4.zhimg.com/v2-9bbe3514629be1ae180003f3078055cf_r.jpg" alt="img"></p>
<p>collection 几乎和  association 一样</p>
<p>你会注意到有一个新的 “ofType” 属性。这个属性非常重要，它用来将 JavaBean（或字段）属性的类型和集合存储的类型区分开来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptMap1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;dept_deptno&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span>/&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- column 属性对应来自一方（一对多的一）表主键的字段名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;employeeList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Employee&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_deptno&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_no&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empNo&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;e_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eName&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">	 <span class="comment">&lt;!-- 又比如 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectPostsForBlog&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="鉴别器"><a href="#鉴别器" class="headerlink" title="鉴别器"></a>鉴别器</h6><p>对于因为  列值 不同  ,而映射关系不同 </p>
<p>使用 <code>鉴别器discriminator</code> 和  case  语句   指定 <code>resultmap</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;vehicleResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Vehicle&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;vin&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vin&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;year&quot;</span> <span class="attr">column</span>=<span class="string">&quot;year&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;make&quot;</span> <span class="attr">column</span>=<span class="string">&quot;make&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;model&quot;</span> <span class="attr">column</span>=<span class="string">&quot;model&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;color&quot;</span> <span class="attr">column</span>=<span class="string">&quot;color&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">         <span class="comment">&lt;!-- 鉴别器  colunmn 指定被比较的列 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">column</span>=<span class="string">&quot;vehicle_type&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;carResult&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;truckResult&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;vanResult&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;suvResult&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//-----------------------------------------------------------------</span><br><span class="line">// 或者 case 不指定结果集 ,直接指定映射关系</span><br><span class="line"> <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;carResult&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;doorCount&quot;</span> <span class="attr">column</span>=<span class="string">&quot;door_count&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">//-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">使用   被指定的结果集   的映射关系</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;carResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Car&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;doorCount&quot;</span> <span class="attr">column</span>=<span class="string">&quot;door_count&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="n-1-延迟加载"><a href="#n-1-延迟加载" class="headerlink" title="n+1 延迟加载"></a>n+1 延迟加载</h6><p>假设现在有 N 个关联关系完成了级联，那么只要再加入一个关联关系，就变成了 N+l<br>个级联，所有的级联 SQL 都会被执行 ，显然会有很多并不是我们关心的数据被取出，这样<br>会造成很大的资源浪费，这就是 N+l 问题，尤其是在那些需要高性能的互联网系统中，这<br>往往是不被允许的。</p>
<p>比 如作为 一个雇员的管理者，他只想看到员 工信息和员工任务信息，那么体检表和工牌的信<br>息就是多余的。</p>
<p>如果像上面那样取出所有属性，就会使数据库多执行几条毫无意义的 SQL 。<br>如果需要在雇员信息系统里加入一个关联信息，那么它在默认情况下会执行 SQL 取出数据，<br>而真实的需求往往只要完成雇员和雇员任务表的级联就可 以了，不需要把所有信息都加载<br>进来，因为有些信息并不常用，加载它们会多执行几条毫无用 处的 SQL，导致数据库资源<br>的损耗和系统性能的下降。</p>
<p>为了应对 N+l 问题， MyBatis 提供了延迟加载功能</p>
<p>即在一开始取雇员信息时，并不 需要将工牌表、体检表、任务表的记录取出 ，而是只将雇员信息和雇员任务表的信息取出 。 当我们通过雇员 POJO 访问工牌表时，体检表和任务表的记录时才通过对应的 SQL 取出，</p>
<p><img src="https://tu.yegetables.com/images/2021/12/10/image-20211210215138555.png" alt="image-20211210215138555"></p>
<p><img src="https://tu.yegetables.com/images/2021/12/10/image-20211210215249465.png" alt="image-20211210215249465"></p>
<p>选项 lazyLoadingEnabled 决定是否开启延迟加载 ， 而选项 aggressiveLazyLoading 则控<br>制是否采用层级加载，但是它们都是全局性的配置，并不能解决我们的需求。加载雇员 信<br>息时，只加载雇员任务信息，因为层级加载会把工牌信息也加载进来 。 为了处理这个问题，<br>在 MyBatis 中使用 fetchType 属性，它可以处理全局定义无法处理的问题，进行自定义 。</p>
<p><code>fetch Type</code> 出现在级联元素（ association 、  collection ，注意，  discriminator 没有这个属性可配置）中 ，它存在着两个值：</p>
<p>•<code>eager</code>，获得当前 POJO 后立即加载对应的数据 。</p>
<p>•<code>lazy</code> ，获得当前 POJO 后延迟加载对应的数据。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/10/image-20211210215646215.png" alt="image-20211210215646215"></p>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>一级续存和二级缓存</p>
<p>一级缓存是在<code> SqI Session</code> 上的缓存，  默认开启</p>
<p>二级缓存是在 <code>SqlSessionFactory</code> 上的缓存</p>
<h6 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h6><p>当一个 SqlSession 第一次通过 SQL 和参数获取对 象后，它就会将其缓存起来，如果下次的 SQL 和参数都没有发生变化， 并且缓存没有超时 或者声明需要刷新时 ， 那么它就会从缓存中获取数据 ，而不是通过 SQL 获取了</p>
<p>注意 commit（）方法的使用，如果不进行 commit ， 是不会有一级缓存存在的</p>
<h6 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h6><p>这说明了 一级缓存是在 SqlSession 层面的，对于不同的 SqlSession 对象是不能共享的。为了使 SqlSession 对象之间共享相同的缓存，有时候需要开启 二级缓存，开启二级缓存很简单，只要在映射文件（ RoleMapper.xml ） 上加入代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">//  Mapper.xml </span><br></pre></td></tr></table></figure>

<p>这个时候 MyBatis 会序列化和反序列化对应的 POJO ，也就要求 POJO 是一个可序列化 的对象，那么它就必须实现<code>Serializable</code> 接口。</p>
<p>对角色类（ Role ）对象进行缓存，那 么就需要它实现 Serializable 接口 ：</p>
<p>从日志中可以看到，不同的 <code>SqlSession</code> 在获取同一条记录，都只是发送过一次 SQL 获<br>取数据因为这个时候 <code>MyBatis</code> 将其保存在   <code>SqlSessionFactory</code> 层面 ，可以 提供给各个 <code>Sq!Session </code>使用，只是它需要 一 个序列化和反序列化的过程而己，因此它需要实现 <code>Serializable</code> 接口。</p>
<h6 id="配置cache"><a href="#配置cache" class="headerlink" title="配置cache"></a>配置cache</h6><p><img src="https://tu.yegetables.com/images/2021/12/10/image-20211210221845473.png" alt="image-20211210221845473"></p>
<p>可以使用自定义的缓存，只是实现类需要实现 MyBatis 的接口 org.apache.ibatis.cache. Cache</p>
<p>在现实中 ，我们可 以使用 Redis,  MongoDB 或者其他常用的缓存 ， 假设存在一个 Redis 的缓存实现类 com.ssm . chapter5 .cache.RedisCache ，那么可以这样配置它 ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.cache.RedisCache&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;host&quot;</span> <span class="attr">value</span>=<span class="string">&quot;localhost&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这样配置后，  MyBatis 会启用缓存，同时调用 setHost(String host）方法，去设置配置的 内容。</span><br></pre></td></tr></table></figure>







<p>对于一些不想使用缓存的语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">flushCache</span>= <span class="string">&quot;false &quot;</span> <span class="attr">useCache</span>= <span class="string">”</span> <span class="attr">true</span> ” /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">flushCache</span>=<span class="string">&quot;true &quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">flushCache</span>=<span class="string">&quot;true &quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><ol>
<li><p>设计一个pojo ,  属性为 输出  和 输入 参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pojoName</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> roleName;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    Date execDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用 mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;pojoName&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;CALLABLE&quot;</span>&gt;</span></span><br><span class="line">		&#123; </span><br><span class="line">    		call funname1 (</span><br><span class="line">    			#&#123;roleName,mode=IN,jdbcType=VARCHAR&#125;,</span><br><span class="line">    			#&#123;total,ode=OUT,jdbcType=INTEGER&#125;,</span><br><span class="line">    			.......</span><br><span class="line">    	    )</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>指定 statemetType 为 CALLABLE，说明它是在使用存储过程，如果不这样声明那么<br>这段代码将会抛出异常。</p>
</li>
</ol>
<p>​		在调度存储过程中放入参数对应 的属性 ，井且在属性上通过 mode 设置了其输入或者输出参数 ，指定对应的 jdbcType ，这样 MyBatis 就会使用对应 的 typeHandler 去处理对应的类型转换。</p>
<h6 id="游标-待补充"><a href="#游标-待补充" class="headerlink" title="游标 待补充"></a>游标 待补充</h6><h4 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h4><p>因为某些查询需要许多条件，比如查询角色，可以根据角色名称或 者备注等信息查询 ，当不输入名 称时使用名称作条件就不合适了 </p>
<p>而 MyBatis 提供对 SQL 语句动态的组装能力， 使用 XML 的几个简单的元素 ，便能完成功态 SQL 的功能。大量的判断都可以在 MyBatis 的映射 XML 里面配置，以达到许多需要大量代码才能实现的功能，大大减少了代码量 ，这体现了 MyBatis 的灵活、高度可配置性和可维护性 。</p>
<h6 id="test-判断字符串"><a href="#test-判断字符串" class="headerlink" title="test 判断字符串"></a>test 判断字符串</h6><p>test 用于条件判断语旬，它在 MyBatis 中使用广泛。test 的作用相当于判断真假，在大部分场景中 ，它都是用以判断空和非空的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot; type=&#x27;Y&#x27;.toString()&quot;</span>&gt;</span></span><br><span class="line">		//ok</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于字符型直接比较</p>
<p>对于字符串   用 tostring方法比较</p>
<p><img src="https://tu.yegetables.com/images/2021/12/10/image-20211210224437659.png" alt="image-20211210224437659"></p>
<h6 id="if"><a href="#if" class="headerlink" title="if"></a>if</h6><p>它常常与 test 属性联合使用 </p>
<p>根据角色名称  roleName  去查找角色 ， 但是角色名称是一个选填条件，不填写 时，就不要用它作为条件<br>查询。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">......</span>    &gt;</span></span><br><span class="line">		select * from table1 where 1=1 </span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;roleName !=null and roleName !=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">    	and role_name like ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h6 id="choose-、when-、-otherwise-元素"><a href="#choose-、when-、-otherwise-元素" class="headerlink" title="choose 、when 、 otherwise 元素"></a>choose 、when 、 otherwise 元素</h6><p> switch… case … default. . .功能的语句 。在映射器的动态语句中 choose 、 when 、 otherwise 这 3 个元素承担了这个功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">......</span>    &gt;</span></span><br><span class="line">		select * from table1 where 1=1 </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span> // switch</span><br><span class="line">    </span><br><span class="line">         </span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span>  <span class="attr">test</span>=<span class="string">&quot;roleName !=null and roleName !=&#x27;&#x27; &quot;</span>&gt;</span> // case1</span><br><span class="line">        and role_no= #&#123;roleNo&#125;  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span>  <span class="attr">test</span>=<span class="string">&quot; ,,,,, ?条件2 &quot;</span>&gt;</span>   // case2</span><br><span class="line">        and role_name like ....</span><br><span class="line">     	<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>  //default</span><br><span class="line">        		and ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h6 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim  where  set"></a>trim  where  set</h6><p>上面示例   都加入了 一个条件  “ 1&#x3D;1 ”，如果没有加入这个条件，那么可能就变为了这样一条错误的语句：</p>
<p>而加入了条件“ 1&#x3D;1 ” 又显得相当奇怪，我们可以用 where 元素去处理 SQL 以达到预期效果，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">......</span>    &gt;</span></span><br><span class="line">		select * from table1  </span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;roleName !=null and roleName !=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">    		and role_name like ....</span><br><span class="line">    	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>有时候要去掉的是一些特殊的 SQL 语法，比如常见的 and 、 or。而使用 trim 元素也可以达到预期效果</p>
<p><img src="https://tu.yegetables.com/images/2021/12/10/image-20211210225602222.png" alt="image-20211210225602222"></p>
<p>上面的效果是  将 and 替换为 where</p>
<p>update 中 set 元素 </p>
<p><img src="https://tu.yegetables.com/images/2021/12/10/image-20211210225845183.png" alt="image-20211210225845183"></p>
<h6 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h6><p><img src="https://tu.yegetables.com/images/2021/12/10/image-20211210230030943.png" alt="image-20211210230030943"></p>
<h6 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h6><p>bind 元素的作用是通过 OGNL 表达式去自定义一个上下文变量，这样更方便使用。</p>
<p>在进行模糊查询时，如果是 MySQL 数据库，常常用到的是一个 concat，它用“%”和参数相<br>连。</p>
<p>然而在 Oracle 数据库则没有，Oracle 数据库用连接符号“｜｜”，这样 SQL 就需要提供两<br>种形式去实现。但是有了 bind 元素，就不必使用数据库的语言 ，而是使用 MyBatis 的动态<br>SQL 即可完成。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/10/image-20211210230538485.png" alt="image-20211210230538485"></p>
<p>传递进来的参数，它和通配符（%）连接后赋给了 pattern,然后就可以在 se lect 语句中使用这个变量进行模糊查询了</p>
<h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><p>My Batis 的运行过程分为两大步：</p>
<p>第1 步，读取配置文件缓存到 Configuration 对象，用以创建 Sq!SessionFactory ： </p>
<p>第 2 步，SqI Session 的执行过程 。</p>
<p> Sq!Ses sion 的执行过程就不是那么简单了，它包括许多复杂 的技术，要先掌握反射技术和动态代理技术，这是揭示 MyBatis 底层构架的基础</p>
<h3 id="SqlSessionFactory-1"><a href="#SqlSessionFactory-1" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>它采用了 Builder 模式去创建 SqlSessionFactory ， 在实际中可以通过 SqlSessionFactoryBuilder 去构建 ，<br>其构建分为两步。</p>
<ol>
<li>通过 org.apache.ibatis .builder且nl .XMLConfigBuilder 解析<strong>配置的 XML 文件</strong> ，读出所配置的参数，并将读取的内容<strong>存入 Configuration 类对象</strong>中。 而 Configuration 采用的是单例模式 ，几乎所有 的 MyBatis 配置内容都会存放在这个单例对象中，以便后续将这些内容读出。</li>
<li>使用 Confinguration 对象去创建 SqlSessionFactory 。  默认的实现类 DefaultSqlSessionFactory</li>
</ol>
<h2 id="生成sql"><a href="#生成sql" class="headerlink" title="生成sql"></a>生成sql</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">selectPersonSql</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;&#123;</span><br><span class="line">    SELECT(<span class="string">&quot;P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME&quot;</span>);</span><br><span class="line">    SELECT(<span class="string">&quot;P.LAST_NAME, P.CREATED_ON, P.UPDATED_ON&quot;</span>);</span><br><span class="line">    FROM(<span class="string">&quot;PERSON P&quot;</span>);</span><br><span class="line">    FROM(<span class="string">&quot;ACCOUNT A&quot;</span>);</span><br><span class="line">    INNER_JOIN(<span class="string">&quot;DEPARTMENT D on D.ID = P.DEPARTMENT_ID&quot;</span>);</span><br><span class="line">    INNER_JOIN(<span class="string">&quot;COMPANY C on D.COMPANY_ID = C.ID&quot;</span>);</span><br><span class="line">    WHERE(<span class="string">&quot;P.ID = A.ID&quot;</span>);</span><br><span class="line">    WHERE(<span class="string">&quot;P.FIRST_NAME like ?&quot;</span>);</span><br><span class="line">    OR();</span><br><span class="line">    WHERE(<span class="string">&quot;P.LAST_NAME like ?&quot;</span>);</span><br><span class="line">    GROUP_BY(<span class="string">&quot;P.ID&quot;</span>);</span><br><span class="line">    HAVING(<span class="string">&quot;P.LAST_NAME like ?&quot;</span>);</span><br><span class="line">    OR();</span><br><span class="line">    HAVING(<span class="string">&quot;P.FIRST_NAME like ?&quot;</span>);</span><br><span class="line">    ORDER_BY(<span class="string">&quot;P.ID&quot;</span>);</span><br><span class="line">    ORDER_BY(<span class="string">&quot;P.FULL_NAME&quot;</span>);</span><br><span class="line">  &#125;&#125;.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql必会-快速查阅</title>
    <url>/%E5%AD%A6%E4%B9%A0/2022-01-07-mysql%E5%BF%85%E4%BC%9A-%E5%BF%AB%E9%80%9F%E6%9F%A5%E9%98%85/</url>
    <content><![CDATA[<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>主键（primary key）一列（或一组列），其值能够唯一区分表中每个行。</p>
<p>表中的任何列都可以作为主键，只要它满足以下条件：</p>
<p> 任意两行都不具有相同的主键值；</p>
<p> 每个行都必须具有一个主键值（主键列不允许NULL值）。</p>
<p> 不更新主键列中的值；</p>
<p> 不重用主键列的值；</p>
<p> 不在主键列中使用可能会更改的值</p>
<h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>返回当前选择的数据库内可用表的列表。</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> COLUMNS <span class="keyword">from</span> table1;</span><br><span class="line"><span class="keyword">DESCRIBE</span> customers;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>是 <span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> customers;的一种快捷方式。</span><br><span class="line"></span><br><span class="line">要 求 给 出 一 个 表 名 （ 这 个 例 子 中 的 <span class="keyword">FROM</span> customers），它对每个字段返回一行，行中包含字段名、数据类型、是否允许<span class="keyword">NULL</span>、键信息、默认值以及其他信息（如字段cust_id的 auto_increment）。</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207091104096.png" alt="image-20211207091104096"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">HELP <span class="keyword">SHOW</span>;显示允许的<span class="keyword">SHOW</span>语句。</span><br></pre></td></tr></table></figure>



<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>  id <span class="keyword">from</span> products;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id告诉MySQL只返回不同（唯一）的id行，使用<span class="keyword">DISTINCT</span>关键字，它必须直接放在列名的前面</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>不能部分使用<span class="keyword">DISTINCT</span> <span class="keyword">DISTINCT</span>关键字应用于所有列而 不仅是前置它的列。如果给出<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id, prod_price，除非指定的两个列都不同，否则所有行都将被 检索出来</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LIMIT <span class="number">5</span>指示MySQL返回 不多于<span class="number">5</span>行。</span><br><span class="line">LIMIT <span class="number">5</span>, <span class="number">5</span>指示MySQL返回从行<span class="number">5</span>开始的<span class="number">5</span>行。第一个数为开始位置，第二个数为要检索的行数。</span><br><span class="line"></span><br><span class="line">行数从<span class="number">0</span></span><br><span class="line"></span><br><span class="line"> LIMIT <span class="number">4</span> <span class="keyword">OFFSET</span> <span class="number">3</span>意为从行<span class="number">3</span>开始取<span class="number">4</span>行，就像LIMIT <span class="number">3</span>, <span class="number">4</span>一样</span><br></pre></td></tr></table></figure>

<h3 id="排序-order-by"><a href="#排序-order-by" class="headerlink" title="排序  order by"></a>排序  order by</h3><p>默认升序</p>
<p>为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。</p>
<p>ORDER BY子句取一个或多个列的名字，据此对输出进行排序。</p>
<p>可以使用非显示列 进行排序 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  id <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>

<h5 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h5><p>为了按多个列排序，只要指定列名，列名之间用逗号分开即可（就像选择多个列时所做的那样）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  id <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> price,name;</span><br></pre></td></tr></table></figure>

<p>先按price排序,相同price 按 name 排序</p>
<h5 id="降序-order-by-desc"><a href="#降序-order-by-desc" class="headerlink" title="降序 order by  desc"></a>降序 order by  desc</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">DESC</span>关键字只应用到直接位于其前面的列名</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>, name;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 降序排price , 再排name</span><br></pre></td></tr></table></figure>



<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>​         between low and high</p>
<p>​		 where name IS NULL   &#x2F;&#x2F; 判断空值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> abc和ABC mysql中默认相同</span><br></pre></td></tr></table></figure>

<p>单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不<br>用引号。</p>
<h4 id="and-or"><a href="#and-or" class="headerlink" title="and  or"></a>and  or</h4><p>SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> (a<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> b<span class="operator">=</span><span class="number">2</span> ) <span class="keyword">and</span> c<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序，即使它确实是你想要的东西也是如此。使用圆括号没有什么坏处，它能消除歧义。</p>
<h4 id="in-not"><a href="#in-not" class="headerlink" title="in not"></a>in not</h4><p>IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全都括在圆括号中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">100</span>,<span class="number">200</span>)   <span class="operator">/</span><span class="operator">/</span> <span class="number">100</span> 或 <span class="number">200</span> </span><br></pre></td></tr></table></figure>

<p>为什么要使用IN操作符？其优点具体如下。<br> 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。<br> 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。<br> IN操作符一般比OR操作符清单执行更快。<br> IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</p>
<p>NOT WHERE子句中用来否定后跟条件的关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="keyword">in</span> (a,b)</span><br></pre></td></tr></table></figure>

<h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p>为在搜索子句中使用通配符，必须使用LIKE操作符</p>
<p>LIKE指示 MySQL 后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。</p>
<h4 id="任何字符任意次数"><a href="#任何字符任意次数" class="headerlink" title="% 任何字符任意次数"></a>% 任何字符任意次数</h4><p>最常使用的通配符是百分号（%）。在搜索串中，%表示任何字符出现任意次数</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207101953246.png" alt="image-20211207101953246"></p>
<p>还可以使用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%abc%     匹配  ( 100abc21 ,    abc3  , 1abc )</span><br></pre></td></tr></table></figure>

<p>即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行。</p>
<h4 id="任意字符-1-次"><a href="#任意字符-1-次" class="headerlink" title="_   任意字符 1 次"></a>_   任意字符 1 次</h4><p> 匹配任意字符  但下划线只匹配单个字符而不是多个字符。</p>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>REGEXP 关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> name regexp <span class="string">&#x27;1000&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207104318527.png" alt="image-20211207104318527"></p>
<p>LIKE匹配整个串而REGEXP匹配子串。利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使<br>REGEXP的作用与LIKE一样。</p>
<p>MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大<br>小写，可使用BINARY关键字，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="type">BINARY</span> <span class="string">&#x27;JetPack .000&#x27;</span></span><br></pre></td></tr></table></figure>

<p>两个以上的OR条件 可以给出两个以上的OR条件。例如，<code>&#39;1000 | 2000 | 3000&#39;</code>将匹配1000或2000或3000</p>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义 \\"></a>转义 <code>\\</code></h4><p>为了匹配特殊字符，必须用<code>\\</code>为前导。</p>
<p><code>\\-</code>  表示查找<code>-</code>  <code>\\.</code>表示查找<code>.</code></p>
<p>为了匹配反斜杠（\）字符本身，需要使用<code>\\\</code></p>
<p>多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（MySQL<br>自己解释一个，正则表达式库解释另一个）</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207104911297.png" alt="image-20211207104911297"></p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207105037565.png" alt="image-20211207105037565"></p>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207105144297.png" alt="image-20211207105144297"></p>
<h2 id="计算字段-和-函数"><a href="#计算字段-和-函数" class="headerlink" title="计算字段 和 函数"></a>计算字段 和 函数</h2><p>计算字段并 不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。</p>
<h3 id="拼接Concat"><a href="#拼接Concat" class="headerlink" title="拼接Concat()"></a>拼接Concat()</h3><p>在MySQL的SELECT语句中，可使用 <code>Concat()</code>函数来拼接两个列。</p>
<p>Concat()需要一个或多个指定的串，各个串之间用逗号分隔。</p>
<p>多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207110011587.png" alt="image-20211207110011587"></p>
<h3 id="Trim-去空格"><a href="#Trim-去空格" class="headerlink" title="Trim()去空格"></a>Trim()去空格</h3><p>RTrim()   LTrim()  Trim()   </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Concat( RTrim(name) , <span class="string">&#x27;(&#x27;</span> , RTrim(country) , <span class="string">&#x27;)&#x27;</span> ) <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>

<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>从前面的输出中可以看到，SELECT语句拼接地址字段工作得很好。但此新计算列的名字是什么呢？实际上它没有名字，它只是一个值。一个未命名的列不能用于客户机应用中，因为客户机没有办法引用它。</p>
<p>别名用AS关键字赋予。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Concat( RTrim(name) , <span class="string">&#x27;(&#x27;</span> , RTrim(country) , <span class="string">&#x27;)&#x27;</span> ) <span class="keyword">as</span> myname  <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>

<p>client可以用 别名 当作列名 去使用</p>
<p>别名还有其他用途。常见的用途包括在实际 的表列名包含不符合规定的字符（如空格）时重新命名它，在<br>原来的名字含混或容易误解时扩充它</p>
<p>别名除了用于列名和计算字段外，SQL还允许给表名起别名。这样做有两个主要理由：<br> 缩短SQL语句；<br> 允许在单条SELECT语句中多次使用相同的表。</p>
<p>应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">from</span> table1 <span class="keyword">as</span> a, table2 <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">where</span></span><br></pre></td></tr></table></figure>



<h3 id="算术计算"><a href="#算术计算" class="headerlink" title="算术计算"></a>算术计算</h3><p>计算字段的另一常见用途是对检索出的数据进行算术计算</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207110735865.png" alt="image-20211207110735865"></p>
<p> 支持  加减乘除</p>
<h3 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h3><p>能运行在多个系统上的代码称 为可移植的（portable）。相对来说，多数SQL语句是可移植的，<br>在SQL实现之间有差异时，这些差异通常不那么难处理。而函 数的可移植性却不强。几乎每种主要的DBMS的实现都支持其 他实现不支持的函数，而且有时差异还很大。</p>
<h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><p><code>Trim()去空格</code></p>
<p><code>Upper()转大写</code></p>
<p><code>Length() 返回串长</code></p>
<p><code>Left()</code> 返回串左边的字符</p>
<p><code>Locate()</code> 找出串的一个子串</p>
<p><code>Lower()</code> 将串转换为小写</p>
<p><code>LTrim()</code> 去掉串左边的空格</p>
<p><code>Right()</code> 返回串右边的字符</p>
<p><code>RTrim()</code> 去掉串右边的空格</p>
<p><code>SubString()</code> 返回子串的字符</p>
<p><code>Soundex()</code> 返回串的SOUNDEX值  </p>
<p> SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207111511553.png" alt="image-20211207111511553"></p>
<h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><p>一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。</p>
<p>不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。因此，2005年9月1日，给出为2005-09-01。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它排除了多义性</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207112051616.png" alt="image-20211207112051616"></p>
<p>基本的日期比较</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> data<span class="operator">=</span><span class="string">&#x27;2002-05-15&#x27;</span></span><br></pre></td></tr></table></figure>

<p>比 如 ， 存 储 的 order_date 值 为 2005-09-01 11:30:05，则WHERE order_date &#x3D; ‘2005-09-01’失败。</p>
<p>即使给出具有该日期的一行，也不会把它检索出来，因为WHERE匹配失败。</p>
<p>MySQL仅将给出的日期与列中的日期部分进行比 较，而不是将给出的日期与整个列值进行比较</p>
<p>为此，必须使用Date() 函数。Date(order_date)指示MySQL仅提取列的日期部分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span>  <span class="type">Date</span>(data)<span class="operator">=</span><span class="string">&#x27;2002-05-15&#x27;</span></span><br></pre></td></tr></table></figure>



<p>如果你想检索出2005年9月下的 所有订单，怎么办？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span>  <span class="type">Date</span>(data) <span class="keyword">between</span> <span class="string">&#x27;2002-05-01&#x27;</span> <span class="keyword">and</span>  <span class="string">&#x27;2002-05-31&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Year</span>(data)<span class="operator">=</span><span class="number">2002</span> <span class="keyword">and</span> <span class="keyword">Month</span>(data)<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h4 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h4><p>这些函数一般主要用于代数、三角 或几何运算，</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207112658152.png" alt="image-20211207112658152"></p>
<h4 id="汇总表本身信息"><a href="#汇总表本身信息" class="headerlink" title="汇总表本身信息"></a>汇总表本身信息</h4><p>我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提 供了专门的函数。使用这些函数，MySQL查询可用于检索数据，以便分 析和报表生成。</p>
<p> 确定表中行数（或者满足某个条件或包含某个特定值的行数）。</p>
<p> 获得表中行组的和。</p>
<p>找出表列（或所有行或某些特定的行）的最大值、最小值和平均值</p>
<p>上述例子都需要对表中数据（而不是实际数据本身）汇总。因此 ， 返回实际表数据是对时间和处理资源的一种浪费（更不用说带宽了）。重 复一遍，实际想要的是汇总信息。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207112943225.png" alt="image-20211207112943225"></p>
<h5 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h5><p>只用于单个列 AVG()只能用来确定特定数值列的平均值，而 且列名必须作为函数参数给出。为了获得多个列的平均值， 必须使用多个AVG()函数。</p>
<p>AVG()函数忽略列值为NULL的行。</p>
<h5 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h5><p>可利用COUNT()计算行的数目。</p>
<p>COUNT()函数有两种使用方式。</p>
<p>​	 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</p>
<p>​	 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值</p>
<h5 id="MAX-x2F-MIN"><a href="#MAX-x2F-MIN" class="headerlink" title="MAX &#x2F; MIN"></a>MAX &#x2F; MIN</h5><p>MAX()返回指定列中的最大值。MAX()要求指定列名</p>
<p>在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行。MIN()返回最前面的行</p>
<p>忽略列值为NULL的行</p>
<h5 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h5><p>SUM()用来返回指定列值的和（总计）。</p>
<h5 id="distinct-排除"><a href="#distinct-排除" class="headerlink" title="distinct 排除"></a>distinct 排除</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>( <span class="keyword">DISTINCT</span> price  ) <span class="keyword">from</span> products <span class="keyword">where</span> id <span class="operator">=</span><span class="number">10086</span>;</span><br></pre></td></tr></table></figure>

<p>只对不同价格的商品计算平均值</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>单个组 的聚集函数 可以统计 Count &#x2F;Sum 等</p>
<p>但如果要返回多个有细微区别的 组的数据  </p>
<p>这就是分组显身手的时候了。分组允许把数据分为多个逻辑组，以 便能对每个组进行聚集计算。</p>
<p>在具体使用GROUP BY子句前，需要知道一些重要的规定。</p>
<p> GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</p>
<p> 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</p>
<p> GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</p>
<p> 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</p>
<p> 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p>
<p> GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p>
<h3 id="创建分组-group-by"><a href="#创建分组-group-by" class="headerlink" title="创建分组 group by"></a>创建分组 group by</h3><p>SELECT语句的GROUP BY子句中建立的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207114232745.png" alt="image-20211207114232745"></p>
<p>使用ROLLUP 使用WITH ROLLUP关键字，可以得到每个分组以 及每个分组汇总级别（针对每个分组）的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id ,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">with</span> <span class="keyword">rollup</span> ;</span><br></pre></td></tr></table></figure>



<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207114734309.png" alt="image-20211207114734309"></p>
<h3 id="过滤分组-having"><a href="#过滤分组-having" class="headerlink" title="过滤分组 having"></a>过滤分组 having</h3><p><code>HAVING</code>非常类似于WHERE。事实上，目前为止所 学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是 WHERE过滤行，而HAVING过滤分组。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207125607913.png" alt="image-20211207125607913"></p>
<p>分组不等于排序,  有了  Group By  不要忘记使用 Order By 来确保正确顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id ,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id  <span class="keyword">having</span>  num_prods <span class="operator">&gt;</span><span class="number">100</span>  <span class="keyword">order</span> <span class="keyword">by</span> num_prods ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 此语句     用count 计算 num , 按照 id 分组 , 保留 num <span class="operator">&gt;</span><span class="number">50</span> , 并按照  num  排序</span><br></pre></td></tr></table></figure>



<p>select 中 各个字句 先后顺序 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">from</span><br><span class="line">where</span><br><span class="line">group by</span><br><span class="line">having</span><br><span class="line">order by</span><br><span class="line">limit</span><br></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>SQL还允许创建子查询（subquery），即嵌套在其他查询中的查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> others <span class="keyword">where</span> order_num <span class="keyword">in</span> (<span class="number">20005</span>,<span class="number">20007</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> others <span class="keyword">where</span> order_num <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可见，在WHERE子句中使用子查询能够编写出功能很强并且很灵活的 SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于 性能的限制，不能嵌套太多的子查询。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207165247697.png" alt="image-20211207165247697"></p>
<h2 id="联结-join"><a href="#联结-join" class="headerlink" title="联结 join"></a>联结 join</h2><p>外键（foreign key） 外键为某个表中的一列，它包含另一个表 的主键值，定义了两个表之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 情景模拟</span><br><span class="line">假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢</span><br><span class="line"></span><br><span class="line">关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</span><br><span class="line"></span><br><span class="line">在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。vendors表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为主键（primary key）（在第1章中首次提到），可以是供应商ID或任何其他唯一值。</span><br><span class="line"></span><br><span class="line">products表只存储产品信息，它除了存储供应商ID（vendors表的主键）外不存储其他供应商信息。vendors表的主键又叫作products的外键，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。</span><br><span class="line"></span><br><span class="line">这样做的好处如下：</span><br><span class="line"> 供应商信息不重复，从而不浪费时间和空间；</span><br><span class="line"> 如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动；</span><br><span class="line"> 由于数据无重复，显然数据是一致的，这使得处理数据更简单。</span><br></pre></td></tr></table></figure>

<p>如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？<br>答案是使用联结。简单地说，联结是一种机制，用来在一条SELECT<br>语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返<br>回一组输出，联结在运行时关联表中正确的行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果在products表中插入拥有非法供应商ID（即没有在vendors表中出现）的供应商生产的产品，则这些</span><br><span class="line">产品是不可访问的，因为它们没有关联到某个供应商。</span><br><span class="line">为防止这种情况发生，可指示MySQL只允许在products表的供应商ID列中出现合法值（即出现在vendors表中的供应商）。</span><br><span class="line">这就是维护引用完整性，它是通过在表的定义中指定主键和外键来实现的。</span><br></pre></td></tr></table></figure>

<h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> table1.id<span class="operator">=</span>table2.id</span><br></pre></td></tr></table></figure>

<p>笛卡儿积（cartesian product） 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
<h3 id="内连结"><a href="#内连结" class="headerlink" title="内连结"></a>内连结</h3><p>目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结</p>
<p>内连结有关键词 Inner Join  on</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> table1 <span class="keyword">inner</span> <span class="keyword">join</span> table2 <span class="keyword">on</span> table1.id<span class="operator">=</span>table2.id</span><br></pre></td></tr></table></figure>

<p>尽量不要使用 * 通配符在 内连结 ,有 笛卡尔积问题</p>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> p1.id , p1.name </span><br><span class="line"><span class="keyword">from</span> products <span class="keyword">as</span> p1,products <span class="keyword">as</span> p2</span><br><span class="line"><span class="keyword">where</span> p1.id<span class="operator">=</span>p2.id <span class="keyword">and</span> p2.id<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对表设置别名  对一张表设置两个别名 分别使用 </p>
<p>用自联结而不用子查询 自联结通常作为外部语句用来替代 从相同表中检索数据时使用的子查询语句。虽然最终的结果是 相同的，但有时候处理联结远比处理子查询快得多。</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。</p>
<p>内部联结）返回所有数据，甚 至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次</p>
<p>系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一<br>般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207192551674.png" alt="image-20211207192551674"></p>
<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> table1 <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> table2  <span class="keyword">on</span> table1.id<span class="operator">=</span>table2.id</span><br></pre></td></tr></table></figure>

<p>使用<code>outer join</code> 语法时必须指定 <code>right </code>还是 <code>left</code></p>
<p>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表）</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207193124571.png" alt="image-20211207193124571"></p>
<p>表中指定 <code>left outer join</code> 指定了 customers 为拥有所有行的表 , 所以 cust_id 不为空, orders 表可能有空</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存在两种基本的外部联结形式：左外部联结 和右外部联结。它们之间的唯一差别是所关联的表的顺序不</span><br><span class="line">同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中 表的顺序转换为右外部联结。因此，两种类型的外部联结可互</span><br><span class="line">换使用，而究竟使用哪一种纯粹是根据方便而定。</span><br></pre></td></tr></table></figure>



<h2 id="组合查询union"><a href="#组合查询union" class="headerlink" title="组合查询union"></a>组合查询union</h2><p>MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个<br>查询结果集返回。</p>
<p>有两种基本情况，其中需要使用组合查询：<br> 在单个查询中从不同的表返回类似结构的数据；<br> 对单个表执行多个查询，按单个查询返回数据。</p>
<p>利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集。</p>
<p>UNION的使用很简单。所需做的只是给出每条SELECT语句，在各条语句之间放上关键字UNION。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207194637041.png" alt="image-20211207194637041"></p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207194643905.png" alt="image-20211207194643905"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="number">1</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>在这个简单的例子中，使用UNION可能比使用WHERE子句更为复杂。但对于更复杂的过滤条件，或者从多个表（而不是单个表）中检索数据 的情形，使用UNION可能会使处理更简单。</p>
<p><strong>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</strong></p>
<p><strong>UNION从查询结果集中自动去除了重复的行</strong></p>
<p>这是UNION的默认行为，但是如果需要，可以改变它。事实上，如果 想返回所有匹配行，可使用<code>UNION ALL</code>而不是UNION。</p>
<p>UNION ALL为UNION的一种形式，它完成 WHERE子句完成不了的工作。如果确实需要每个条件的匹配行全<br>部出现（包括重复行），则必须使用UNION ALL而不是WHERE。</p>
<h3 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h3><p><strong>最后一条 select 的 order by 对整个结果集 起作用</strong></p>
<p>SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只 能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。对 于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一 部分的情况，因此不允许使用多条ORDER BY子句。</p>
<h2 id="全文本搜索-待补充"><a href="#全文本搜索-待补充" class="headerlink" title="全文本搜索 (待补充)"></a>全文本搜索 (待补充)</h2><p>并非所有引擎都支持全文本搜索 正如第21章所述，MySQL 支持几种基本的数据库引擎。并非所有的引擎都支持本书所描 述的全文本搜索。两个最常使用的引擎为MyISAM和InnoDB， 前者支持全文本搜索，而后者不支持 </p>
<p>如果你的应用中需要全文本搜索功能，应该记住这一点</p>
<h2 id="插入-更新-删除"><a href="#插入-更新-删除" class="headerlink" title="插入 更新 删除"></a>插入 更新 删除</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 插入完整的行；</span><br><span class="line"> 插入行的一部分；</span><br><span class="line"> 插入多行；</span><br><span class="line"> 插入某些查询的结果</span><br></pre></td></tr></table></figure>

<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 (colum1,colum2,....) <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>



<p>如果 检索 比 插入重要 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> low priority <span class="keyword">into</span> .....</span><br></pre></td></tr></table></figure>

<p>多行插入 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 (colum1,colum2,....) <span class="keyword">values</span> </span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>insert select   ( 注意  不含主键 ??)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 (colum1,colum2,....)</span><br><span class="line"><span class="keyword">select</span>  colum1,colum2,....</span><br><span class="line"><span class="keyword">from</span> table2;</span><br></pre></td></tr></table></figure>

<p>INSERT SELECT中的列名不一定要求列名匹配。</p>
<p>事实上，MySQL甚至不关心SELECT返回的列名。它使用的是 列的位置，因此SELECT中的第一列（不管其列名）将用来填充 表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，</p>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>省略 where  会 更新表所有 行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> table1 </span><br><span class="line"><span class="keyword">set</span> column1<span class="operator">=</span><span class="string">&#x27;2&#x27;</span> ,column2<span class="operator">=</span><span class="string">&#x27;3&#x27;</span> </span><br><span class="line"><span class="keyword">where</span>   ...</span><br></pre></td></tr></table></figure>

<p>在UPDATE语句中使用子查询 UPDATE语句中可以使用子查 询，使得能用SELECT语句检索出的数据更新列数据。</p>
<p>ignore 关键字 如果用UPDATE语句更新多行，并且在更新这些 行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> IGNORE ......</span><br></pre></td></tr></table></figure>

<p>update set &#x3D;null 置为空,删除效果</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>省略 where  会 删除表所有 行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table1</span><br><span class="line"><span class="keyword">where</span></span><br></pre></td></tr></table></figure>



<p>DELETE删除整行而不是删除列。为了 删除指定的列，请使用UPDATE语句。</p>
<h2 id="创建摧毁表"><a href="#创建摧毁表" class="headerlink" title="创建摧毁表"></a>创建摧毁表</h2><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> name1</span><br><span class="line">(</span><br><span class="line">    column1 type1 ...  ,</span><br><span class="line">    column1 type1 ...  ,</span><br><span class="line">)Engine<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<h5 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h5><p>表的主键可以在创建表时用 PRIMARY KEY关键字指定。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">primary</span> key ( column1 ,column2 )</span><br></pre></td></tr></table></figure>



<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207205757751.png" alt="image-20211207205757751"></p>
<h5 id="AUTO-INCREMENT-自增"><a href="#AUTO-INCREMENT-自增" class="headerlink" title="AUTO_INCREMENT 自增"></a>AUTO_INCREMENT 自增</h5><p>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。</p>
<p>那么，如何在使用AUTO_INCREMENT列时获得这个值呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_insert_id() </span><br></pre></td></tr></table></figure>

<p>此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于 后续的MySQL语句。</p>
<h5 id="IF-NOT-EXISTS"><a href="#IF-NOT-EXISTS" class="headerlink" title="IF NOT EXISTS"></a>IF NOT EXISTS</h5><p>如果你仅想在一个表不存在时创建它，应该在表名后给出<code>IF NOT EXISTS</code>。这样做不检查已有表的模式是否与你打算创建 的表模式相匹配。它只是查看表名是否存在，并且仅在表名不 存在时创建它。</p>
<h5 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h5><p>创建表时 指定列 能否为空值</p>
<p>主键中只能使用不允许NULL值的列</p>
<h5 id="default"><a href="#default" class="headerlink" title="default"></a>default</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">column1 type1  <span class="keyword">NOT</span> <span class="keyword">NULL</span>  <span class="keyword">DEFAULT</span> <span class="number">1</span> ,</span><br></pre></td></tr></table></figure>

<h5 id="engine"><a href="#engine" class="headerlink" title="engine"></a>engine</h5><p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207210620031.png" alt="image-20211207210620031"></p>
<p>外键不能跨引擎 混用引擎类型有一个大缺陷。外键（用于 强制实施引用完整性，如第1章所述）不能跨引擎，即使用一 个引擎的表不能引用具有使用不同引擎的表的外键。</p>
<h5 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">		O_Id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		OrderNo <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		P_Id <span class="type">int</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (O_Id),</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY (P_Id) <span class="keyword">REFERENCES</span> Persons(P_Id)</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>如需命名 <span class="keyword">FOREIGN</span> KEY 约束，并定义多个列的 <span class="keyword">FOREIGN</span> KEY 约束</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_PerOrders <span class="keyword">FOREIGN</span> KEY (P_Id) <span class="keyword">REFERENCES</span> Persons(P_Id)</span><br><span class="line">    </span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h3><h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h4><p>add</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1 <span class="keyword">add</span>  </span><br><span class="line">column1 type1  <span class="keyword">NOT</span> <span class="keyword">NULL</span>  <span class="keyword">DEFAULT</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p>drop</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1 <span class="keyword">drop</span></span><br><span class="line">column1 ;</span><br></pre></td></tr></table></figure>

<p>外键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1</span><br><span class="line"><span class="keyword">add</span> </span><br><span class="line"><span class="keyword">foreign</span> key ( table1.colnm1 ) <span class="keyword">references</span> table2 (table2.colnm2 )</span><br></pre></td></tr></table></figure>

<p>如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_PerOrders</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (P_Id) <span class="keyword">REFERENCES</span> Persons(P_Id)</span><br></pre></td></tr></table></figure>

<p>撤销外键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_PerOrders</span><br></pre></td></tr></table></figure>





<p>一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY(唯一约束的键)。</p>
<h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table1;</span><br></pre></td></tr></table></figure>



<h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">rename <span class="keyword">table</span> table1 <span class="keyword">to</span> table2;</span><br></pre></td></tr></table></figure>





<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询的数据</p>
<p>下面是视图的一些常见应用。</p>
<p> 重用SQL语句。</p>
<p> 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</p>
<p> 使用表的组成部分而不是整个表。</p>
<p> 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</p>
<p> 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p>
<p>重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p>最常见的规则和限制。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</span><br><span class="line"> 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</span><br><span class="line"> 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</span><br><span class="line"> ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</span><br><span class="line"> 视图不能索引，也不能有关联的触发器或默认值。</span><br><span class="line"> 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。</span><br></pre></td></tr></table></figure>

<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>CREATE VIEW语句</p>
<p>用SHOW CREATE VIEW viewname；来查看创建视图的语句。</p>
<p>DROP删除视图，其语法为DROP VIEW viewname;。</p>
<p>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> viewname1 <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> ...</span><br><span class="line">....;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> viewname1;</span><br></pre></td></tr></table></figure>



<p>常用来格式化一些 数据</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208124935876.png" alt="image-20211208124935876"></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新一个视图将更新其基表</p>
<p>但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不 能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实 际上意味着，如果视图定义中有以下操作，则不能进行视图的更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group by </span><br><span class="line">having</span><br><span class="line">连结</span><br><span class="line">子查询</span><br><span class="line">并</span><br><span class="line">聚集函数 Distinct</span><br><span class="line">导出（计算）列。</span><br></pre></td></tr></table></figure>

<p>将视图用于检索 一般，应该将视图用于检索（SELECT语句） 而不用于更新（INSERT、UPDATE和DELETE）</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程简单来说，就是为以后的使用而保存 的一条或多条MySQL语句的集合。可将其视为批文件</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> funname1 ( </span><br><span class="line">    arg1, </span><br><span class="line">    arg2  <span class="operator">/</span><span class="operator">/</span> 可选参数</span><br><span class="line">) </span><br></pre></td></tr></table></figure>



<h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> funname1( 可选参数 )</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> .....</span><br><span class="line">	<span class="keyword">from</span> ... ;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>如果存储过程接受参数，它们将在()中列举出来。此存储过程没</span><br><span class="line">有参数，但后跟的()仍然需要。<span class="keyword">BEGIN</span>和<span class="keyword">END</span>语句用来限定存储过程体，过</span><br><span class="line">程体本身仅是一个简单的<span class="keyword">SELECT</span>语句</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> funame1;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> IF <span class="keyword">EXISTS</span> funname1;</span><br></pre></td></tr></table></figure>

<h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><h5 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> funname1( </span><br><span class="line">	<span class="keyword">out</span> p1 <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">out</span> p2 <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">out</span> p3 <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">Min</span>(price)</span><br><span class="line">	<span class="keyword">into</span> p1</span><br><span class="line">	<span class="keyword">from</span> products;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">Max</span>(price)</span><br><span class="line">	<span class="keyword">into</span> p2</span><br><span class="line">	<span class="keyword">from</span> products;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">Avg</span>(price)</span><br><span class="line">	<span class="keyword">into</span> p3</span><br><span class="line">	<span class="keyword">from</span> products;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>解析</p>
<ol>
<li><p>参数 p1,p2,p3   都是 out 参数  用来传出 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in  传入参数</span><br><span class="line">out 传出参数</span><br><span class="line">inout  传入传出参数</span><br><span class="line"></span><br><span class="line">decimal 十进制</span><br></pre></td></tr></table></figure>


</li>
<li><p><code> into</code> 用来给变量赋值</p>
</li>
</ol>
<p>记录集不是允许的类型，因此，不能通过一个参数返回 多个行和列。这就是前面的例子为什么要使用3个参数</p>
<h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">call</span> funname1 (</span><br><span class="line">    		<span class="variable">@min</span>_arg,</span><br><span class="line">             <span class="variable">@max</span>_arg,</span><br><span class="line">             <span class="variable">@avg</span>_arg</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>所有MySQL变量都必须以@开始。</p>
<p>由于此存储过程要求3个参数，因此必须正好传递3个参数</p>
<h5 id="拿取参数"><a href="#拿取参数" class="headerlink" title="拿取参数"></a>拿取参数</h5><p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208170936471.png" alt="image-20211208170936471"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@min</span>_arg ;</span><br></pre></td></tr></table></figure>



<h3 id="显示存储过程"><a href="#显示存储过程" class="headerlink" title="显示存储过程"></a>显示存储过程</h3><p>显示用来创建一个存储过程的CREATE语句</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> funname1;</span><br></pre></td></tr></table></figure>

<p>列出所有存储过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS</span><br></pre></td></tr></table></figure>





<h2 id="游标-待补充"><a href="#游标-待补充" class="headerlink" title="游标 (待补充)"></a>游标 (待补充)</h2><p>需要在检索出来的行中前进或后退一行或多行。这就是使用 游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<p> 不像多数DBMS，MySQL游标只能用于存储过程（和函数）。</p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>MySQL语句在需要时被执行，存储过程也是如此。但是，如果你 想要某条语句（或某些语句）在事件发生时自动执行</p>
<p>所有这些例子的共同之处是它们都需要在某个表发生更改时自动 处理。这确切地说就是触发器。</p>
<p>触发器是MySQL响应以下任意语句而 自动执行的一条MySQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE；</span><br><span class="line">INSERT；</span><br><span class="line">UPDATE;</span><br><span class="line">begin   ....   end;</span><br></pre></td></tr></table></figure>

<p>其他MySQL语句不支持触发器</p>
<p> 应该用触发器来保证数据的一致性（大小写、格式等）。在触发器<br>中执行这种类型的处理的优点是它总是进行这种处理，而且是透<br>明地进行，与客户机应用无关。</p>
<p>触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，<br>把更改（如果需要，甚至还有之前和之后的状态）记录到另一个<br>表非常容易。</p>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>在创建触发器时，需要给出4条信息：<br> 唯一的触发器名；<br> 触发器关联的表；<br> 触发器应该响应的活动（DELETE、INSERT或UPDATE）；<br> 触发器何时执行（处理之前或之后）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> name </span><br><span class="line">after<span class="operator">|</span>before 		<span class="keyword">insert</span><span class="operator">|</span><span class="keyword">update</span><span class="operator">|</span><span class="keyword">delete</span>  	<span class="keyword">on</span> table1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>   <span class="operator">/</span><span class="operator">/</span>这个触发器还指定 FOREACH <span class="type">ROW</span>，因此代码对每个插入行执行。</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;aaaaa&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>只有表才支持触发器，视图不支持（临时表也不 支持）。</p>
<p>单一触发器不能与多个事件或多个表关联，所 以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义 两个触发器。</p>
<p>如果BEFORE触发器失败，则MySQL将不执行请 求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL<br>将不执行AFTER触发器（如果有的话）。</p>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> name;</span><br></pre></td></tr></table></figure>

<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。</p>
<h3 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h3><p>在INSERT触发器代码内，可引用一个名为<code>NEW</code>的虚拟表，访问<code>被插入的行</code>；</p>
<p>对于<code>AUTO_INCREMENT</code>列，NEW在INSERT<code>执行之前包含0</code>，在<code>INSERT执行之后包含新的自动生成值</code>。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208190029679.png" alt="image-20211208190029679"></p>
<h3 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h3><p> 在DELETE触发器代码内，你可以引用一个名为<code>OLD</code>的虚拟表，访问被删除的行；</p>
<p><code>OLD</code>中的值全都是<code>只读</code>的，不能更新。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> name1 </span><br><span class="line">before <span class="keyword">delete</span> <span class="keyword">on</span> table1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> table2 (column1,column2 ...)</span><br><span class="line">	<span class="keyword">values</span> (old.column1, old.column2 ...) ;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>这个例子是 对每个删除行进行备份到 table2 中</p>
<h3 id="update-2"><a href="#update-2" class="headerlink" title="update"></a>update</h3><p>在UPDATE触发器代码中，你可以引用一个名为<code>OLD</code>的虚拟表访问 以前（UPDATE语句前）的值，引用一个名为<code>NEW</code>的虚拟表访问新更新的值；</p>
<p>在<code>BEFORE UPDATE</code>触发器中，<code>NEW</code>中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</p>
<p><code>OLD</code>中的值全都是只读的，不能更新。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>并非所有引擎都支持事务处理</p>
<p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p>
<p>事务（transaction）指一组SQL语句；</p>
<p>回退（rollback）指撤销指定SQL语句的过程；</p>
<p>提交（commit）指将未存储的SQL语句结果写入数据库表；</p>
<p>保留点（savepoint）指事务处理中设置的临时占位符（place-<br>holder），你可以对它发布回退（与回退整个事务处理不同）。</p>
<p>你不能回退CREATE或DROP操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction  ;</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"><span class="keyword">rollback</span> ; <span class="operator">/</span><span class="operator">/</span> <span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure>

<p>当COMMIT或ROLLBACK语句执行后，事务会自 动关闭（将来的更改会隐含提交）。</p>
<h4 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h4><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放 置占位符。这样，如果需要回退，可以回退到某个占位符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">savepoint</span>  delete1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> delete1;</span><br></pre></td></tr></table></figure>



<p>保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放 </p>
<p>或者手动 <code>release savepoint</code></p>
<h4 id="更改默认提交行为"><a href="#更改默认提交行为" class="headerlink" title="更改默认提交行为"></a>更改默认提交行为</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p> 字符集 character   为字母和符号的集合；</p>
<p> 编码       为某个字符集成员的内部表示；</p>
<p> 校对    collation    为规定字符如何比较的指令。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208192511630.png" alt="image-20211208192511630"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208192556076.png" alt="image-20211208192556076"></p>
<h2 id="权限控制-待补充"><a href="#权限控制-待补充" class="headerlink" title="权限控制 (待补充)"></a>权限控制 (待补充)</h2><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。</p>
<p>决不要检索比需求还要多的数据。换言之，不要用SELECT *（除 非你真正需要每个列）。</p>
<p>必须索引数据库表以改善数据检索的性能。</p>
<p>索引改善数据检索的性能，但损害数据插入、删除和更新的性能</p>
<p> LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。</p>
<p>你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改进。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p>使用引号 不管使用何种形式的串数据类型，串值都必须括在<br>引号内（通常单引号更好）。</p>
<p>如果数值是计算（求和、平均等）中使 用的数值，则应该存储在数值数据类型列中。如果作为字符串（可能只包含数字）使用，则应该保存在串数据类型列中。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208193447550.png" alt="image-20211208193447550"></p>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>有符号或无符号 所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号。</p>
<p>默认情况为有符号，</p>
<p>可以使用<code>UNSIGNED</code>关键字，这样做将允许你存储两倍大小的值。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208193708795.png" alt="image-20211208193708795"></p>
<h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208193731910.png" alt="image-20211208193731910"></p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208193749896.png" alt="image-20211208193749896"></p>
<p><a href="https://www.aliyundrive.com/s/xw1pPe33r4m">MySQL必知必会（文字版）.pdf</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaRmi远程方法调用</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-11-08-JavaRmi%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>RMI使您可以以更高的抽象级别编程。它隐藏了套接字服务器，套接字，连接和发送或接收数据的详细信息。它甚至实现了引擎盖下的多线程服务器，而使用套接级编程，则必须明确地实现用于处理多个客户端的线程。 RMI应用程序是可扩展且易于维护的。您可以更改RMI服务器或将其移动到另一台计算机，而无需修改客户端程序，只是重置URL以找到服务器。 （为避免重置URL，您可以修改客户端将URL传递为命令行参数。）在套接级编程中，发送数据的客户端操作需要服务器操作来读取它。在套接字级别的客户端和服务器的实现是紧密同步的。 RMI客户端可以直接调用服务器方法，而插座级编程仅限于传递值。套接字级编程非常原始。避免使用它来开发客户端&#x2F;服务器应用程序。作为一个类比，套接字级编程就像汇编语言的编程一样，而RMI编程就像以高级语言编程。</p>
<p>本地对象是只能在本地主机内访问。可从远程主机访问的对象称为 <code>远程对象</code>。对于要远程调用的对象，它必须在 Java 接口中定义 服务器和客户端都可以访问。此外，该接口必须扩展 java.lang.rmi.Remote 接口。像 java.io.Serializable 接口，java.rmi.Remote 是一个不包含常量或方法的标记接口。它仅用于识别远程 对象。</p>
<p><img src="https://tu.yegetables.com/images/2021/11/05/image-20211105171220449.png" alt="image-20211105171220449"></p>
<p><img src="https://tu.yegetables.com/images/2021/11/06/image.png" alt="image-20211106125338311"></p>
<h1 id="普通RMI-调用"><a href="#普通RMI-调用" class="headerlink" title="普通RMI 调用"></a>普通RMI 调用</h1><p>客户端如何找到远程对象？<code>RMI注册表</code>提供了服务器的注册表服务，用于注册对象并为客户端找到对象。</p>
<p>您可以在<code>Locateregistry</code>类中使用几个超载的静态<code>getRegisty（）</code>方法来返回对注册表的引用，</p>
<p>一旦获得了注册表，您可以使用绑定或Rebind方法在注册表中使用唯一名称绑定对象或使用查找方法找到对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public:</span><br><span class="line">	Registry: 可在第三方启动，也可在Server启动， 区别是创建还是获取Registry注册中心</span><br><span class="line">	LocateRegistry.createRegistry(65532); //启动注册中心</span><br><span class="line">	CS共有一个接口 </span><br><span class="line">Server：</span><br><span class="line">	Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 65532);//获取注册中心</span><br><span class="line">	服务端特有接口的实现类，new一个出来以后包装成Remte对象</span><br><span class="line">    var proxy=  UnicastRemoteObject.exportObject(simply, 1985);</span><br><span class="line">	bind/rebind/unbind/  到key   </span><br><span class="line"></span><br><span class="line">Client:</span><br><span class="line">	Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 65532);</span><br><span class="line">	list/lookup key得到代理类转为接口，调用接口方法</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/11/07/image-20211107223557870.png" alt="image-20211107223557870"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client</span></span><br><span class="line">	<span class="comment">//获取到注册中心</span></span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">65532</span>);</span><br><span class="line">	<span class="comment">//搜索key-对应的 被代理的接口实现对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">proxy</span> <span class="operator">=</span> (Simple) registry.lookup(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">	<span class="comment">//通过这个代理的接口实现对象 调用接口方法</span></span><br><span class="line">System.out.println(proxy.say());</span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">//server</span></span><br><span class="line">	<span class="comment">//创建注册中心（也可以获取第三方注册中心）</span></span><br><span class="line"><span class="keyword">var</span> registry=LocateRegistry.createRegistry(<span class="number">65532</span>);</span><br><span class="line">	<span class="comment">//新建一个接口实现类</span></span><br><span class="line">Simple simply=<span class="keyword">new</span> <span class="title class_">SimpleRealizer</span>();</span><br><span class="line">	<span class="comment">//将这个实现类转换成代理类Remote类</span></span><br><span class="line"><span class="keyword">var</span> proxy= UnicastRemoteObject.exportObject(simply, <span class="number">1985</span>);</span><br><span class="line">	<span class="comment">//去注册中心将上一步的代理接口类绑定key</span></span><br><span class="line">registry.bind(<span class="string">&quot;key&quot;</span>,proxy);</span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line">	<span class="comment">//继承Remote接口，方法必须抛异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Simple</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRealizer</span> <span class="keyword">implements</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;say:hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>客户端调用 stub 的 say() 方法背后的流程：<br>client 端通过 stub 中包含的 host、port 信息，与 remote object 所在的 server 建立连接 ，然后序列化调用数据<br>server 端接收调用请求，将调用转发给 remote object，然后序列化结果，返回给 client<br>client 端接收、反序列化结果</p>
</blockquote>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cs 共知接口 继承Remote 方法必须抛异常  throws RemoteException</span><br><span class="line">（？？此条待定）cs 注册的类必须同包名，不然找不到</span><br><span class="line">c 参数 和 返回值，如果是Object ，必须手动实现序列化接口 implements Serializable </span><br></pre></td></tr></table></figure>

<h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><blockquote>
<p>tips：正常	<code>rmi</code>	是 共知接口1，server有接口1的实现类，将实现类与key绑定，然后被client 获取并调用<code>代理接口实现类</code>的接口1中的已知方法</p>
</blockquote>
<h1 id="RMI回调"><a href="#RMI回调" class="headerlink" title="RMI回调"></a>RMI回调</h1><p>​	传统Rmi只能是客户端调用服务端的方法，回调则提供了一种服务器端可以调用客户端方法的办法，具体如下：<img src="https://tu.yegetables.com/images/2021/11/07/image-20211107223610637.png" alt="image-20211107223610637"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public:</span><br><span class="line">	接口1和接口2 由 cs 共同知晓</span><br><span class="line">	c有接口2的实现类，s有接口1的实现类</span><br><span class="line">	接口1中有方法将接口2作为参数</span><br><span class="line">C：</span><br><span class="line">	new接口2的实现类       I2 cl=new I2implenter();</span><br><span class="line">	拿到接口1的代理对象后   调用代理类的特殊传参（参数为接口2）方法</span><br><span class="line">    int result =proxy.pass(cl);</span><br><span class="line">    得到s端 接口2实现类 实现的方法返回值，也可能没有返回值</span><br><span class="line">S:  无特殊</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">I1</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    String <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">pass</span><span class="params">(I2 temp)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">//接口1实现类（s端特有）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">I1implenter</span> <span class="keyword">implements</span> <span class="title class_">I1</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">say</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pass</span><span class="params">(I2 temp)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    	<span class="comment">//此时可以自由使用接口2实现类的方法</span></span><br><span class="line">    	<span class="comment">//使用完后返回pass方法的返回值给client</span></span><br><span class="line">        <span class="keyword">return</span> temp.sum(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">//接口2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">I2</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">//接口2实现类（c端特有）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">I2implenter</span> <span class="keyword">implements</span> <span class="title class_">I2</span>, Serializable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">//client</span></span><br><span class="line"> <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">65532</span>);</span><br><span class="line"> <span class="type">var</span> <span class="variable">proxy</span> <span class="operator">=</span> (I1) registry.lookup(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"> System.out.println(proxy.say());</span><br><span class="line"> I2 cl=<span class="keyword">new</span> <span class="title class_">I2implenter</span>();</span><br><span class="line"> <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span>proxy.pass(cl);</span><br><span class="line"> System.out.println(<span class="string">&quot;result=&quot;</span>+result);</span><br><span class="line"><span class="comment">//server</span></span><br><span class="line"> <span class="keyword">var</span> registry=LocateRegistry.createRegistry(<span class="number">65532</span>);</span><br><span class="line"> I1 simply=<span class="keyword">new</span> <span class="title class_">I1implenter</span>();</span><br><span class="line"> <span class="keyword">var</span> proxy=  UnicastRemoteObject.exportObject(simply, <span class="number">1985</span>);</span><br><span class="line"> registry.bind(<span class="string">&quot;key&quot;</span>,proxy);</span><br></pre></td></tr></table></figure>

<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口2实现类必须实现序列化接口</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>rmi</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP中的Request与Response</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-10-22-HTTP%E4%B8%AD%E7%9A%84Request%E4%B8%8EResponse/</url>
    <content><![CDATA[<h1 id="HTTP协议-请求"><a href="#HTTP协议-请求" class="headerlink" title="HTTP协议-请求"></a>HTTP协议-请求</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><h3 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a>常见形式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a标签</span><br><span class="line">form中的method=get</span><br><span class="line">link引入css</span><br><span class="line">Script引入js文件</span><br><span class="line">image引入图片</span><br><span class="line">iframe引入html页面</span><br><span class="line">浏览器输地址后回车</span><br></pre></td></tr></table></figure>
<p><img src="https://tu.yegetables.com/images/2021/08/14/20210814163138.png" alt="img.png"></p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求方式                  GET</span><br><span class="line">请求资源路径[+?+请求参数]   /myTomcat/index.html</span><br><span class="line">请求协议版本号             HTTP/1.1</span><br></pre></td></tr></table></figure>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept:              客户端可以接受的数据类型</span><br><span class="line">Accept-Language:     zh_CN/en_US</span><br><span class="line">User-Agent:          浏览器信息</span><br><span class="line">Accept-Encoding:     可以接受的数据编码 (压缩)格式</span><br><span class="line">Host:                请求的服务器ip:端口</span><br><span class="line">Connection:          Keep-Alive/Closed     回传数据后 告诉服务器的行为</span><br></pre></td></tr></table></figure>




<h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><h3 id="常见形式-1"><a href="#常见形式-1" class="headerlink" title="常见形式"></a>常见形式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">form中的method=get</span><br></pre></td></tr></table></figure>
<h3 id="请求行-1"><a href="#请求行-1" class="headerlink" title="请求行"></a>请求行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求方式                              POST</span><br><span class="line">请求资源路径[+?+请求参数]               /myTomcat/index.html</span><br><span class="line">请求协议版本号                         HTTP/1.1</span><br></pre></td></tr></table></figure>
<h3 id="请求头-1"><a href="#请求头-1" class="headerlink" title="请求头"></a>请求头</h3><p>大部分与 GET相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept:              客户端可以接受的数据类型</span><br><span class="line">Accept-Language:     zh_CN/en_US</span><br><span class="line">User-Agent:          浏览器信息</span><br><span class="line">Accept-Encoding:     可以接受的数据编码 (压缩)格式</span><br><span class="line">Host:                请求的服务器ip:端口</span><br><span class="line">Connection:          Keep-Alive/Closed     回传数据后 告诉服务器的行为</span><br></pre></td></tr></table></figure>
<p>特别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Referer:              请求发起时浏览器地址(请求的来源)</span><br><span class="line"> Content-Type:         multipart/form-data                 以多段的方式提交数据(流的方式,用于上传)</span><br><span class="line">                         application/x-www-form-urlencoded   提交方式是 name=value&amp;name=value,然后进行url编码(非英文转为%xx%xx)</span><br><span class="line"> Content-Length:       请求体长度</span><br><span class="line">Catch-Control:        no-cache不缓存                                     控制缓存  </span><br></pre></td></tr></table></figure>
<p><img src="https://tu.yegetables.com/images/2021/08/14/20210814170427.png" alt="img_1.png"></p>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure>

<h1 id="HTTP协议-响应"><a href="#HTTP协议-响应" class="headerlink" title="HTTP协议-响应"></a>HTTP协议-响应</h1><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">响应协议和版本号                         HTTP/1.1</span><br><span class="line">响应状态码                              200  </span><br><span class="line">响应状态描述符                           OK</span><br></pre></td></tr></table></figure>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server:							服务器信息(如Apache-Coyote/1.1)</span><br><span class="line">Content-Type:                    响应体的数据类型(如text/html   application/json)MIME类型</span><br><span class="line">Content-Length:					长度</span><br><span class="line">Date:							请求响应的时间(格林时间)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h3><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>(例如  整个html页面)</p>
<p><img src="https://tu.yegetables.com/images/2021/08/14/20210814171839.png" alt="image-20210814171839089"></p>
<h2 id="常见响应状态"><a href="#常见响应状态" class="headerlink" title="常见响应状态"></a>常见响应状态</h2><p>200 ok<br>404 请求收到 但是请求数据not found<br>302 重定向<br>500 请求收到 但是内部错误</p>
<h1 id="HTTP中的数据类型"><a href="#HTTP中的数据类型" class="headerlink" title="HTTP中的数据类型"></a>HTTP中的数据类型</h1><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><p><img src="https://tu.yegetables.com/images/2021/08/14/20210814173112.png" alt="image-20210814173112102"></p>
<p><a href="https://blog.csdn.net/weixin_39190897/article/details/82414549">JavaWeb-Servlet</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的 Jdbc使用全解</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-10-19-java%E4%B8%AD%E7%9A%84_jdbc%E4%BD%BF%E7%94%A8%E5%85%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>JDBC 应用程序使用 Driver 接口加载适当的驱动程序，使用 Connection 接口连接到数据库，使用 Statement 接口创建和执行 SQL 语句，如果语句返回结果，则使用 ResultSet 接口处理结果</p>
<h1 id="jdbc流程"><a href="#jdbc流程" class="headerlink" title="jdbc流程"></a>jdbc流程</h1><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><ol>
<li></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	 <span class="comment">//通过DriverManager获取数据库连接</span></span><br><span class="line"> <span class="type">Connection</span> <span class="variable">cn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mariadb://localhost:3306/test?user=ajian&amp;password=123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(cn.toString());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Java 支持自动驱动程序发现，因此您不必显式加载驱动程序。 但是，在撰写本文时，并非所有数据库驱动程序都支持此功能。 为安全起见，请显式加载驱动程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;JDBCDriverClass&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><img src="https://tu.yegetables.com/images/2021/10/18/20211018201806.png" alt="image-20211018201759729"></p>
</li>
<li><p><img src="https://tu.yegetables.com/images/2021/10/18/20211018201958.png" alt="image-20211018201958798"></p>
</li>
</ol>
<h2 id="语句执行"><a href="#语句执行" class="headerlink" title="语句执行"></a>语句执行</h2><p>使用<code>Statement</code>执行SQL语句。</p>
<table>
<thead>
<tr>
<th>executeUpdate()</th>
<th>主要用于执行DML和DDL语句。执行DML语句返回受SQL语句影响的行数，执行DDL语句返回0。</th>
</tr>
</thead>
<tbody><tr>
<td>executeQuery()</td>
<td>只能执行查询语句，执行后返回代表查询结果的ResultSet对象。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>DML</th>
<th>inster &#x2F;update &#x2F;delete</th>
<th>受影响行数</th>
</tr>
</thead>
<tbody><tr>
<td>DDL</td>
<td>create &#x2F;drop   &#x2F;alter</td>
<td>成功0</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="comment">//通过Connection对象创建Statement对象</span></span><br><span class="line">     <span class="type">Statement</span> <span class="variable">sd</span> <span class="operator">=</span> cn.createStatement();</span><br><span class="line">     </span><br><span class="line">   <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span>    sd.executeUpdate(<span class="string">&quot;insert  into   user(user_name, user_passwd,user_email,user_status) values (\&quot;safaffa\&quot;,\&quot;assss\&quot;,\&quot;ajian@email.com\&quot;,0 )&quot;</span>);</span><br><span class="line">System.out.println(result);<span class="comment">//返回1  受影响行数</span></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="重复执行的sql"><a href="#重复执行的sql" class="headerlink" title="重复执行的sql"></a>重复执行的sql</h3><p><code>Statement</code> 接口用于执行不包含任何参数的静态 SQL 语句。</p>
<p><code>PreparedStatement</code> 接口(extend-ing Statement)用于执行预编译的 SQL 语句，可以带参数或不带参数。因为 SQL 语句是预编译的，所以它们对于重复执行非常有效。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> PreparedStatement preparedStatement <span class="operator">=</span> connection.prepareStatement (&quot;insert into Student (firstName, mi, lastName) &quot; <span class="operator">+</span> &quot;values (?, ?, ?)&quot;);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>setX(<span class="type">int</span> parameterIndex, X <span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">preparedStatement.setString(<span class="number">1</span>, &quot;Jack&quot;);</span><br><span class="line">preparedStatement.setString(<span class="number">2</span>, &quot;A&quot;);</span><br><span class="line">preparedStatement.setString(<span class="number">3</span>, &quot;Ryan&quot;);</span><br><span class="line"></span><br><span class="line">ResultSet rset <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line">   var temp<span class="operator">=</span> preparedStatement.executeUpdate() ;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>






<h2 id="结果集"><a href="#结果集" class="headerlink" title="结果集"></a>结果集</h2><p>操作结果集 如果执行的SQL语句是查询语句，则执行结果将返回一个ResultSet对象，该对象里保存了SQL语句查询的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> sd.executeQuery(<span class="string">&quot;select * from user &quot;</span>);</span><br><span class="line">      <span class="comment">//ResultSet对象主要提供了如下两类方法。</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="comment">//➢ next()、previous()、first()、last()、beforeFirst()、afterLast()、absolute()等移动记录指针的方法。</span></span><br><span class="line">      <span class="comment">//➢ getXxx()方法获取记录指针指向行、特定列的值。该方法既可使用列索引作为参数，也可使用列名作为参数。使用列索引作为参数性能更好，使用列名作为参数可读性更好。</span></span><br><span class="line">              <span class="keyword">while</span> (res.next())</span><br><span class="line">             &#123;</span><br><span class="line">                  System.out.println(res.getInt(<span class="number">1</span>) + <span class="string">&quot;  &quot;</span> + res.getString(<span class="number">2</span>) + <span class="string">&quot;  &quot;</span> + res.getString(<span class="number">3</span>) + <span class="string">&quot;  &quot;</span> + res.getString(<span class="number">4</span>));</span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="回收-close"><a href="#回收-close" class="headerlink" title="回收 close"></a>回收 close</h2><p>回收数据库资源，包括关闭&#96;&#96;ResultSet<code>、</code>Statement<code>和</code>Connection&#96;等资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res.close();</span><br><span class="line">sd.close();</span><br><span class="line">cn.close();</span><br></pre></td></tr></table></figure>



<h1 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h1><h2 id="创建create"><a href="#创建create" class="headerlink" title="创建create"></a>创建create</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table Student (</span><br><span class="line">ssn char(9),</span><br><span class="line">firstName varchar(25),</span><br><span class="line">mi char(1),</span><br><span class="line">lastName varchar(25),</span><br><span class="line">birthDate date,</span><br><span class="line">street varchar(25),</span><br><span class="line">phone char(11),</span><br><span class="line">zipCode char(5),</span><br><span class="line">deptId char(4),</span><br><span class="line">primary key (ssn)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="插入insert"><a href="#插入insert" class="headerlink" title="插入insert"></a>插入insert</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into tableName [(column1, column2, ..., column)] values (value1, value2, ..., valuen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into Course (courseId, subjectId, courseNumber, title, numOfCredits) values (&#x27;11113&#x27;, &#x27;CSCI&#x27;, &#x27;3720&#x27;, &#x27;Database Systems&#x27;, 3);</span><br></pre></td></tr></table></figure>

<h2 id="更新update"><a href="#更新update" class="headerlink" title="更新update"></a>更新update</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tableName set column1 = newValue1 [, column2 = newValue2, ...] [where condition];</span><br><span class="line"></span><br><span class="line">update Course set numOfCredits = 4 where title = &#x27;Database Systems&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="删除delete"><a href="#删除delete" class="headerlink" title="删除delete"></a>删除delete</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from tableName [where condition];</span><br><span class="line">delete from Course where title = &#x27;Database Systems&#x27;;</span><br><span class="line"></span><br><span class="line">delete from Course;</span><br></pre></td></tr></table></figure>
<h2 id="查询select"><a href="#查询select" class="headerlink" title="查询select"></a>查询select</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column-list from table-list [where condition];</span><br><span class="line"></span><br><span class="line">select firstName, mi, lastName from Student where deptId = &#x27;CS&#x27; and zipCode = &#x27;31411&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>您可以在模式 p 中使用通配符<code> %</code>（百分比符号）和<code> _</code>（下划线符号）。<br><code>%</code> 匹配零个或多个字符，<br><code>_</code> 匹配 s 中的任何单个字符。<br>例如，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lastName <span class="keyword">like</span> <span class="string">&#x27;_mi%&#x27;</span>     匹配任何第二个和第三个字母是 m 和 i 的字符串</span><br><span class="line"></span><br><span class="line">lastName <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;_mi%&#x27;</span>   排除第二个和第三个字母是 m 和 i 的任何字符串。</span><br></pre></td></tr></table></figure>



<p><code>between-and </code>运算符使用以下语法检查值 v 是否在其他<code>两个值 v1 和 v2 之间</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v between v1 and v2           //    v &gt;= v1 and v &lt;= v2 </span><br><span class="line">v not between  v1 and v2      // v &lt; v1 or v &gt; v2 .</span><br></pre></td></tr></table></figure>



<p>is null 运算符使用以下语法检查值 v 是否为空：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">v <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">or</span> v <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>



<p>SQL 提供了 <code>distinct </code>关键字，可用于<code>消除结果中的重复元组</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> subjectId <span class="keyword">as</span> &quot;Subject ID&quot; <span class="keyword">from</span> Course; </span><br></pre></td></tr></table></figure>

<p>SQL 提供了 <code>order by</code> 子句来使用以下语法对输出进行<code>排序</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">column</span><span class="operator">-</span>list <span class="keyword">from</span> <span class="keyword">table</span><span class="operator">-</span>list [ <span class="keyword">where</span> <span class="keyword">condition</span>] [ <span class="keyword">order</span> <span class="keyword">by</span> 某列];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>默认情况下，顺序是升序。 要按降序排序 请附加 <span class="keyword">desc</span> 关键字</span><br><span class="line"><span class="keyword">select</span> lastName, firstName, deptId <span class="keyword">from</span> Student <span class="keyword">where</span> deptId <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> lastName <span class="keyword">desc</span> ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>










<h2 id="销毁drop"><a href="#销毁drop" class="headerlink" title="销毁drop"></a>销毁drop</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column-list from table-list [where condition];</span><br><span class="line"></span><br><span class="line">select firstName, mi, lastName from Student where deptId = &#x27;CS&#x27; and zipCode = &#x27;31411&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>















<h1 id="修改用户有远程权限"><a href="#修改用户有远程权限" class="headerlink" title="修改用户有远程权限"></a>修改用户有远程权限</h1><h2 id="1-让数据库有远程监听选项"><a href="#1-让数据库有远程监听选项" class="headerlink" title="1.让数据库有远程监听选项"></a>1.让数据库有远程监听选项</h2><h2 id="2-更改-账号权限"><a href="#2-更改-账号权限" class="headerlink" title="2. 更改 账号权限"></a>2. 更改 账号权限</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select User, host from mysql.user;</span><br></pre></td></tr></table></figure>

<p>root账户中的host项是localhost表示该账号只能进行本地登录，我们需要修改权限，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p>修改权限。%表示针对所有IP，password表示将用这个密码登录root用户，如果想只让某个IP段的主机连接，可以修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;192.168.100.%&#x27; IDENTIFIED BY &#x27;my-new-password&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p><strong>注意：此时远程连接的密码可能与你在本地登录时的密码不同了，主要看你在IDENTIFIED BY后面给了什么密码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql restart</span><br></pre></td></tr></table></figure>

<h2 id="2-另-创建有远程权限的用户"><a href="#2-另-创建有远程权限的用户" class="headerlink" title="2.(另)创建有远程权限的用户"></a>2.(另)创建有远程权限的用户</h2><h2 id="3-得到-重置-远程密码"><a href="#3-得到-重置-远程密码" class="headerlink" title="3.得到(重置) 远程密码"></a>3.得到(重置) 远程密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select User,authentication_string,Host from user;</span><br></pre></td></tr></table></figure>

<p>host默认都是localhost访问权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>重置远程密码</p>
<p><a href="https://blog.csdn.net/m0_37482190/article/details/86624096">mysql：MySQL数据库修改用户权限（远程访问权限、操作权限）</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h2><p>关闭自动提交     设置回滚点</p>
<p><code>setAutoCommit(false) </code>方法禁用自动提交</p>
<p>因此所有 SQL 语句都被分组到一个事务中，该事务通过调用 </p>
<p><code>commit() 或 rollback() </code>方法终止。 rollback() 方法撤消事务所做的所有更改。</p>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从 连接 创建 批处理接口</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"><span class="comment">// 添加任务</span></span><br><span class="line">statement.addBatch(<span class="string">&quot;create table T (C1 integer, C2 varchar(15))&quot;</span>);</span><br><span class="line">statement.addBatch( <span class="string">&quot;insert into T values (100, &#x27;Smith&#x27;)&quot;</span> );</span><br><span class="line">statement.addBatch( <span class="string">&quot;insert into T values (200, &#x27;Jones&#x27;)&quot;</span> );</span><br><span class="line"><span class="comment">// 批量执行 分别返回</span></span><br><span class="line"><span class="type">int</span> count[] = statement.executeBatch();</span><br></pre></td></tr></table></figure>

<p>要确定驱动程序是否支持批量更新，请在 DatabaseMetaData 实例上调用 supportsBatchUpdates()。 </p>
<p>您不能在批处理中执行 SELECT 语句</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>CallableStatement 接口旨在执行 SQL 存储过程。 过程可能有 IN、OUT 或 IN OUT 参数。 </p>
<p>IN 参数在调用时接收传递给过程的值。 OUT 参数在过程完成后返回一个值，但在调用过程时它不包含任何值。 </p>
<p>IN-OUT 参数包含在调用过程时传递给过程的值，并在完成后返回一个值。</p>
<p> 例如，Oracle PL&#x2F;SQL 中的以下过程具有 IN 参数 p1 、 OUT 参数 p2 和 IN OUT 参数 p3</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">procedure</span> sampleProcedure</span><br><span class="line">(p1 <span class="keyword">in</span> <span class="type">varchar</span>, p2 <span class="keyword">out</span> number, p3 <span class="keyword">in</span> <span class="keyword">out</span> <span class="type">integer</span>) </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">/* do something */</span></span><br><span class="line"><span class="keyword">end</span> sampleProcedure;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注册</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">function</span> studentFound </span><br><span class="line">(<span class="keyword">first</span> varchar2, <span class="keyword">last</span> varchar2) </span><br><span class="line"><span class="keyword">return</span> number <span class="keyword">is</span> numberOfSelectedRows number :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> numberOfSelectedRows</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> Student.firstName <span class="operator">=</span> <span class="keyword">first</span> <span class="keyword">and</span></span><br><span class="line">Student.lastName <span class="operator">=</span> <span class="keyword">last</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> numberOfSelectedRows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> studentFound;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">callableStatement</span> <span class="operator">=</span>connection.prepareCall(</span><br><span class="line"><span class="string">&quot;&#123;call sampleProcedure(?, ?, ?)&#125;&quot;</span>);</span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">callableStatement</span> <span class="operator">=</span>connection.prepareCall(</span><br><span class="line"><span class="string">&quot;&#123;? = call studentFound(?, ?)&#125;&quot;</span>);</span><br><span class="line"><span class="comment">//调用 两种方式   ,注册 存储过程句柄函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">callableStatement.setString(<span class="number">2</span>, firstName);</span><br><span class="line">callableStatement.setString(<span class="number">3</span>, lastName);</span><br><span class="line"><span class="comment">//设置 传出类型</span></span><br><span class="line">callableStatement.registerOutParameter(<span class="number">1</span>, Types.INTEGER);</span><br><span class="line">callableStatement.execute();  <span class="comment">//或 executeUpdate ()</span></span><br><span class="line"></span><br><span class="line">callableStatement.getInt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://zhuanlan.zhihu.com/p/137896709">存储过程这一篇就够了</a></p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>通过DatabaseMetaData接口 从 连接句柄  获取数据库URL、用户名、JDBC驱动名称等数据库元数据，  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbMetaData</span> <span class="operator">=</span> connection.getMetaData();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;database URL: &quot;</span> + dbMetaData.getURL());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;database username:&quot;</span>+dbMetaData.getUserName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;database product name: &quot;</span>+dbMetaData.getDatabaseProductName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;database product version: &quot;</span>+dbMetaData.getDatabaseProductVersion());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;JDBC driver name: &quot;</span> +</span><br><span class="line"> dbMetaData.getDriverName());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;JDBC driver version: &quot;</span> +</span><br><span class="line"> dbMetaData.getDriverVersion());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;JDBC driver major version: &quot;</span> +</span><br><span class="line"> dbMetaData.getDriverMajorVersion());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;JDBC driver minor version: &quot;</span> +</span><br><span class="line"> dbMetaData.getDriverMinorVersion());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Max number of connections: &quot;</span> +</span><br><span class="line"> dbMetaData.getMaxConnections());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;MaxTableNameLength: &quot;</span> +</span><br><span class="line"> dbMetaData.getMaxTableNameLength());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;MaxColumnsInTable: &quot;</span> +</span><br><span class="line"> dbMetaData.getMaxColumnsInTable());</span><br><span class="line">----------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 结果集 从 连接元数据 获取 getTables </span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rsTables</span> <span class="operator">=</span> dbMetaData.getTables(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;TABLE&quot;</span>&#125;);</span><br><span class="line"><span class="keyword">while</span> (rsTables.next()) </span><br><span class="line">    System.out.print(rsTables.getString(<span class="string">&quot;TABLE_NAME&quot;</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>通过ResultSetMetaData接口 从结果集 获取表列数、列名等结果集元数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery</span><br><span class="line"> (<span class="string">&quot;select * from Enrollment&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsMetaData</span> <span class="operator">=</span></span><br><span class="line">    resultSet.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= rsMetaData.getColumnCount(); i++)</span><br><span class="line">    System.out.printf(<span class="string">&quot;%-12s\t&quot;</span>,rsMetaData.getColumnName(i));</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=rsMetaData.getColumnCount(); i++)</span><br><span class="line">			System.out.printf(<span class="string">&quot;%-12s\t&quot;</span>,resultSet.getObject(i));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">displayResultSet</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"> 	<span class="type">ResultSetMetaData</span> <span class="variable">rsMetaData</span> <span class="operator">=</span> resultSet.getMetaData();</span><br><span class="line"> 	resultSet.beforeFirst();</span><br><span class="line"> 	<span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">     	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= rsMetaData.getColumnCount(); i++)</span><br><span class="line"> 			System.out.printf(<span class="string">&quot;%-12s\t&quot;</span>, resultSet.getObject(i));</span><br><span class="line"> 	 	System.out.println(); &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要查找结果集中的列数，首先使用 </p>
<p>ResultSet 上的 getMetaData ()方法创建 ResultSetMetaData 实例。</p>
<p>使用 getColumnCount ()返回列计数，</p>
<p>使用 getColumnName (int)返回列名</p>
<h2 id="可更新结果集"><a href="#可更新结果集" class="headerlink" title="可更新结果集"></a>可更新结果集</h2><p>访问数据库的一个更强大的方法是使用可滚动和可更新的结果，这使您能够向前和向后滚动行，并使用第一个、最后一个、下一个、上一个、绝对或相对方法将光标移动到所需的位置。此外，还可以在结果集中插入、删除或更新行，并将更改自动反映到数据库中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接 创建 滚动 句柄  //  句柄 执行的 结果集 都是 可滚动</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement(<span class="type">int</span> resultSetType, <span class="type">int</span> resultSetConcurrency);</span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(String sql, <span class="type">int</span> resultSetType, <span class="type">int</span> resultSetConcurrency);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resultSetType	 </span></span><br><span class="line">TYPE_FORWARD_ONLY ：按顺序向前访问结果集。</span><br><span class="line">TYPE_SCROLL_INSENSITIVE：结果集是可滚动的，但对数据库中的更改不敏感。</span><br><span class="line">TYPE_SCROLL_SENSITIVE：结果集是可滚动的，并且对其他人所做的更改敏感。 如果您希望结果集可滚动和更新，请使用此类型。</span><br><span class="line"></span><br><span class="line"><span class="comment">// resultSetConcurrency </span></span><br><span class="line">CONCUR_READ_ONLY：结果集不能用于更新数据库。 </span><br><span class="line">CONCUR_UPDATABLE：结果集可用于更新数据库。 例如，如果您希望结果集可滚动和可更新，您可以</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement</span><br><span class="line">(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">    <span class="comment">// 连接 创建 滚动 句柄  //  句柄 执行的 结果集 都是 可滚动</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(query);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// first() 、 next() 、 previous() 和  last()  absolute(int row) 方法将光标移动到</span></span><br><span class="line"><span class="comment">//  第一行、   下一行、   上一行和       最后一行   指定行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getXxx(int columnIndex) 或 getXxx(String columnName) 方法用于检索当前行指定字段的值</span></span><br><span class="line">    <span class="comment">// insertRow() 、 deleteRow() 和 updateRow() 方法也可用于插入、删除和更新当前行。 </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Update the second row</span></span><br><span class="line">    resultSet.absolute(<span class="number">2</span>); <span class="comment">// Move cursor to the second row</span></span><br><span class="line">	resultSet.updateString(<span class="string">&quot;state&quot;</span>, <span class="string">&quot;New S&quot;</span>); <span class="comment">// Update the column</span></span><br><span class="line"> 	resultSet.updateString(<span class="string">&quot;capital&quot;</span>, <span class="string">&quot;New C&quot;</span>); <span class="comment">// Update the column</span></span><br><span class="line"> 	resultSet.updateRow(); <span class="comment">// Update the row in the data source</span></span><br><span class="line">    <span class="comment">//在应用 insertRow 或 updateRow 之前，需要使用 updateXxx (int columnIndex，Xxx 值)或 update (String columnName，Xxx 值)方法向当前行的字段写入一个新值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//CancelRowUpdates ()方法取消对行的更新。Close ()方法关闭结果集并释放其资源。如果最后一列读取的值为 sqlnull，则 wasNull ()方法返回 true。</span></span><br></pre></td></tr></table></figure>

<p>可更新的 ResultSet 对象有一个与之关联的特殊行，用作构建要插入的行的暂存区。 此特殊行称为插入行。</p>
<p>要插入一行，首先调用 moveToInsertRow() 方法将光标移动到插入行（第 36 行），然后使用 updateXxx 方法更新列（第 37-38 行），最后使用 insertRow() 插入行 方法（第 39 行） 调用 moveToCurrentRow() 将光标移动到当前插入的行（第 40 行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Insert after the last row</span></span><br><span class="line">resultSet.last();</span><br><span class="line">resultSet.moveToInsertRow(); <span class="comment">// Move cursor to the insert row</span></span><br><span class="line">resultSet.updateString(<span class="string">&quot;state&quot;</span>, <span class="string">&quot;Florida&quot;</span>);</span><br><span class="line">resultSet.updateString(<span class="string">&quot;capital&quot;</span>, <span class="string">&quot;Tallahassee&quot;</span>);</span><br><span class="line">resultSet.insertRow(); <span class="comment">// Insert the row</span></span><br><span class="line">resultSet.moveToCurrentRow(); <span class="comment">// Move the cursor to the current row </span></span><br></pre></td></tr></table></figure>

<p>可以在 DatabaseMetaData 接口中使用 supportsResultSetType (int type)和 supportsResultSetConcurrency (int type，int concurrency)来查找 JDBC 驱动程序支持哪种结果类型和模式</p>
<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>SQL3 引入了一种称为 BLOB（Binary Large OBject）的新数据类型，用于存储二进制数据，可用于存储图像</p>
<p>另一种新的 SQL3 类型是 CLOB（Character Large OBject），用于以字符格式存储大文本</p>
<p>​	 您可以使用 getBlob 、 setBinaryStream 、 getClob 、 setBlob 和 setClob 来访问接口 ResultSet 和 PreparedStatement 中的 SQL BLOB 和 CLOB 值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Country(name <span class="type">varchar</span>(<span class="number">30</span>), flag <span class="type">blob</span>, description <span class="type">varchar</span>(<span class="number">255</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;insert into Country values(?, ?, ?)&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(imageFilename);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="comment">//图像通常存储在文件中。 您可以首先获取图像文件的 InputStream 实例，然后使用 setBinaryStream 方法将输入流与表中的单元格关联，</span></span><br><span class="line">pstmt.setBinaryStream(<span class="number">2</span>, inputImage, (<span class="type">int</span>)(file.length())); </span><br><span class="line">-</span><br><span class="line"><span class="comment">//恢复图像</span></span><br><span class="line"><span class="type">Blob</span> <span class="variable">blob</span> <span class="operator">=</span> rs.getBlob( <span class="number">1</span> );</span><br><span class="line"><span class="type">ImageIcon</span> <span class="variable">imageIcon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageIcon</span>( blob.getBytes( <span class="number">1</span> , (<span class="type">int</span>)blob.length()));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>参数</tag>
        <tag>int</tag>
        <tag>return</tag>
        <tag>char</tag>
        <tag>数据库</tag>
        <tag>sql</tag>
        <tag>类型</tag>
        <tag>temp</tag>
        <tag>next</tag>
        <tag>函数</tag>
        <tag>字符</tag>
        <tag>排序</tag>
        <tag>账号</tag>
        <tag>var</tag>
        <tag>静态</tag>
        <tag>mysql</tag>
        <tag>name</tag>
        <tag>语句</tag>
        <tag>statement</tag>
        <tag>resultset</tag>
        <tag>select</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaFx Tips</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-10-14-JavaFx_tips/</url>
    <content><![CDATA[<h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setRotate()旋转角度</span><br><span class="line">setStyle(&quot;-fx-stroke:black;-fx-fill:red;&quot;);</span><br><span class="line">contains      </span><br><span class="line">setScaleX 缩放节点</span><br></pre></td></tr></table></figure>

<h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">centerX/YProperty.bind(  )</span><br><span class="line">d1.bindBidirectional(d2)双向绑定    </span><br><span class="line">			SimpleDoubleProperty</span><br></pre></td></tr></table></figure>



<h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造方法(r,g,b,透明度)   </span><br><span class="line">静态    Color.rgb(255,255,255)</span><br><span class="line">静态    Color.RED</span><br></pre></td></tr></table></figure>

<h3 id="Font"><a href="#Font" class="headerlink" title="Font"></a>Font</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Font (size)</span><br></pre></td></tr></table></figure>

<h3 id="Image-x2F-ImageView"><a href="#Image-x2F-ImageView" class="headerlink" title="Image&#x2F;ImageView"></a>Image&#x2F;ImageView</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Image  (path/url)  </span><br><span class="line"></span><br><span class="line">ImageView(Image)   </span><br><span class="line">	setFitHeight/FitWidth 设置长宽</span><br></pre></td></tr></table></figure>



<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TextField 输入框</span><br><span class="line">// setPreColumnCount 列数</span><br><span class="line">//Label     文字栏</span><br><span class="line">//Button    按钮</span><br><span class="line">//</span><br></pre></td></tr></table></figure>

<h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str可用\n</span><br><span class="line">构造方法  Text(str)</span><br><span class="line">		 Text(x,y,str)</span><br><span class="line">underline:boolean</span><br><span class="line">strikethrough:boolean 删除线</span><br><span class="line">指定Font </span><br></pre></td></tr></table></figure>

<h3 id="Line"><a href="#Line" class="headerlink" title="Line"></a>Line</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">startX/Y </span><br><span class="line">endX/Y</span><br><span class="line">Line(startx,starty,endx,endy)</span><br></pre></td></tr></table></figure>

<h3 id="Rectangle-矩形"><a href="#Rectangle-矩形" class="headerlink" title="Rectangle  矩形"></a>Rectangle  矩形</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/y/width/height </span><br><span class="line">arcWidth/arvHEight  圆角弧度水平直径/垂直直径</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h2><h3 id="Circle-与-Ellipse椭圆-与-ARC-弧度"><a href="#Circle-与-Ellipse椭圆-与-ARC-弧度" class="headerlink" title="Circle 与 Ellipse椭圆 与 ARC 弧度"></a>Circle 与 Ellipse椭圆 与 ARC 弧度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">圆</span><br><span class="line">setCenterX/Y/Radius  半径</span><br><span class="line">setStroke/Fill 边框颜色/填充颜色</span><br><span class="line"></span><br><span class="line">椭圆</span><br><span class="line">centerX/Y </span><br><span class="line">radiusX/Y 水平/垂直半径</span><br><span class="line"></span><br><span class="line">ARC 弧度</span><br><span class="line">centerX/Y </span><br><span class="line">radiusX/Y 水平/垂直半径</span><br><span class="line">startAngle 起始角度 </span><br><span class="line">length     角度范围(逆时针旋转)</span><br><span class="line">type : ArcType.OPEN ArcType.CHORD ArcType.ROUND 弧度闭合类型</span><br></pre></td></tr></table></figure>

<p>OPEN</p>
<p><img src="https://tu.yegetables.com/images/2021/10/06/20211006163137.png" alt="image-20211006163130582"></p>
<p>CHORD</p>
<p><img src="https://tu.yegetables.com/images/2021/10/06/20211006163142.png" alt="image-20211006163142664"></p>
<p>ROUND</p>
<p><img src="https://tu.yegetables.com/images/2021/10/06/20211006163149.png" alt="image-20211006163149007"></p>
<h3 id="点集连线-Polygon-与-Poltyline-不自动闭合"><a href="#点集连线-Polygon-与-Poltyline-不自动闭合" class="headerlink" title="点集连线 Polygon 与 Poltyline(不自动闭合)"></a>点集连线 Polygon 与 Poltyline(不自动闭合)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getPoints():list  </span><br><span class="line">向list 添加 坐标   (x1,y1,x2,y2)</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/10/06/20211006165449.png" alt="image-20211006165449791"></p>
<h1 id="Pane"><a href="#Pane" class="headerlink" title="Pane"></a>Pane</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setPadding(new Insets&#123;11,12,13,14&#125;) 设置 上下左右间距</span><br></pre></td></tr></table></figure>

<h2 id="StackPane-中央-叠加"><a href="#StackPane-中央-叠加" class="headerlink" title="StackPane      中央  叠加"></a>StackPane      中央  叠加</h2><h2 id="FlowPane-水平-或-垂直-排列"><a href="#FlowPane-水平-或-垂直-排列" class="headerlink" title="FlowPane     (水平 或 垂直 )排列"></a>FlowPane     (水平 或 垂直 )排列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setAlignment(Pos.CENTER);整体对齐方式 默认 左对齐Pos.LEFT</span><br><span class="line"></span><br><span class="line">setH/Vgap() 水平间距/垂直间距</span><br><span class="line"></span><br><span class="line">setOrientation( Orientation.HORIZONTAL 水平排列默认/ Orientation.VERTICAL 垂直排列);</span><br></pre></td></tr></table></figure>

<h2 id="GridPane-二维网格-单元格"><a href="#GridPane-二维网格-单元格" class="headerlink" title="GridPane      二维网格 单元格"></a>GridPane      二维网格 单元格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setAlignment/H/Vgap 设置整体对齐/间距</span><br><span class="line">setGridLinesVisible 网格线可见</span><br><span class="line">add(Node,cloumn,row)/getCloumnIndex(node)获得节点列下标 </span><br><span class="line">setH/Valighnment   		设置单元格中子项的水平对齐方式/垂直对齐方式</span><br></pre></td></tr></table></figure>

<h2 id="BorderPane-顶部-右边-底部-左边-中间"><a href="#BorderPane-顶部-右边-底部-左边-中间" class="headerlink" title="BorderPane    顶部 右边 底部 左边 中间"></a>BorderPane    顶部 右边 底部 左边 中间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTop setBottom setLeft setRight setCenter(Node)</span><br></pre></td></tr></table></figure>

<h2 id="HBox-x2F-VBox-单行-x2F-列"><a href="#HBox-x2F-VBox-单行-x2F-列" class="headerlink" title="HBox&#x2F;VBox 单行&#x2F;列"></a>HBox&#x2F;VBox 单行&#x2F;列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pane.setSpacing(8)  设置间距</span><br></pre></td></tr></table></figure>



<h2 id="滚动-ScrollPane"><a href="#滚动-ScrollPane" class="headerlink" title="滚动 ScrollPane"></a>滚动 ScrollPane</h2><h1 id="EVENT"><a href="#EVENT" class="headerlink" title="EVENT"></a>EVENT</h1><h2 id="ActionEvent"><a href="#ActionEvent" class="headerlink" title="ActionEvent"></a>ActionEvent</h2><p>( setOnAction)</p>
<p>按钮 单击</p>
<p>文本域 回车</p>
<p>勾选 &#x2F;取消勾选 </p>
<p>选择一个项 </p>
<h2 id="MouseEvent"><a href="#MouseEvent" class="headerlink" title="MouseEvent"></a>MouseEvent</h2><p>按下  setOnMousePressed </p>
<p>释放 setOnMouseReleased</p>
<p>单击 setOnMouseClicked</p>
<p>进入 setOnMouseEntered</p>
<p>退出 setOnMouseExited</p>
<p>移动 setOnMouseMoved</p>
<p>拖动 setOnMouseDragged </p>
<p>event   {</p>
<p>is Alt &#x2F; Control &#x2F; Meta &#x2F; Shift Down ()  事件中 alt&#x2F;ctr&#x2F;鼠标中键&#x2F;shift 键是否按下</p>
<p>getButton()     &#x2F;&#x2F;    枚举  左键MouseButton.PRIMARY    右键MouseButton.SECONDARY </p>
<p>​						&#x2F;&#x2F;   中键MouseButton.MIDDLE  </p>
<p> getX&#x2F;Y ()</p>
<p>}</p>
<h2 id="KeyEvent"><a href="#KeyEvent" class="headerlink" title="KeyEvent"></a>KeyEvent</h2><p>按下  setOnKeyPressed</p>
<p>释放 setOnKeyReleased</p>
<p>敲击 setOnKeyTyped       非Unicode 字符时 不调用 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keyEvent&#123;</span><br><span class="line">	getCharacter</span><br><span class="line">	getCode</span><br><span class="line">	getText</span><br><span class="line">	</span><br><span class="line">	is Alt/Control/Meta/Shift Down</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按下/释放     getcode 返回常量值  getText 描述  getCharacter 空</span><br><span class="line"></span><br><span class="line">敲击         getCode -&gt;UNDEFINED       getCharacter 返回UNicode字符/其他</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://tu.yegetables.com/images/2021/10/07/20211007163112.png" alt="image-20211007163111777"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b.setOnKeyPressed(e -&gt; &#123;</span><br><span class="line">           switch (e.getCode())</span><br><span class="line">           &#123;</span><br><span class="line">               case UP:</span><br><span class="line">                   b.setY(b.getY() - 10);</span><br><span class="line">                   System.out.println(&quot;UP&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               case DOWN:</span><br><span class="line">                   b.setY(b.getY() + 10);</span><br><span class="line">                   System.out.println(&quot;DOWN&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               case LEFT:</span><br><span class="line">                   b.setX(b.getX() - 10);</span><br><span class="line">                   System.out.println(&quot;LEFT&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               case RIGHT:</span><br><span class="line">                   b.setX(b.getX() + 10);</span><br><span class="line">                   System.out.println(&quot;RIGHT&quot;);</span><br><span class="line">                   break;</span><br><span class="line">               default:</span><br><span class="line">                   System.out.println(e.getText());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       b.requestFocus();</span><br><span class="line">       //    一定是show之后才能 指定 某个 node 获取焦点 得到输入 </span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       //第二种方法     让 scence 指定 键盘监听   </span><br><span class="line">scence.setOnKeyPressed(   .........) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>可观察对象 的 addListener 方法  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DoubleProperty dp=<span class="keyword">new</span> <span class="title class_">DoubleProperty</span>();</span><br><span class="line">dp.addListener( ov-&gt; sout(dp.value()));</span><br></pre></td></tr></table></figure>







<h1 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autoReverse  交替周期 是否需要倒转方向</span><br><span class="line">cycleCount    循环次数    Timeline.INDEFINITE 无限</span><br><span class="line">rate  速度</span><br><span class="line"></span><br><span class="line">status    &#123; Status.PAUSED  Status.RUNNING Status.STOPPED       &#125;</span><br><span class="line">pause() stop() play( )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="PathTransition-节点沿路径"><a href="#PathTransition-节点沿路径" class="headerlink" title="PathTransition 节点沿路径"></a>PathTransition 节点沿路径</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">duration 持续时间</span><br><span class="line">node  变换的节点(移动物)</span><br><span class="line">orientation  方向     PathTransition.OrientationType.ORTHOGONAL_TO_TANGENT  与路径切线垂直</span><br><span class="line">path  &lt;Shape&gt; 路径的形状</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">构造器 </span><br><span class="line">空</span><br><span class="line">(时间,路径)</span><br><span class="line">(时间,路径,节点)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 		PathTransition pt = new PathTransition();</span><br><span class="line">        pt.setDuration(Duration.millis(1000));  //每次持续时间</span><br><span class="line">        pt.setPath(circle);</span><br><span class="line">        pt.setNode(rectangle);</span><br><span class="line">        pt.setOrientation(PathTransition.OrientationType.ORTHOGONAL_TO_TANGENT);//方向 </span><br><span class="line">        pt.setAutoReverse(true);</span><br><span class="line">        pt.setRate(2.0);</span><br><span class="line">        pt.setCycleCount(Timeline.INDEFINITE);//无限次</span><br><span class="line">        pt.play();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="FadeTransition-改变透明度"><a href="#FadeTransition-改变透明度" class="headerlink" title="FadeTransition 改变透明度"></a>FadeTransition 改变透明度</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">duration  持续时间</span><br><span class="line">node </span><br><span class="line">fromValue</span><br><span class="line">toValue</span><br><span class="line">byValue  递增值</span><br></pre></td></tr></table></figure>

<h2 id="TimeLine-自定义-关键帧"><a href="#TimeLine-自定义-关键帧" class="headerlink" title="TimeLine  自定义 关键帧"></a>TimeLine  自定义 关键帧</h2><p>对于每一个关键帧KeyFrame     定义 处理函数hander ,在该关键帧 结束后调用      EventHandler</p>
<p>对于 Timeline   由若干个  关键帧 组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Text t = new Text(30, 30, &quot;11111&quot;);</span><br><span class="line">        EventHandler hander = e -&gt; &#123;</span><br><span class="line">            if (t.getText().length() == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                t.setText(&quot;11111&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                t.setText(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Timeline tl = new Timeline(new KeyFrame(Duration.millis(1000), hander));</span><br></pre></td></tr></table></figure>



<h1 id="UI控件"><a href="#UI控件" class="headerlink" title="UI控件"></a>UI控件</h1><h2 id="Label-标签"><a href="#Label-标签" class="headerlink" title="Label 标签"></a>Label 标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graphic   标签修饰的Node</span><br><span class="line"></span><br><span class="line">label.setContentDisplay( )</span><br><span class="line"> 	//常量    ContentDisplay.Top/BOTTOM/LEFT/RIGHT    结点相对于文本的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><p>onaction </p>
<h2 id="CheckBox-复选框"><a href="#CheckBox-复选框" class="headerlink" title="CheckBox 复选框"></a>CheckBox 复选框</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onaction()</span><br><span class="line"></span><br><span class="line">selected     :boolean</span><br><span class="line">isSelected()  判断选中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RadioButton-单选框-圆"><a href="#RadioButton-单选框-圆" class="headerlink" title="RadioButton 单选框(圆)"></a>RadioButton 单选框(圆)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按钮组可以做到  互斥选择</span><br><span class="line">toggleGroup 字段 选择按钮组</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ToggleGroup tg=new ToggleGroup();</span><br><span class="line">rb1.setToggleGroup(tg);</span><br><span class="line">rb2.setToggleGroup(tg);</span><br><span class="line">rb3.setToggleGroup(tg);</span><br><span class="line">//添加 rb1/2/3到一个按钮组</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="TextField-文本域"><a href="#TextField-文本域" class="headerlink" title="TextField 文本域"></a>TextField 文本域</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setEditable(false)    锁定不可变</span><br><span class="line">onaction() 回车 时触发一个ActionEvent</span><br><span class="line">prefColumnCount    列数  可设置</span><br></pre></td></tr></table></figure>

<h2 id="TextArea-多行输入"><a href="#TextArea-多行输入" class="headerlink" title="TextArea 多行输入"></a>TextArea 多行输入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prefRowCount/prefRowCount 指定行列数</span><br><span class="line"></span><br><span class="line">wrapText: boolean 指定自动换行</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="滚动-ScrollPane-1"><a href="#滚动-ScrollPane-1" class="headerlink" title="滚动 ScrollPane"></a>滚动 ScrollPane</h2><p>一般是创建一个  ScrollPane 包裹着 TextArea </p>
<p>可以上下左右滚动</p>
<h2 id="组合框-x2F-下拉单向选择-ComboBox"><a href="#组合框-x2F-下拉单向选择-ComboBox" class="headerlink" title="组合框 &#x2F;下拉单向选择  ComboBox"></a>组合框 &#x2F;下拉单向选择  ComboBox</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ComboBox&lt;T&gt; cbo=new ComboBox&lt;&gt;();</span><br><span class="line">cbo.getItems.add/addALL( T values );</span><br><span class="line">cbo.setValue( T value1 )</span><br><span class="line">//cbo.setStyle  color</span><br><span class="line"></span><br><span class="line">被选中时 ActionEvent 触发</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="下拉多项选择-ListView"><a href="#下拉多项选择-ListView" class="headerlink" title="下拉多项选择 ListView"></a>下拉多项选择 ListView</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">items  选项们</span><br><span class="line">orientation: boolean   选项水平/垂直显示</span><br><span class="line">SelectionMode()   :&#123;</span><br><span class="line">			可设置  选择模式( 默认单选 SelectionMode.SINGLE/多选SelectionMode.MULTIPLE) </span><br><span class="line">			</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> //由列表  添加到选项列表</span><br><span class="line">  ListView&lt;String&gt; lv = new ListView&lt;&gt;();</span><br><span class="line">  ObservableList&lt;String&gt; ol = FXCollections.observableArrayList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;);</span><br><span class="line">  lv.setItems(ol);</span><br><span class="line">   </span><br><span class="line"> // 设置 单选 多选</span><br><span class="line">  lv.getSelectionMode().setSelectionMode(SelectionMode.MULTIPLE);//先获取在设置</span><br><span class="line">  </span><br><span class="line">  //设置监听   已选择的内容</span><br><span class="line">   lv.getSelectionModel().selectedItemProperty().addListener(new ChangeListener&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void changed(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) &#123;</span><br><span class="line">                System.out.println(&quot;oldvalue=&quot; + oldValue + &quot; newvalue=&quot; + newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="滚动条-ScrollBar"><a href="#滚动条-ScrollBar" class="headerlink" title="滚动条 ScrollBar"></a>滚动条 ScrollBar</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blockIncrement    单击按钮时改变的值</span><br><span class="line">max/min</span><br><span class="line">unitIncrement      调用方法时调整 滚动条的量</span><br><span class="line">value 当前值  0</span><br><span class="line">visibleAmount  选择块宽度 默认15</span><br><span class="line">oritntation : 方向 默认横向HORIZONTAL</span><br><span class="line">increment( )/decrement()    滚动条改变 unitIncrement 值 -+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">监听改变</span><br><span class="line">ScrollBar 的 valueProperty().addListener()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Slider-滑动条-—-增强版滚动条"><a href="#Slider-滑动条-—-增强版滚动条" class="headerlink" title="Slider  滑动条   —-增强版滚动条"></a>Slider  滑动条   —-增强版滚动条</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blockIncrement  单击时调节的值</span><br><span class="line">max/min/value</span><br><span class="line">oritntation : 方向 默认横向HORIZONTAL</span><br><span class="line">majorTickUnit/minorTickUnit 主刻度间隔距离/两个主刻度间的次刻度数</span><br><span class="line">showTickLabels/showTickMarks  :Boolean  是否显示 刻度标签/刻度</span><br><span class="line"></span><br><span class="line">监听</span><br><span class="line">监听改变</span><br><span class="line">Sl 的 valueProperty().addListener()</span><br></pre></td></tr></table></figure>

<h2 id="Media-影音"><a href="#Media-影音" class="headerlink" title="Media 影音"></a>Media 影音</h2><h3 id="Media"><a href="#Media" class="headerlink" title="Media"></a>Media</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">duration 持续时间/s</span><br><span class="line">width/height </span><br><span class="line"></span><br><span class="line">构造方法(url)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="MediaPlayer-播放和控制媒体"><a href="#MediaPlayer-播放和控制媒体" class="headerlink" title="MediaPlayer 播放和控制媒体"></a>MediaPlayer 播放和控制媒体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autoPlay :boolean 自动开始</span><br><span class="line">currentCount : readonly 已循环播放次数</span><br><span class="line">cycleCount   : 指定播放次数</span><br><span class="line">mute			:是否静音</span><br><span class="line">volume		:音量	</span><br><span class="line">totalDuration	:从开始到结束播放媒体的持续时间</span><br><span class="line">	</span><br><span class="line">pause()/play()</span><br><span class="line">seek()  定位到时间点  Duration.ZERO q</span><br><span class="line">构造( MEDIA )</span><br></pre></td></tr></table></figure>

<h3 id="MediaView-显示视频"><a href="#MediaView-显示视频" class="headerlink" title="MediaView 显示视频"></a>MediaView 显示视频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">x/y</span><br><span class="line">mediaPlayer</span><br><span class="line">fitWidth/fitHeight </span><br><span class="line"></span><br><span class="line">构造(MEDIAPLAYER)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>gui</tag>
        <tag>javaFx</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程 基础</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-10-14-java%E7%BA%BF%E7%A8%8B_%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="任务Runnable接口"><a href="#任务Runnable接口" class="headerlink" title="任务Runnable接口"></a>任务Runnable接口</h2><p>实现接口Runnable的run方法   可以被线程执行</p>
<h2 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h2><p>start 方法   创建 指定 去调run 方法,交给jvm选择时间 和线程 去并发执行</p>
<p>run 方法     直接调 run方法 执行任务,不并发</p>
<p>thread 可以实现 runnable  接口 将  线程的启动交给别的线程</p>
<p><img src="https://tu.yegetables.com/images/2021/10/14/20211014160551.png" alt="image-20211014160544627"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getPriority() 得到优先级</span><br><span class="line"> setPriority()   </span><br><span class="line"> Thread 静态常量	  MIN_PRIORITY , NORM_PRIORITY , and MAX_PRIORITY , </span><br></pre></td></tr></table></figure>



<p>tips:  javaFX 执行 显示 时需要将 任务 交给 主线程 Platform.runLater(Runnable r)</p>
<h2 id="Thread-Pools-Executors-new"><a href="#Thread-Pools-Executors-new" class="headerlink" title="Thread Pools   ( Executors.new)"></a>Thread Pools   ( Executors.new)</h2><p><img src="https://tu.yegetables.com/images/2021/10/14/20211014160935.png" alt="image-20211014160935259"></p>
<p>静态方法创建线程池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executors 工具类</span><br><span class="line">	Executors.newFixedThreadPool(3);</span><br><span class="line">	//线程数固定   一直存在，直到它被明确shutdown 。</span><br><span class="line">	//多的任务 在队列中等待，直到有线程可用。 </span><br><span class="line">	</span><br><span class="line">    Executors.newCachedThreadPool();</span><br><span class="line">    // 根据需要创建新线程，但在可用时将重用先前构造的线程。 </span><br><span class="line">    // 60 秒内未使用的线程将被终止并从缓存中删除。 因此，保持空闲足够长时间的池不会消耗任何资源。 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(3);</span><br><span class="line"></span><br><span class="line">	executor.execute(new PrintChar(&#x27;a&#x27;, 100));</span><br><span class="line">	executor.execute(new PrintChar(&#x27;b&#x27;, 100));</span><br><span class="line">	executor.execute(new PrintNum(100));</span><br><span class="line">	</span><br><span class="line">	  while (!executor.isTerminated()) ;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h3><p> 在<code>实例</code>方法的情况下，锁位于调用该方法的<code>对象</code>上。 </p>
<p> 在<code>静态</code>方法的情况下，锁在<code>类</code>上。</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>与同步方法不同，同步语句必须指定提供内在锁的对象</p>
<p>有时你不需要同步整个方法，而是同步方法中的一部分。Java 可以对方法的一部分进行同步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(this) &#123; </span><br><span class="line">        lastName = name; </span><br><span class="line">        nameCount++; </span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<h3 id="锁Lock和实例ReentrantLock"><a href="#锁Lock和实例ReentrantLock" class="headerlink" title="锁Lock和实例ReentrantLock"></a>锁Lock和实例ReentrantLock</h3><p><img src="https://tu.yegetables.com/images/2021/10/14/20211014162344.png" alt="image-20211014162344526"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> 	 &#123;       					 	  &#125;</span><br><span class="line"><span class="keyword">finally</span>  &#123;     lock.unlock();  		      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="条件变量Condition-lock-newCondition"><a href="#条件变量Condition-lock-newCondition" class="headerlink" title="条件变量Condition (lock.newCondition)"></a>条件变量Condition (lock.newCondition)</h3><p><img src="https://tu.yegetables.com/images/2021/10/14/20211014162748.png" alt="image-20211014162748069"></p>
<p><img src="https://tu.yegetables.com/images/2021/10/14/20211014163041.png" alt="image-20211014163041482"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">	lock.lock(); </span><br><span class="line">		<span class="keyword">while</span> (queue.size() == CAPACITY) notFull.await();</span><br><span class="line">	<span class="comment">//do</span></span><br><span class="line">	notEmpty.signal(); </span><br><span class="line">    lock.unlock(); </span><br><span class="line"></span><br><span class="line">	lock.lock(); </span><br><span class="line">	<span class="keyword">while</span> (queue.isEmpty()) notEmpty.await();</span><br><span class="line">	<span class="comment">//do</span></span><br><span class="line">	notFull.signal();</span><br><span class="line">	lock.unlock(); </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait notify notifyAll"></a>wait notify notifyAll</h3><p>wait() 、 notify() 和 notifyAll() 方法必须在这些方法的接收对象上的同步方法或同步块中调用。 否则，将发生 IllegalMonitorStateException。</p>
<ul>
<li>必须 先获得对象的锁 ,在 用 wait 使当前线程沉睡 ,等待别的线程 用 notify通知当前线程 </li>
<li>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。</li>
<li>只有当 notify&#x2F;notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.lock 锁住某个对象  只有调用 Object.notify 唤醒才行</span><br><span class="line"></span><br><span class="line">//仓库存储的载体</span><br><span class="line">11     private LinkedList list = new LinkedList();</span><br><span class="line">12 </span><br><span class="line">13     //生产产品</span><br><span class="line">14     public void produce(int num)&#123;</span><br><span class="line">15         //同步</span><br><span class="line">16         synchronized (list)&#123;</span><br><span class="line">17             //仓库剩余的容量不足以存放即将要生产的数量，暂停生产</span><br><span class="line">18             while(list.size()+num &gt; MAX_SIZE)&#123;</span><br><span class="line">19                 System.out.println(&quot;【要生产的产品数量】:&quot; + num + &quot;\t【库存量】:&quot;</span><br><span class="line">20                         + list.size() + &quot;\t暂时不能执行生产任务!&quot;);</span><br><span class="line">21 </span><br><span class="line">22                 try &#123;</span><br><span class="line">23                     //条件不满足，生产阻塞</span><br><span class="line">24                     list.wait();</span><br><span class="line">25                 &#125; catch (InterruptedException e) &#123;</span><br><span class="line">26                     e.printStackTrace();</span><br><span class="line">27                 &#125;</span><br><span class="line">28             &#125;</span><br><span class="line">29 </span><br><span class="line">30             for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">31                 list.add(new Object());</span><br><span class="line">32             &#125;</span><br><span class="line">33 </span><br><span class="line">34             System.out.println(&quot;【已经生产产品数】:&quot; + num + &quot;\t【现仓储量为】:&quot; + list.size());</span><br><span class="line">35 </span><br><span class="line">36             list.notifyAll();</span><br><span class="line">37         &#125;</span><br><span class="line">38     &#125;</span><br><span class="line">39 </span><br><span class="line">40     //消费产品</span><br><span class="line">41     public void consume(int num)&#123;</span><br><span class="line">42         synchronized (list)&#123;</span><br><span class="line">43 </span><br><span class="line">44             //不满足消费条件</span><br><span class="line">45             while(num &gt; list.size())&#123;</span><br><span class="line">46                 System.out.println(&quot;【要消费的产品数量】:&quot; + num + &quot;\t【库存量】:&quot;</span><br><span class="line">47                         + list.size() + &quot;\t暂时不能执行生产任务!&quot;);</span><br><span class="line">48 </span><br><span class="line">49                 try &#123;</span><br><span class="line">50                     list.wait();</span><br><span class="line">51                 &#125; catch (InterruptedException e) &#123;</span><br><span class="line">52                     e.printStackTrace();</span><br><span class="line">53                 &#125;</span><br><span class="line">54             &#125;</span><br><span class="line">55 </span><br><span class="line">56             //消费条件满足，开始消费</span><br><span class="line">57             for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">58                 list.remove();</span><br><span class="line">59             &#125;</span><br><span class="line">60 </span><br><span class="line">61             System.out.println(&quot;【已经消费产品数】:&quot; + num + &quot;\t【现仓储量为】:&quot; + list.size());</span><br><span class="line">62 </span><br><span class="line">63             list.notifyAll();</span><br><span class="line">64         &#125;</span><br><span class="line">65     &#125;</span><br><span class="line">66 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h3><p><img src="https://tu.yegetables.com/images/2021/10/14/20211014164615.png" alt="image-20211014164615031"></p>
<p><img src="https://tu.yegetables.com/images/2021/10/14/20211014164627.png" alt="image-20211014164627707"></p>
<p>ArrayBlockingQueue 构造方法指定 队列大小      put   时如果 队列满 则等待  </p>
<p>ArrayBlockingQueue 和 LinkedBlockingQueue 和 PriorityBlockingQueue 在  take  时等待 队列不为空</p>
<h3 id="信号量-Semaphores"><a href="#信号量-Semaphores" class="headerlink" title="信号量 Semaphores"></a>信号量 Semaphores</h3><p>指定 同时 在上面 的线程数量   +-1</p>
<p><img src="https://tu.yegetables.com/images/2021/10/14/20211014165042.png" alt="image-20211014165042389"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> 	 &#123;       semaphore.acquire(); 	  &#125;</span><br><span class="line"><span class="keyword">finally</span>  &#123;       semaphore.release();     &#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>New, </p>
<p>Ready,		   (    start  之后  等待 操作系统分配时间   )  </p>
<p>Running,   	(   开始执行时，它进入运行状态    )    (  调用 yield  回到 ready   )</p>
<p>Blocked,       (   wait   join  sleep 	)</p>
<p>Finished        </p>
<p>isAlive()    —–&gt;  Ready&#x2F;Running&#x2F;Blocked    —-true</p>
<p> interrupt()——–&gt;    就绪或运行—&gt;中断标志       </p>
<p>​							当前被阻塞，它被唤醒并进入就绪状态，并抛出一个 java.lang.InterruptedException。</p>
<p><img src="https://tu.yegetables.com/images/2021/10/14/20211014172109.png" alt="image-20211014172109583"></p>
<h2 id="Collections同步集合-list-set-map"><a href="#Collections同步集合-list-set-map" class="headerlink" title="Collections同步集合  (  list,  set,    map )"></a>Collections同步集合  (  list,  set,    map )</h2><p>Collections 类提供了六个静态方法，用于将集合包装到同步版本中，</p>
<p><img src="https://tu.yegetables.com/images/2021/10/14/20211014173139.png" alt="image-20211014173139924"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原理类似于</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E o)</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> c.add(o);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步包装类是线程安全的，但迭代器是失败的。</strong></p>
<p>要遍历一个集合，你必须这样写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">hashSet</span> <span class="operator">=</span> Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (hashSet) &#123; </span><br><span class="line">	<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> hashSet.iterator();</span><br><span class="line">	<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">		System.out.println(iterator.next());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="并行处理-Fork-x2F-Join-框架"><a href="#并行处理-Fork-x2F-Join-框架" class="headerlink" title="并行处理  Fork&#x2F;Join 框架"></a>并行处理  Fork&#x2F;Join 框架</h2><p> 并行处理是使用 Fork&#x2F;Join 框架实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分治</span><br><span class="line">if (the program is small)</span><br><span class="line">solve it sequentially;</span><br><span class="line">else &#123;</span><br><span class="line">divide the problem into nonoverlapping subproblems;</span><br><span class="line">solve the subproblems concurrently;</span><br><span class="line">combine the results from subproblems to solve the whole problem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://tu.yegetables.com/images/2021/10/14/20211014190440.png" alt="image-20211014190439886"></p>
<p>ForkJoinTask 的两个子类  RecursiveAction 和 RecursiveTask </p>
<p>要定义具体的任务类，您的类应该扩展 RecursiveAction  或 RecursiveTask 。 </p>
<p><code>RecursiveAction</code> 用于<code>不返回</code>值的任务  	invokeAll()   </p>
<p><code>RecursiveTask</code> 用于确实<code>返回</code>值的任务。  fork()    join()</p>
<p> 你的任务类应该覆盖  <code>compute()</code> 方法来指定如何执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组进行排序的 Arrays.sort 和 Arrays.parallelSort 方法 </span></span><br><span class="line"><span class="comment">//parallelSort 方法利用多个处理器来减少排序时间。 </span></span><br><span class="line"><span class="comment">//并行流，用于并行执行流操作以加快使用多个处理器的处理速度。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1 . 任务类 继承  RecursiveAction     重写 compute()</span></span><br><span class="line">	<span class="comment">//2. 创建 fork/join实例 </span></span><br><span class="line">	<span class="comment">//3. 调用 实例的invoke 执行 任务     </span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">RecursiveAction</span> <span class="variable">mainTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortTask</span>(list);	</span><br><span class="line">	<span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">	pool.invoke(mainTask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SortTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span>   &#123;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="comment">//11   递归调用不返回 </span></span><br><span class="line"><span class="comment">//	invokeAll(new SortTask(firstHalf), new SortTask(secondHalf));</span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"> 			<span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        	<span class="comment">//递归调用  左右 两半(允许 可变参数  并行计算)</span></span><br><span class="line">        	<span class="comment">//在执行主任务时，将任务拆分为子任务，并调用子任务  </span></span><br><span class="line">        	<span class="comment">//使用 invokeAll 方法。 invokeAll 方法终究会返回子任务完成。 请注意，每个子任务会进一步递归地拆分为更小的任务。</span></span><br><span class="line">        	<span class="comment">//可以在池中创建和执行大量子任务。 Fork/Join 框架自动高效地执行和协调所有任务。</span></span><br><span class="line">        	invokeAll(<span class="keyword">new</span> <span class="title class_">SortTask</span>(firstHalf), <span class="keyword">new</span> <span class="title class_">SortTask</span>(secondHalf));</span><br><span class="line"></span><br><span class="line">        	<span class="comment">//  合并结果  </span></span><br><span class="line">        	merge(firstHalf, secondHalf, list);</span><br><span class="line">        &#125;</span><br><span class="line">     	</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"><span class="comment">//22    拿返回值</span></span><br><span class="line"><span class="comment">//		new Task1().fork;	new Task2().fork;</span></span><br><span class="line"><span class="comment">//       	Take1().join;         	Take2().join;  </span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     	<span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (high - low &lt; THRESHOLD)   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">                RecursiveTask&lt;Integer&gt; left = <span class="keyword">new</span> <span class="title class_">MaxTask</span>(list, low, mid);<span class="comment">//人物类</span></span><br><span class="line">                RecursiveTask&lt;Integer&gt; right = <span class="keyword">new</span> <span class="title class_">MaxTask</span>(list, mid, high);<span class="comment">//人物类</span></span><br><span class="line"></span><br><span class="line">                right.fork();<span class="comment">//执行</span></span><br><span class="line">                left.fork();<span class="comment">//执行</span></span><br><span class="line">                <span class="keyword">return</span> Math.max(left.join(), right.join());<span class="comment">//拿返回值 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     	</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>java</tag>
        <tag>同步</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>提问1    TreeNode 与 BSTreeNode 的继承 关系 使用</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-09-29-%E6%8F%90%E9%97%AE1____TreeNode_%E4%B8%8E_BSTreeNode_%E7%9A%84%E7%BB%A7%E6%89%BF_%E5%85%B3%E7%B3%BB_%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>提问1.   </p>
<p><img src="https://tu.yegetables.com/images/2021/09/29/20210929133246.png" alt="image-20210929133239757"></p>
<p>我想要BSTreeNode 继承于 TreeNode    例如下</p>
<p><img src="https://tu.yegetables.com/images/2021/09/29/20210929133520.png" alt="image-20210929133520513"></p>
<p>但是 在 BSTree 中  无法获得 BSTreeNode  的 <code>left </code>和 <code>right</code>(他们是 TreeNode 类型 而不是 BSTreeNode 类型)</p>
<p><img src="https://tu.yegetables.com/images/2021/09/29/20210929134214.png" alt="image-20210929134214372"></p>
<p>有人告诉我怎么 获得  BSTreeNode 类型的 left 和 right 吗</p>
<p>tips: </p>
<ol>
<li>强制类型转换  可能不是个好办法 ,BSTree 后续拓展 中可能遇见 很多的 left 和 right </li>
<li>BSTreeNode 中 组合 一个 TreeNode 变量 也不是很好,那样做 访问 BSTreeNode 的节点时 需要先访问 TreeNode 变量 再 访问 left 变量 也需要 做 类型转换</li>
<li>定义一个 与 TreeNode 无关的 BSTreeNode 类 也不好 ,我需要 体现 它 与TreeNode 的关系</li>
</ol>
<p>有人 能告诉我答案吗 ?非常感谢</p>
<p>​		</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>转换</tag>
        <tag>treenode</tag>
        <tag>bstreenode</tag>
        <tag>left</tag>
        <tag>变量</tag>
        <tag>类型</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Junit5 技巧</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-09-28-%E5%B8%B8%E7%94%A8junit5_%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>测试按测试函数<code>字典序</code>进行</p>
<h2 id="测试方法名字"><a href="#测试方法名字" class="headerlink" title="测试方法名字"></a>测试方法名字</h2><p>(可以给类前面的加,也可以给测试方法前面加)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@DisplayName(&quot;My 1st JUnit 5 test! &quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;我的第一個測試&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testFirstTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的第一個測試開始測試&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;我的第二個測試&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSecondTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的第二個測試開始測試&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/09/28/image-20210928190250679ed10b33d0f4ce35b.png"></p>
<h3 id="2-before-and-after"><a href="#2-before-and-after" class="headerlink" title="2. before and after"></a>2. before and after</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@BeforeAll</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;初始化資料&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterAll</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;清理資料&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearup</span><span class="params">()</span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;當前測試方法開始&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterEach</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">     		System.out.println(<span class="string">&quot;當前測試方法結束&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">  	<span class="keyword">void</span> <span class="title function_">testFirstTest</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;我的第一個測試開始測試&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testSecondTest</span><span class="params">()</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;我的第二個測試開始測試&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/09/28/image-20210928190347923.png"></p>
<h3 id="3-测试失败提示"><a href="#3-测试失败提示" class="headerlink" title="3. 测试失败提示"></a>3. 测试失败提示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="number">2</span>,calculator.add(<span class="number">1</span>,<span class="number">1</span>),<span class="string">&quot;1 + 1 should equal 2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/08/12/image-20210812194613083826effcfb8783a87.png"></p>
<h3 id="4-取消测试"><a href="#4-取消测试" class="headerlink" title="4. 取消测试"></a>4. 取消测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span> </span><br><span class="line"><span class="meta">@Disabled</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/09/28/image-20210812195521031.png">.</p>
<h3 id="5-测试类树状嵌套-只给class-使用"><a href="#5-测试类树状嵌套-只给class-使用" class="headerlink" title="5. 测试类树状嵌套(只给class 使用)"></a>5. 测试类树状嵌套(只给class 使用)</h3><p>JUnit 5提供了 @Nested注解，能够以静态内部成员类的形式对测试用例类进行逻辑分组。并且每个静态内部类都可以有自己的生命周期方法， 这些方法将按从外到内层次顺序执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@DisplayName(&quot;first&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestingAStackDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;1&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">isInstantiatedWithNew</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;Second&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WhenNew</span> &#123;</span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;2&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;3&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/09/28/image-20210928192148660.png"></p>
<h3 id="6-重复测试"><a href="#6-重复测试" class="headerlink" title="6. 重复测试"></a>6. 重复测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RepeatedTest(value = 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@DisplayName(&quot;自定义名称重复测试&quot;)</span> </span><br><span class="line"><span class="meta">@RepeatedTest(value = 3, name = &quot;&#123;displayName&#125; 第 &#123;currentRepetition&#125; 次&quot;)</span></span><br></pre></td></tr></table></figure>

<p>​    <img src="https://tu.yegetables.com/images/2021/09/28/image-20210928192735791.png"></p>
<p>@RepeatedTest 注解内用</p>
<p><code>currentRepetition</code> 变量表示已经重复的次数，</p>
<p><code>totalRepetitions</code> 变量表示总共要重复的次数，</p>
<p><code>displayName</code> 变量表示测试方法显示名称，</p>
<p>我们直接就可以使用这些内置的变量来重新定义测试方法重复运行时的名称。</p>
<h3 id="7-断言"><a href="#7-断言" class="headerlink" title="7.断言"></a>7.断言</h3><p>断言有助于通过测试用例的实际输出来验证期望的输出。 为简单起见，所有 JUnit Jupiter<br>断言都是<a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assertions.html"><code>org.junit.jupiter.Assertions</code></a>类中的静态方法，例如<code>assertEquals()</code>，<code>assertNotEquals()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">assertEquals 断言预期值和实际值相等</span><br><span class="line">assertAll 分组断言,执行其中包含的所有断言</span><br><span class="line">assertArrayEquals 断言预期数组和实际数组相等</span><br><span class="line">assertFalse 断言条件为假</span><br><span class="line">assertNotNull 断言不为空</span><br><span class="line">assertSame 断言两个对象相等</span><br><span class="line">assertTimeout 断言超时</span><br><span class="line">fail 使单元测试失败</span><br></pre></td></tr></table></figure>

<h3 id="8-假设"><a href="#8-假设" class="headerlink" title="8.假设"></a>8.假设</h3><p><a href="http://junit.org/junit5/docs/current/api/org/junit/jupiter/api/Assumptions.html"><code>Assumptions</code></a>类提供静态方法来支持基于假设的条件测试执行。<br>假设失败会导致测试中止。 通常在没有必要继续执行给定测试方法的情况下使用假设。</p>
<p>假设失败 当前测试被忽略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOnProd</span><span class="params">()</span>&#123;</span><br><span class="line">     Assumptions.assumeFalse(<span class="number">1</span>+<span class="number">1</span>==<span class="number">2</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;okkkk&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/09/28/20210928194900.png" alt="image-20210928194852962"></p>
<h4 id="假设与断言"><a href="#假设与断言" class="headerlink" title="假设与断言:"></a>假设与断言:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设仅在假设为真时才会运行。如果为假，将被跳过。</span><br><span class="line"></span><br><span class="line">在断言为假的情况下，它会提供预定义的错误消息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一个测试失败时，Asserts和Assumes都会停止，然后继续进行下一个测试。区别在于，失败的Assert将失败记录为失败的测试，而Assume仅移至下一个测试。</span><br><span class="line"></span><br><span class="line">简而言之，假设用于禁用测试</span><br></pre></td></tr></table></figure>

<h3 id="9-参数化测试"><a href="#9-参数化测试" class="headerlink" title="9.参数化测试"></a>9.参数化测试</h3><p>@ParameterizedTest 表示方法是参数化测试</p>
<h4 id="ValueSource"><a href="#ValueSource" class="headerlink" title="@ValueSource"></a>@ValueSource</h4><p>它可以让你指定一个原生类型（String，int，long或double）的数组，并且只能为每次调用提供一个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span> </span><br><span class="line"><span class="meta">@ValueSource(ints = &#123;1, 2, 3&#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testWithValueSource</span><span class="params">(<span class="type">int</span> argument)</span>&#123;</span><br><span class="line">        assertNotNull(argument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/09/28/20210928200023.png" alt="image-20210928200023488"></p>
<p>默认测试数组所有值</p>
<h4 id="CsvSource"><a href="#CsvSource" class="headerlink" title="@CsvSource"></a>@CsvSource</h4><p>@CsvSource允许您将参数列表表示为以逗号分隔的值（例如，字符串文字）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span> </span><br><span class="line"><span class="meta">@CsvSource(&#123;&quot;foo, 1&quot;, &quot;bar, 2&quot;, &quot;&#x27;baz, qux&#x27;, 3&quot;&#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testWithCsvSource</span><span class="params">(String first,<span class="type">int</span> second)</span>&#123;</span><br><span class="line">        assertNotNull(first);</span><br><span class="line">        assertNotEquals(<span class="number">0</span>,second);</span><br><span class="line">        System.out.println(first+<span class="string">&quot; &quot;</span>+second);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/09/28/20210928201142.png" alt="image-20210928201142177"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>junit5</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb之Servlet与Http请求响应</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-08-14-javaweb%E4%B9%8BServlet%E4%B8%8EHttp%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="动态web工程介绍"><a href="#动态web工程介绍" class="headerlink" title="动态web工程介绍"></a>动态web工程介绍</h2><p><img src="https://tu.yegetables.com/images/2021/08/10/20210810170629.png" alt="image-20210810170629200"></p>
<p>更多内容详见<a href="https://www.zhihu.com/question/32212996/answer/87524617">tomcat 与 nginx，apache的区别是什么？ - David的回答 - 知乎</a></p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>一个接口</p>
<h2 id="触发顺序"><a href="#触发顺序" class="headerlink" title="触发顺序"></a>触发顺序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 构造器 第一次触发 </span><br><span class="line">2. init 第一次时触发 </span><br><span class="line">3. service 重复调用 </span><br><span class="line">4. destroy 停止时触发</span><br></pre></td></tr></table></figure>

<h2 id="部署目录"><a href="#部署目录" class="headerlink" title="部署目录"></a>部署目录</h2><ol>
<li>注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name = &quot;NewServlet&quot;, value = &quot;/ser&quot;)</span></span><br></pre></td></tr></table></figure>

<p>类名NewServlet 部署到工程目录下的的&#x2F;ser目录下(localhost:8080&#x2F;myTomcat&#x2F;ser)</p>
<ol start="2">
<li>改web.xml(Tomcat 10 及以上失效)</li>
</ol>
<h2 id="区分get-x2F-post请求"><a href="#区分get-x2F-post请求" class="headerlink" title="区分get&#x2F;post请求"></a>区分get&#x2F;post请求</h2><ol>
<li>父类强转子类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类强转子类,使用getmethod方法</span></span><br><span class="line"></span><br><span class="line">HttpServletRequest httpServletRequest=(HttpServletRequest)servletRequest;</span><br><span class="line">        <span class="keyword">if</span>(httpServletRequest.getMethod().equals(<span class="string">&quot;POST&quot;</span>))&#123;</span><br><span class="line">        doPOST();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        doGET();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义方法继承自(原来的)子类<ol>
<li>自定义类继承HttpServlet类</li>
<li>重写doGet&#x2F;doPost</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类关系Servlet"><a href="#类关系Servlet" class="headerlink" title="类关系Servlet"></a>类关系Servlet</h2><p><img src="https://tu.yegetables.com/images/2021/08/13/20210813221005.png"></p>
<h2 id="servletConfig"><a href="#servletConfig" class="headerlink" title="servletConfig"></a>servletConfig</h2><p>作用</p>
<ol>
<li>获取Servlet程序别名servlet-name</li>
<li>获取初始化参数init-param</li>
<li>获取ServletContext对象</li>
</ol>
<p>使用Servlet 的程序和 ServletConfig 是启动时tomcat帮忙创建,我们只需要使用</p>
<p>Servlet 是启动时创建 ServletConfig 是每个servlet程序创建时创建一个</p>
<ol>
<li>init时使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">servletConfig.getServleName();    <span class="comment">//程序别名</span></span><br><span class="line">servletConfig.getInitParameter(<span class="string">&quot;key&quot;</span>);    <span class="comment">//初始化key的值</span></span><br><span class="line">servletConfig.getServletContext();    <span class="comment">//获取servletContext对象</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>service中使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//init</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">super</span>.init(config);        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//service</span></span><br><span class="line">&#123;</span><br><span class="line">	ServletConfig servletConfig=getServletConfig();</span><br><span class="line">    servletConfig.getInitParameter(<span class="string">&quot;key&quot;</span>);    <span class="comment">//初始化key的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Config-Context"><a href="#Config-Context" class="headerlink" title="Config.Context"></a>Config.Context</h2><p><img src="https://tu.yegetables.com/images/2021/08/14/20210814091451.png"></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>获取web.xml的上下文参数context-param(任意key-value)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletConfig().getServletContext();</span><br><span class="line">context.getInitParameter(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>
2.获取工程路径</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getContextPath();</span><br><span class="line"><span class="comment">//    /myTomcat</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取工程部署后在磁盘上的绝对路径</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        System.out.println(context.getRealPath(<span class="string">&quot;/&quot;</span>));</span><br><span class="line"><span class="comment">//   D:\Ajian\javatest\myTomcat\target\myTomcat-1.0-SNAPSHOT\</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>像map存数据 (用于不同servlet共享数据&#x2F;停止数据会销毁)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setAttribute  getAttribute removeAttribute</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="HTTP协议-请求"><a href="#HTTP协议-请求" class="headerlink" title="HTTP协议-请求"></a>HTTP协议-请求</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><h3 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a>常见形式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. a标签</span><br><span class="line">2. form中的method=get</span><br><span class="line">3. link引入css</span><br><span class="line">4. Script引入js文件</span><br><span class="line">5. image引入图片</span><br><span class="line">6. iframe引入html页面</span><br><span class="line">7. 浏览器输地址后回车</span><br></pre></td></tr></table></figure>
<p><img src="https://tu.yegetables.com/images/2021/08/14/20210814163138.png" alt="img.png"></p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 请求方式                  GET</span><br><span class="line">2. 请求资源路径[+?+请求参数]   /myTomcat/index.html</span><br><span class="line">3. 请求协议版本号             HTTP/1.1</span><br></pre></td></tr></table></figure>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Accept:              客户端可以接受的数据类型</span><br><span class="line">2. Accept-Language:     zh_CN/en_US</span><br><span class="line">3. User-Agent:          浏览器信息</span><br><span class="line">4. Accept-Encoding:     可以接受的数据编码 (压缩)格式</span><br><span class="line">5. Host:                请求的服务器ip:端口</span><br><span class="line">6. Connection:          Keep-Alive/Closed     回传数据后 告诉服务器的行为</span><br></pre></td></tr></table></figure>




<h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><h3 id="常见形式-1"><a href="#常见形式-1" class="headerlink" title="常见形式"></a>常见形式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">form中的method=get</span><br></pre></td></tr></table></figure>
<h3 id="请求行-1"><a href="#请求行-1" class="headerlink" title="请求行"></a>请求行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 请求方式                              POST</span><br><span class="line">2. 请求资源路径[+?+请求参数]               /myTomcat/index.html</span><br><span class="line">3. 请求协议版本号                         HTTP/1.1</span><br></pre></td></tr></table></figure>
<h3 id="请求头-1"><a href="#请求头-1" class="headerlink" title="请求头"></a>请求头</h3><p>大部分与 GET相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Accept:              客户端可以接受的数据类型</span><br><span class="line">2. Accept-Language:     zh_CN/en_US</span><br><span class="line">3. User-Agent:          浏览器信息</span><br><span class="line">4. Accept-Encoding:     可以接受的数据编码 (压缩)格式</span><br><span class="line">5. Host:                请求的服务器ip:端口</span><br><span class="line">6. Connection:          Keep-Alive/Closed     回传数据后 告诉服务器的行为</span><br></pre></td></tr></table></figure>
<p>特别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7. Referer:              请求发起时浏览器地址(请求的来源)</span><br><span class="line">8. Content-Type:         multipart/form-data                 以多段的方式提交数据(流的方式,用于上传)</span><br><span class="line">                         application/x-www-form-urlencoded   提交方式是 name=value&amp;name=value,然后进行url编码(非英文转为%xx%xx)</span><br><span class="line">9. Content-Length:       请求体长度</span><br><span class="line">10.Catch-Control:        no-cache不缓存                                     控制缓存  </span><br></pre></td></tr></table></figure>
<p><img src="https://tu.yegetables.com/images/2021/08/14/20210814170427.png" alt="img_1.png"></p>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">key1=value1&amp;key2=value2</span><br></pre></td></tr></table></figure>

<h1 id="HTTP协议-响应"><a href="#HTTP协议-响应" class="headerlink" title="HTTP协议-响应"></a>HTTP协议-响应</h1><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 响应协议和版本号                         HTTP/1.1</span><br><span class="line">2. 响应状态码                              200  </span><br><span class="line">3. 响应状态描述符                           OK</span><br></pre></td></tr></table></figure>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Server:							服务器信息(如Apache-Coyote/1.1)</span><br><span class="line">2. Content-Type:                    响应体的数据类型(如text/html   application/json)MIME类型</span><br><span class="line">3. Content-Length:					长度</span><br><span class="line">4. Date:							请求响应的时间(格林时间)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h3><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>(例如  整个html页面)</p>
<p><img src="https://tu.yegetables.com/images/2021/08/14/20210814171839.png" alt="image-20210814171839089"></p>
<h2 id="常见响应状态"><a href="#常见响应状态" class="headerlink" title="常见响应状态"></a>常见响应状态</h2><p>200 ok<br>404 请求收到 但是请求数据not found<br>302 重定向<br>500 请求收到 但是内部错误</p>
<h1 id="HTTP中的数据类型"><a href="#HTTP中的数据类型" class="headerlink" title="HTTP中的数据类型"></a>HTTP中的数据类型</h1><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><p><img src="https://tu.yegetables.com/images/2021/08/14/20210814173112.png" alt="image-20210814173112102"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>servlet</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中jdbc操作流程</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-07-31-java%E4%B8%ADjdbc%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h1><p>通过使用JDBC，Java程序可以非常方便地操作各种主流数据库<br><img src="https://tu.yegetables.com/images/2021/07/31/20210731151541.jpg" alt="jdbc访问"></p>
<p>在数据库发展历史中，按时间顺序主要出现了如下几种类型的数据库系统。<br>➢ 网状型数据库<br>➢ 层次型数据库<br>➢ 关系数据库<br>➢ 面向对象数据库<br>对于关系数据库而言，最基本的数据存储单元就是数据表，因此可以简单地把数据库想象成大量数据表的集合（当然，数据库绝不仅由数据表组成）。</p>
<p>Create    Insert      Update       Delete&#x2F;drop<br>CIUD</p>
<p>标准的SQL语句通常可分为如下几种类型。<br>➢ 查询语句：主要由select关键字完成，查询语句是SQL语句中最复杂、功能最丰富的语句。<br>➢ DML（Data Manipulation Language，数据操作语言）语句：主要由insert、update和delete三个关键字完成。<br>➢ DDL（Data Definition Language，数据定义语言）语句：主要由create、alter、drop和truncate四个关键字完成。<br>➢ DCL（Data Control Language，数据控制语言）语句：主要由grant和revoke两个关键字完成。<br>➢ 事务控制语句：主要由commit、rollback和savepoint三个关键字完成。<br><img src="https://tu.yegetables.com/images/2021/07/31/20210731151545.jpg" alt="数据库对象"></p>
<p>DCL语句用于为数据库用户授权，或者回收指定用户的权限，通常无须程序员操作</p>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h2><p>略</p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol>
<li>通过DriverManager获取数据库连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">cn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mariadb://localhost:3306/test?user=ajian&amp;password=123456&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过Connection对象创建Statement对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">sd</span> <span class="operator">=</span> cn.createStatement();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用Statement执行SQL语句。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   executeUpdate()：主要用于执行DML和DDL语句。执行DML语句返回受SQL语句影响的行数，执行DDL语句返回0。</span></span><br><span class="line"><span class="comment">//   executeQuery()：只能执行查询语句，执行后返回代表查询结果的ResultSet对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DDL   create /drop   /alter     成功0        </span></span><br><span class="line"><span class="comment">//DML   inster /update /delete    受影响行数</span></span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> sd.executeUpdate(<span class="string">&quot;insert into user(user_name, user_passwd,user_email,user_status) values (\&quot;safaffa\&quot;,\&quot;assss\&quot;,\&quot;ajian@email.com\&quot;,0 )&quot;</span>);<span class="comment">//ddl</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<ol start="4">
<li>操作结果集 如果执行的SQL语句是查询语句，则执行结果将返回一个ResultSet对象，该对象里保存了SQL语句查询的结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ResultSet对象主要提供了如下两类方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// next()、previous()、first()、last()、beforeFirst()、afterLast()、absolute()等移动记录指针的方法。返回boolean值确定是否有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getXxx()方法获取记录指针指向行、特定列的值。该方法既可使用列索引作为参数，也可使用列名作为参数。使用列索引作为参数性能更好，使用列名作为参数可读性更好。</span></span><br><span class="line">        </span><br><span class="line"><span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> sd.executeQuery(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">            System.out.println(res.getInt(<span class="number">1</span>) + <span class="string">&quot;  &quot;</span> + res.getString(<span class="number">2</span>) + <span class="string">&quot;  &quot;</span> + res.getString(<span class="number">3</span>) + <span class="string">&quot;  &quot;</span> + res.getString(<span class="number">4</span>));</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//显示结果</span></span><br><span class="line"><span class="comment">//10001  asd  asd  456@email.com</span></span><br><span class="line"><span class="comment">//10002  99  922  aw</span></span><br><span class="line"><span class="comment">//10003  129  922  aw</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>回收数据库资源，包括关闭ResultSet、Statement和Connection等资源。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res.close();<span class="comment">//关闭ResultSet</span></span><br><span class="line">sd.close();<span class="comment">//关闭Statement</span></span><br><span class="line">cn.close();<span class="comment">//关闭Connection</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>附操作源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectTest</span> &#123;</span><br><span class="line"><span class="comment">//    static Driver driver = new Driver();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过DriverManager获取数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">cn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mariadb://localhost:3306/test?user=ajian&amp;password=123456&quot;</span>);</span><br><span class="line">        System.out.println(cn.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过Connection对象创建Statement对象</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">sd</span> <span class="operator">=</span> cn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Statement执行SQL语句。</span></span><br><span class="line">        <span class="comment">//   executeUpdate()：主要用于执行DML和DDL语句。执行DML语句返回受SQL语句影响的行数，执行DDL语句返回0。</span></span><br><span class="line">        <span class="comment">//   executeQuery()：只能执行查询语句，执行后返回代表查询结果的ResultSet对象。</span></span><br><span class="line">        <span class="comment">//DML   inster /update /delete    受影响行数</span></span><br><span class="line">        <span class="comment">//DDL   create /drop   /alter     成功0</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> sd.executeUpdate(<span class="string">&quot;insert into user(user_name, user_passwd,user_email,user_status) values (\&quot;safaffa\&quot;,\&quot;assss\&quot;,\&quot;ajian@email.com\&quot;,0 )&quot;</span>);</span><br><span class="line">        System.out.println(result);<span class="comment">//返回1  受影响行数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作结果集 如果执行的SQL语句是查询语句，则执行结果将返回一个ResultSet对象，该对象里保存了SQL语句查询的结果。</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> sd.executeQuery(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line">        <span class="comment">//ResultSet对象主要提供了如下两类方法。</span></span><br><span class="line">        <span class="comment">//➢ next()、previous()、first()、last()、beforeFirst()、afterLast()、absolute()等移动记录指针的方法。</span></span><br><span class="line">        <span class="comment">//➢ getXxx()方法获取记录指针指向行、特定列的值。该方法既可使用列索引作为参数，也可使用列名作为参数。使用列索引作为参数性能更好，使用列名作为参数可读性更好。</span></span><br><span class="line">        <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">            System.out.println(res.getInt(<span class="number">1</span>) + <span class="string">&quot;  &quot;</span> + res.getString(<span class="number">2</span>) + <span class="string">&quot;  &quot;</span> + res.getString(<span class="number">3</span>) + <span class="string">&quot;  &quot;</span> + res.getString(<span class="number">4</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                ⑥ 回收数据库资源，包括关闭ResultSet、Statement和Connection等资源。</span></span><br><span class="line">        res.close();</span><br><span class="line">        sd.close();</span><br><span class="line">        cn.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>C对mysql(及mariadb)操作的api总览</title>
    <url>/%E7%BC%96%E7%A8%8B/c%E5%AF%B9mysql(%E5%8F%8Amariadb)%E6%93%8D%E4%BD%9C%E7%9A%84api%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h1 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1.头文件"></a>1.头文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;mysql/mysql.h&gt;</span><br></pre></td></tr></table></figure>

<h1 id="2-gcc链接库文件"><a href="#2-gcc链接库文件" class="headerlink" title="2.gcc链接库文件"></a>2.gcc链接库文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc a.c -lmysqlclient</span><br></pre></td></tr></table></figure>
<h1 id="3-api汇总"><a href="#3-api汇总" class="headerlink" title="3.api汇总"></a>3.api汇总</h1><h2 id="第一部分-控制类函数"><a href="#第一部分-控制类函数" class="headerlink" title="第一部分   控制类函数"></a>第一部分   控制类函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql_init()初始化MySQL对象</span><br><span class="line"></span><br><span class="line">mysql_options()设置连接选项    </span><br><span class="line">//字符集的转换. 要注意, 当汉字写到mysql时设这个选项 就好了,unsinged int  ret = mysql_options(myData, MYSQL_SET_CHARSET_NAME, &quot;gb2312&quot;);  不要设就会写进去乱码.</span><br><span class="line"></span><br><span class="line">mysql_real_connect()连接到MySQL数据库</span><br><span class="line"></span><br><span class="line">mysql_real_escape_string()将查询串合法化</span><br><span class="line"></span><br><span class="line">mysql_query()发出一个以空字符结束的查询串</span><br><span class="line"></span><br><span class="line">mysql_real_query()发出一个查询串</span><br><span class="line"></span><br><span class="line">mysql_store_result()一次性传送结果</span><br><span class="line"></span><br><span class="line">mysql_use_result()逐行传送结果</span><br><span class="line"></span><br><span class="line">mysql_free_result()释放结果集</span><br><span class="line"></span><br><span class="line">mysql_change_user()改变用户</span><br><span class="line"></span><br><span class="line">mysql_select_db()改变默认数据库</span><br><span class="line"></span><br><span class="line">mysql_debug()送出调试信息</span><br><span class="line"></span><br><span class="line">mysql_dump_debug_info()转储调试信息</span><br><span class="line"></span><br><span class="line">mysql_ping()测试数据库是否处于活动状态</span><br><span class="line"></span><br><span class="line">mysql_shutdown()请求数据库SHUTDOWN</span><br><span class="line"></span><br><span class="line">mysql_close()关闭数据库连接</span><br></pre></td></tr></table></figure>
<h2 id="第二部分-信息获取类函数"><a href="#第二部分-信息获取类函数" class="headerlink" title="第二部分   信息获取类函数"></a>第二部分   信息获取类函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql_character_set_name()获取默认字符集</span><br><span class="line"></span><br><span class="line">mysql_get_client_info()获取客户端信息</span><br><span class="line"></span><br><span class="line">mysql_host_info()获取主机信息</span><br><span class="line"></span><br><span class="line">mysql_get_proto_info()获取协议信息</span><br><span class="line"></span><br><span class="line">mysql_get_server_info()获取服务器信息</span><br><span class="line"></span><br><span class="line">mysql_info()获取部分查询语句的附加信息</span><br><span class="line"></span><br><span class="line">mysql_stat()获取数据库状态</span><br><span class="line"></span><br><span class="line">mysql_list_dbs()获取数据库列表</span><br><span class="line"></span><br><span class="line">mysql_list_tables()获取数据表列表</span><br><span class="line"></span><br><span class="line">mysql_list_fields()获取字段列表</span><br></pre></td></tr></table></figure>
<h2 id="第三部分-行列类操作函数"><a href="#第三部分-行列类操作函数" class="headerlink" title="第三部分   行列类操作函数"></a>第三部分   行列类操作函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql_field_count()获取字段数</span><br><span class="line"></span><br><span class="line">mysql_affected_rows()获取受影响的行数</span><br><span class="line"></span><br><span class="line">mysql_insert_id()获取AUTO_INCREMENT列的ID值</span><br><span class="line"></span><br><span class="line">mysql_num_fields()获取结果集中的字段数</span><br><span class="line"></span><br><span class="line">mysql_field_tell()获取当前字段位置</span><br><span class="line"></span><br><span class="line">mysql_field_seek()定位字段</span><br><span class="line"></span><br><span class="line">mysql_fetch_field()获取当前字段</span><br><span class="line"></span><br><span class="line">mysql_fetch_field_direct()获取指定字段</span><br><span class="line"></span><br><span class="line">mysql_frtch_fields()获取所有字段的数组</span><br><span class="line"></span><br><span class="line">mysql_num_rows()获取行数</span><br><span class="line"></span><br><span class="line">mysql_fetch_lengths()获取行长度</span><br><span class="line"></span><br><span class="line">mysql_row_tell()获取当前行位置</span><br><span class="line"></span><br><span class="line">mysql_row_seek()行定位</span><br><span class="line"></span><br><span class="line">mysql_data_seek()行定位</span><br><span class="line"></span><br><span class="line">mysql_fetch_row()获取当前行</span><br></pre></td></tr></table></figure>
<h2 id="第四部分-线程类操作函数"><a href="#第四部分-线程类操作函数" class="headerlink" title="第四部分   线程类操作函数"></a>第四部分   线程类操作函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">mysql_list_processes()返回所有线程列表</span><br><span class="line"></span><br><span class="line">mysql_thread_id()获取当前线程ID</span><br><span class="line"></span><br><span class="line">mysql_thread_safe()是否支持线程方式</span><br><span class="line"></span><br><span class="line">mysql_kill()杀列一个线程</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="第五部分-出错处理类函数"><a href="#第五部分-出错处理类函数" class="headerlink" title="第五部分   出错处理类函数"></a>第五部分   出错处理类函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql_errno()获取错误号</span><br><span class="line">mysql_error()获取错误信息</span><br></pre></td></tr></table></figure>
<h2 id="第六部分-已过时的函数"><a href="#第六部分-已过时的函数" class="headerlink" title="第六部分   已过时的函数"></a>第六部分   已过时的函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql_connect()     </span><br><span class="line">mysql_create_db()     </span><br><span class="line">mysql_drop_db()     </span><br><span class="line">mysql_eof()    </span><br><span class="line">mysql_reload()    </span><br><span class="line">mysql_escape_string()</span><br></pre></td></tr></table></figure>
<h1 id="4-操作流程"><a href="#4-操作流程" class="headerlink" title="4.操作流程"></a>4.操作流程</h1><p>与MySQL交互时，应用程序应使用该一般性原则：</p>
<ol>
<li><p>通过调用mysql_library_init()，初始化MySQL库。库可以是mysqlclient C客户端库，或mysqld嵌入式服务器库，具体情况取决于应用程序是否与“-libmysqlclient”或“-libmysqld”标志链接。</p>
</li>
<li><p>通过调用mysql_init()初始化连接处理程序，并通过调用mysql_real_connect()连接到服务器。</p>
</li>
<li><p>发出SQL语句并处理其结果。（在下面的讨论中，详细介绍了使用它的方法）。</p>
</li>
<li><p>通过调用mysql_close()，关闭与MySQL服务器的连接。</p>
</li>
<li><p>通过调用mysql_library_end()，结束MySQL库的使用。</p>
</li>
</ol>
<h2 id="1-MYSQL"><a href="#1-MYSQL" class="headerlink" title="1. MYSQL"></a>1. MYSQL</h2><pre><code>   要连接MYSQL，必须建立MYSQL实例，通过mysql_init初始化方能开始进行连接
</code></pre>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MYSQL mysql;       //创建MYSQL实例</span><br><span class="line"></span><br><span class="line">mysql_init(&amp;mysql);//初始化开始进行连接</span><br></pre></td></tr></table></figure>
<h2 id="2-MYSQL-RES"><a href="#2-MYSQL-RES" class="headerlink" title="2. MYSQL_RES"></a>2. MYSQL_RES</h2><p>这个结构代表返回行的一个查询的(SELECT, SHOW, DESCRIBE, EXPLAIN)的结果。返回的数据称为“数据集”。 从数据库读取数据，最后就是从MYSQL_RES中读取数据。</p>
<p>PS：类似于JAVA里面的ResultSet变量一样，将结果集存入到此变量中再从它里面去读数据。</p>
<h2 id="3-MYSQL-ROW"><a href="#3-MYSQL-ROW" class="headerlink" title="3. MYSQL_ROW"></a>3. MYSQL_ROW</h2><p>这是一个行数据的类型安全(type-safe)的表示。当前它实现为一个计数字节的字符串数组。行通过调用mysql_fetch_row()获得</p>
<h2 id="4-MYSQL-FIELD"><a href="#4-MYSQL-FIELD" class="headerlink" title="4. MYSQL_FIELD"></a>4. MYSQL_FIELD</h2><p>你可以通过重复调用mysql_fetch_field()对每一列获得MYSQL_FIELD结构。这个结构包含字段信息，例如字段名、类型和大小。</p>
<p>PS：此变量定义的是列的相关属性问题！</p>
<p>代码示例见<br><a href="https://www.cnblogs.com/jycboy/p/5178751.html">转 用C API 操作MySQL数据库</a></p>
<p>api引自<a href="https://www.git2get.com/av/113892467.html">c++ mysql 取出数据_C++中使用mysql数据库方法</a></p>
]]></content>
      <categories>
        <category>编程</category>
        <category>c</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>将Signalfd加入epoll</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-07-26-%E5%B0%86signalfd%E5%8A%A0%E5%85%A5epoll/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>系统调用被信号打断后， linux 默认不会重启系统调用，当然我们可以设置一些选项来重启一部分系统调用，但并不是所有的系统调用都可以被重启，比如我们经常使用的多路 I&#x2F;O 复用模型 epoll 中的 epoll_wait 就是一个典型例子。</p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><blockquote>
<p>信号可能会对程序的一般流程造成很大的破坏，因为它们本质上是异步的。当您在系统调用中被阻止（导致它们失败）或在执行用户空间指令（可能导致竞争条件）时，它们可能会发生。您可能必须仔细地为您的程序建模以补偿信号的异步性质，这是有经验的 Unix 程序员始终考虑的事情。</p>
</blockquote>
<h2 id="信号注意事项"><a href="#信号注意事项" class="headerlink" title="信号注意事项"></a>信号注意事项</h2><p>以下是一些信号相关注意事项</p>
<blockquote>
<ol>
<li><p>对于体面的程序，您不能取消信号。它们是 Linux 下的现实。</p>
</li>
<li><p>您必须注意从信号处理程序中调用了哪些函数。您调用的函数必须是异步信号安全的。<a href="https://man7.org/linux/man-pages/man7/signal-safety.7.html">signal-safety(7)</a>中列举了信号安全相关的函数</p>
</li>
<li><p>不应该从信号处理程序中调用不可重入函数，因为它们可以从主代码中调用，在执行过程中被中断。如果信号处理程序调用相同的函数，就会出现问题。</p>
</li>
<li><p>当程序被系统调用阻塞时出现信号时，系统调用会返回错误<code>EINTR</code>。但是，可以通过使用<a href="https://man7.org/linux/man-pages/man2/sigaction.2.html">sigaction(2)</a>函数设置信号处理程序时指定<code>SA_RESTART</code>标志  来自动重新启动许多系统调用。</p>
</li>
<li><p>不幸的是，有很多系统调用（如 epoll_wait、epoll_pwait、poll、ppoll、select、pselect、recv、send、和 nanosleep)  尽管<code>SA_RESTART</code>已指定，但永远不会重新启动。</p>
</li>
<li><p>如果在设置信号处理程序和调用<code>pause</code>等待信号发生之间发生信号，则很容易“丢失”或错过信号，从而陷入等待信号的状态。</p>
</li>
</ol>
</blockquote>
<h2 id="不可信号重启的系统调用"><a href="#不可信号重启的系统调用" class="headerlink" title="不可信号重启的系统调用"></a>不可信号重启的系统调用</h2><p>以下接口在被信号打断后永远不会重新启动，无论是否使用 <code>SA_RESTART</code> ，他们总是以错误 <code>EINTR</code> 失败：</p>
<ul>
<li><p>“输入”套接字接口，当已使用 setsockopt 在套接字上设置超时 (SO_RCVTIMEO)：accept、recv、 recvfrom， recvmmsg (也有非空超时参数) 和 recvmsg。</p>
</li>
<li><p>“输出”套接字接口，当已使用 setsockopt 在套接字上设置超时 (SO_RCVTIMEO)：connect， send、sendto 和 sendmsg。</p>
</li>
<li><p>用于等待信号的接口：pause， sigsuspend， sigtimedwait 和 sigwaitinfo。</p>
</li>
<li><p>文件描述符复用接口：epoll_wait， epoll_pwait、poll、ppoll、select 和 pselect。</p>
</li>
<li><p>SystemV IPC 接口：msgrcv、msgsnd、semop 和 semtimedop。</p>
</li>
<li><p>sleep 接口：clock_nanosleep、nanosleep 和 usleep。</p>
</li>
<li><p>io_getevents。</p>
</li>
<li><p>如果被中断， sleep 函数也永远不会重新启动处理程序，但成功返回还剩下的睡眠秒数。</p>
</li>
</ul>
<h2 id="设置自动重启标志"><a href="#设置自动重启标志" class="headerlink" title="设置自动重启标志"></a>设置自动重启标志</h2><p>简单总结一下设置系统调用被信号中断时自动重启标志的方法 :</p>
<p>在安装信号捕捉函数时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">sigemptyset(&amp;sa.sa_mask);<span class="comment">//清空信号掩码集    sigemptyset简单地将 初始化signalmask为空，这样就可以保证不会屏蔽任何信号。（也就是说，所有的信号都会被接收到）</span></span><br><span class="line">sa.sa_flags = SA_RESTART;<span class="comment">//设置重启标志</span></span><br><span class="line">sa.sa_handler = sigalrm_handler;<span class="comment">//指定信号捕捉函数名称</span></span><br><span class="line"><span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) handle_error(<span class="string">&quot;sigaction&quot;</span>);<span class="comment">//注册信号捕捉函数</span></span><br></pre></td></tr></table></figure>



<h2 id="被信号打断的epoll-wait"><a href="#被信号打断的epoll-wait" class="headerlink" title="被信号打断的epoll_wait"></a>被信号打断的epoll_wait</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> handle_error(msg)   \</span></span><br><span class="line"><span class="meta">    do                      \</span></span><br><span class="line"><span class="meta">    &#123;                       \</span></span><br><span class="line"><span class="meta">        perror(msg);        \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"><span class="type">int</span> listen_sock, conn_sock, nfds, epollfd;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Our signal handler simply prints a message and returns.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigalrm_handler</span><span class="params">(<span class="type">int</span> signo)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;Received SIGALRM\n&quot;</span>); &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is responsible for setting up the</span></span><br><span class="line"><span class="comment"> * listening socket for the socket-based echo</span></span><br><span class="line"><span class="comment"> * functionality. Pretty standard stuff.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setup_listening_socket</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) handle_error(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">    <span class="type">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;enable, <span class="keyword">sizeof</span>(<span class="type">int</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;setsockopt(SO_REUSEADDR)&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;srv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">    srv_addr.sin_family = AF_INET;</span><br><span class="line">    srv_addr.sin_port = htons(port);</span><br><span class="line">    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">/* We bind to a port and turn this socket into a listening</span></span><br><span class="line"><span class="comment">     * socket.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sock, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;srv_addr, <span class="keyword">sizeof</span>(srv_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen(sock, <span class="number">10</span>) &lt; <span class="number">0</span>) handle_error(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reads 1kb from the &quot;in&quot; file descriptor and</span></span><br><span class="line"><span class="comment"> * writes it to the &quot;out&quot; file descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_fd</span><span class="params">(<span class="type">int</span> in, <span class="type">int</span> out)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    bytes_read = read(in, buff, <span class="keyword">sizeof</span>(buff) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    write(out, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If a parsable number is passed as the 1st argument to the</span></span><br><span class="line"><span class="comment"> * program, sets up SIGALRM to be sent to self the specified</span></span><br><span class="line"><span class="comment"> * seconds later.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_signals</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="comment">/* No argument passed, and so no signal will be delivered */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No alarm set. Will not be interrupted.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  if a proper number is passed, we setup the alarm,</span></span><br><span class="line"><span class="comment">     * else we return without setting one up.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> alarm_after = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (errno) handle_error(<span class="string">&quot;strtol()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (alarm_after)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Alarm after %ld seconds.\n&quot;</span>, alarm_after);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No alarm set. Will not be interrupted.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Setup a signal handler for the SIGALRM signal</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    sa.sa_flags = SA_RESTART;</span><br><span class="line">    sa.sa_handler = sigalrm_handler;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>) handle_error(<span class="string">&quot;sigaction&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Let&#x27;s send ourselves a SIGALRM signal specified</span></span><br><span class="line"><span class="comment">     * seconds later.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    alarm(alarm_after);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helper function to setup epoll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_epoll</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    epollfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epollfd == <span class="number">-1</span>) handle_error(<span class="string">&quot;epoll_create1()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the file descriptor passed to be monitored by epoll</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_fd_to_epoll</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Add fd to be monitored by epoll */</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev) == <span class="number">-1</span>) handle_error(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Setup sigalrm if a number is passed as the first argument */</span></span><br><span class="line">    setup_signals(argc, argv);</span><br><span class="line">    <span class="comment">/* Let&#x27;s setup epoll */</span></span><br><span class="line">    setup_epoll();</span><br><span class="line">    <span class="comment">/* Add stdin-based echo server to epoll&#x27;s monitoring list */</span></span><br><span class="line">    add_fd_to_epoll(STDIN_FILENO);</span><br><span class="line">    <span class="comment">/* Setup a socket to listen on port 5000 */</span></span><br><span class="line">    listen_sock = setup_listening_socket(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">/* Add socket-based echo server to epoll&#x27;s monitoring list */</span></span><br><span class="line">    add_fd_to_epoll(listen_sock);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Let&#x27;s wait for some activity on either stdin or on the socket */</span></span><br><span class="line">        nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == <span class="number">-1</span>) handle_error(<span class="string">&quot;epoll_wait()&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For each of the file descriptors epoll says are ready,</span></span><br><span class="line"><span class="comment">         * check which one it is the echo read data back.</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; nfds; n++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[n].data.fd == STDIN_FILENO)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;stdin ready..\n&quot;</span>);</span><br><span class="line">                copy_fd(STDIN_FILENO, STDOUT_FILENO);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[n].data.fd == conn_sock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;socket data ready..\n&quot;</span>);</span><br><span class="line">                copy_fd(conn_sock, conn_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[n].data.fd == listen_sock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Listening socket is ready, meaning</span></span><br><span class="line"><span class="comment">                 * there&#x27;s a new client connection */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;new connection ready..\n&quot;</span>);</span><br><span class="line">                conn_sock = accept(listen_sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (conn_sock == <span class="number">-1</span>) handle_error(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">                <span class="comment">/* Add the connected client to epoll&#x27;s monitored FDs list */</span></span><br><span class="line">                add_fd_to_epoll(conn_sock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc a.c</span><br><span class="line">./a.out  5</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/07/26/20210726205425.png" alt="image-20210726205425376"></p>
<p>当5秒后定时信号 <code>SIGALRM</code> 被信号捕捉函数处理之后, 返回 <code>epoll_wait</code> 时报错被中断的系统调用，程序结束运行。</p>
<p>这显然是对于服务器来说不能忍受的。</p>
<p>epoll_wait脆弱到被任何信号捕捉函数中断后,无法继续运行下去</p>
<p>注: 上面的代码启用了 <code>自动重启</code> 标志，但从结果来看并不能对 <code>epoll_wait</code> 生效。</p>
<p>因篇幅原因，故不对没有设置自动重启标志的 epoll_wait 测试，结果显而易见 epoll_wait 被中断了。</p>
<h1 id="引入signalfd"><a href="#引入signalfd" class="headerlink" title="引入signalfd"></a>引入signalfd</h1><p>如何避免循环  <code>while(1)&#123;epoll_wait()&#125;</code> ，这里引出我们这篇文章的主角 <a href="https://man7.org/linux/man-pages/man2/signalfd.2.html"><code>signalfd</code></a>。</p>
<blockquote>
<p>Linux 有一种机制可以将异步信号转换为可由epoll 监听的描述符。如果信号可以通过文件描述符传递，就像数据一样，那么现有的 I&#x2F;O 多路复用机制epoll可以用来处理信号，就像我们处理代表本地文件或套接字的其他文件描述符一样。</p>
</blockquote>
<p>如何将 <code>signal</code> 的异步中断转化为 <code>signalfd</code> 的一个事件,是我们接下来要考虑的问题</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> handle_error(msg)   \</span></span><br><span class="line"><span class="meta">    do                      \</span></span><br><span class="line"><span class="meta">    &#123;                       \</span></span><br><span class="line"><span class="meta">        perror(msg);        \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"><span class="type">int</span> listen_sock, conn_sock, nfds, epollfd, sfd;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function is responsible for setting up the</span></span><br><span class="line"><span class="comment"> * listening socket for the socket-based echo</span></span><br><span class="line"><span class="comment"> * functionality. Pretty standard stuff.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setup_listening_socket</span><span class="params">(<span class="type">int</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>) handle_error(<span class="string">&quot;socket()&quot;</span>);</span><br><span class="line">    <span class="type">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;enable, <span class="keyword">sizeof</span>(<span class="type">int</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;setsockopt(SO_REUSEADDR)&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;srv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">    srv_addr.sin_family = AF_INET;</span><br><span class="line">    srv_addr.sin_port = htons(port);</span><br><span class="line">    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">/* We bind to a port and turn this socket into a listening</span></span><br><span class="line"><span class="comment">     * socket.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sock, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;srv_addr, <span class="keyword">sizeof</span>(srv_addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;bind()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen(sock, <span class="number">10</span>) &lt; <span class="number">0</span>) handle_error(<span class="string">&quot;listen()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (sock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads 1kb from the &quot;in&quot; file descriptor and</span></span><br><span class="line"><span class="comment"> * writes it to the &quot;out&quot; file descriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_fd</span><span class="params">(<span class="type">int</span> in, <span class="type">int</span> out)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    bzero(buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    bytes_read = read(in, buff, <span class="keyword">sizeof</span>(buff) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    write(out, buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If a parsable number is passed as the 1st argument to the</span></span><br><span class="line"><span class="comment"> * program, sets up SIGALRM to be sent to self the specified</span></span><br><span class="line"><span class="comment"> * seconds later.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_signals</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">    <span class="type">long</span> alarm_after = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* No argument passed. Let&#x27;s set a default interval of 5. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No alarm set. Will default to 5 seconds.\n&quot;</span>);</span><br><span class="line">        alarm_after = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*  if a proper number is passed, we setup the alarm,</span></span><br><span class="line"><span class="comment">     * else we return without setting one up.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (alarm_after == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alarm_after = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (errno) handle_error(<span class="string">&quot;strtol()&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (alarm_after)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Alarm set every %ld seconds.\n&quot;</span>, alarm_after);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No alarm set. Will default to 5 seconds.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Setup SIGALRM to be delivered via SignalFD</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGALRM);</span><br><span class="line">    sigaddset(&amp;mask, SIGQUIT);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Block these signals so that they are not handled</span></span><br><span class="line"><span class="comment">     * in the usual way. We want them to be handled via</span></span><br><span class="line"><span class="comment">     * SignalFD.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>) == <span class="number">-1</span>) handle_error(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    sfd = signalfd(<span class="number">-1</span>, &amp;mask, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd == <span class="number">-1</span>) handle_error(<span class="string">&quot;signalfd&quot;</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Let&#x27;s send ourselves a SIGALRM signal every specified</span></span><br><span class="line"><span class="comment">     * seconds continuously.</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">itv</span>;</span></span><br><span class="line">    itv.it_interval.tv_sec = alarm_after;</span><br><span class="line">    itv.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    itv.it_value = itv.it_interval;</span><br><span class="line">    <span class="keyword">if</span> (setitimer(ITIMER_REAL, &amp;itv, <span class="literal">NULL</span>) == <span class="number">-1</span>) handle_error(<span class="string">&quot;setitimer()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helper function to setup epoll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_epoll</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    epollfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (epollfd == <span class="number">-1</span>) handle_error(<span class="string">&quot;epoll_create1()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the file descriptor passed to be monitored by epoll</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_fd_to_epoll</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Add fd to be monitored by epoll */</span></span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;ev) == <span class="number">-1</span>) handle_error(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is not a signal handler in the traditional sense.</span></span><br><span class="line"><span class="comment"> * Signal handlers are invoked by the kernel asynchronously.</span></span><br><span class="line"><span class="comment"> * Meaning, we have no control over when it&#x27;s invoked and</span></span><br><span class="line"><span class="comment"> * if we need to restart any system calls.</span></span><br><span class="line"><span class="comment"> * This function is invoked from our epoll based event loop</span></span><br><span class="line"><span class="comment"> * synchronously. Meaning, we have full control over when we</span></span><br><span class="line"><span class="comment"> * invoke this function call. And we do not interrupt any</span></span><br><span class="line"><span class="comment"> * system calls. This makes error handling much simpler in</span></span><br><span class="line"><span class="comment"> * our programs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_signals</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signalfd_siginfo</span> <span class="title">sfd_si</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (read(sfd, &amp;sfd_si, <span class="keyword">sizeof</span>(sfd_si)) == <span class="number">-1</span>) handle_error(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd_si.ssi_signo == SIGALRM)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got SIGALRM via SignalFD.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sfd_si.ssi_signo == SIGQUIT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got SIGQUIT. Will exit.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got unexpected signal!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Let&#x27;s setup epoll */</span></span><br><span class="line">    setup_epoll();</span><br><span class="line">    <span class="comment">/* Add stdin-based echo server to epoll&#x27;s monitoring list */</span></span><br><span class="line">    add_fd_to_epoll(STDIN_FILENO);</span><br><span class="line">    <span class="comment">/* Setup a socket to listen on port 5000 */</span></span><br><span class="line">    listen_sock = setup_listening_socket(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">/* Add socket-based echo server to epoll&#x27;s monitoring list */</span></span><br><span class="line">    add_fd_to_epoll(listen_sock);</span><br><span class="line">    <span class="comment">/* Setup sigalrm+sigquit if a number is passed as the first argument */</span></span><br><span class="line">    setup_signals(argc, argv);</span><br><span class="line">    <span class="comment">/* Add the SignalFD file descriptor to epoll&#x27;s monitoring list */</span></span><br><span class="line">    add_fd_to_epoll(sfd);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Let&#x27;s wait for some activity on either stdin or on the socket */</span></span><br><span class="line">        nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nfds == <span class="number">-1</span>) handle_error(<span class="string">&quot;epoll_wait()&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For each of the file descriptors epoll says are ready,</span></span><br><span class="line"><span class="comment">         * check which one it is the echo read data back.</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; nfds; n++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[n].data.fd == STDIN_FILENO)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;stdin ready..\n&quot;</span>);</span><br><span class="line">                copy_fd(STDIN_FILENO, STDOUT_FILENO);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[n].data.fd == conn_sock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;socket data ready..\n&quot;</span>);</span><br><span class="line">                copy_fd(conn_sock, conn_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[n].data.fd == listen_sock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Listening socket is ready, meaning</span></span><br><span class="line"><span class="comment">                 * there&#x27;s a new client connection */</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;new connection ready..\n&quot;</span>);</span><br><span class="line">                conn_sock = accept(listen_sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (conn_sock == <span class="number">-1</span>) handle_error(<span class="string">&quot;accept()&quot;</span>);</span><br><span class="line">                <span class="comment">/* Add the connected client to epoll&#x27;s monitored FDs list */</span></span><br><span class="line">                add_fd_to_epoll(conn_sock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[n].data.fd == sfd)</span><br><span class="line">            &#123;</span><br><span class="line">                handle_signals();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//注册signalfd(仅增加的部分步骤)</span></span><br><span class="line"><span class="type">sigset_t</span> mask;</span><br><span class="line"><span class="type">int</span> sfd = signalfd(<span class="number">-1</span>, &amp;mask, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sfd == <span class="number">-1</span>) handle_error(<span class="string">&quot;signalfd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将signalfd添加进epoll监听事件</span></span><br><span class="line">add_fd_to_epoll(sfd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll对与signalfd的处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_signals</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signalfd_siginfo</span> <span class="title">sfd_si</span>;</span><span class="comment">//新的结构体来分辨是何种信号</span></span><br><span class="line">    <span class="keyword">if</span> (read(sfd, &amp;sfd_si, <span class="keyword">sizeof</span>(sfd_si)) == <span class="number">-1</span>) handle_error(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sfd_si.ssi_signo == SIGALRM)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got SIGALRM via SignalFD.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sfd_si.ssi_signo == SIGQUIT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got SIGQUIT. Will exit.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got unexpected signal!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//影响了while(1)中的epoll_wait的处理流程,增加了判断</span></span><br><span class="line"><span class="keyword">if</span> (events[n].data.fd == sfd)</span><br><span class="line">&#123;</span><br><span class="line">     handle_signals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们学会了如何避免 epoll 被信号处理函数中断，增加了服务器的稳定性， congratulations!</p>
<h1 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h1><p>文章发自<a href="https://blog.yegetables.cn/archives/590/">将signalfd加入epoll</a></p>
<p>读者可以<a href="https://unixism.net/2021/02/making-signals-less-painful-under-linux/">阅读原文—24.5 被信号中断的原语</a></p>
<p>[hide]<a href="https://mp.weixin.qq.com/s/Rn0ab_k61OdjurklLMYbsA">微信推送</a>[&#x2F;hide]</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>epoll</tag>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>System V消息队列</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-04-11-System_V%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="System-V消息队列"><a href="#System-V消息队列" class="headerlink" title="System V消息队列"></a>System V消息队列</h1><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="自定义消息结构体"><a href="#自定义消息结构体" class="headerlink" title="自定义消息结构体"></a>自定义消息结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgst</span> //任意起名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> type; <span class="comment">//必须有</span></span><br><span class="line">    <span class="type">char</span> msg[<span class="number">128</span>]; <span class="comment">//任意类型</span></span><br><span class="line">&#125; mymsg;  <span class="comment">//创建对象,,也可以后面自己随时创建对象</span></span><br></pre></td></tr></table></figure>

<h3 id="ftok得到键值"><a href="#ftok得到键值" class="headerlink" title="ftok得到键值"></a>ftok得到键值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//key_t ftok(const char *__pathname, int __proj_id)</span></span><br><span class="line">      <span class="comment">//提供键值</span></span><br><span class="line">    <span class="type">int</span> c=<span class="number">0</span>; <span class="comment">//范围1-255</span></span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, c);</span><br></pre></td></tr></table></figure>

<h3 id="创建-x2F-访问消息队列"><a href="#创建-x2F-访问消息队列" class="headerlink" title="创建&#x2F;访问消息队列"></a>创建&#x2F;访问消息队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int msgget(key_t __key, int __msgflg)</span></span><br><span class="line"><span class="comment">//msgflg:</span></span><br><span class="line"><span class="comment">//	IPC_CREAT :无则创建,有则返回</span></span><br><span class="line"><span class="comment">//  IPC_EXCl:与creat一起使用,有则出错-1</span></span><br><span class="line">     <span class="comment">//   </span></span><br><span class="line">     <span class="type">int</span> qid = msgget(key , IPC_CREAT | <span class="number">0644</span>);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="写入消息队列"><a href="#写入消息队列" class="headerlink" title="写入消息队列"></a>写入消息队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//1.构造消息队列</span></span><br><span class="line">   mymsg.type = <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>(mymsg.msg, <span class="string">&quot;ababc&quot;</span>);</span><br><span class="line">len =<span class="built_in">strlen</span>(mymsg.msg);<span class="comment">//</span></span><br><span class="line"><span class="comment">//len=sizeof(struct msgst)-4;//减去long</span></span><br></pre></td></tr></table></figure>

<h3 id="发送消息队列"><a href="#发送消息队列" class="headerlink" title="发送消息队列"></a>发送消息队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> __msqid, <span class="type">const</span> <span class="type">void</span> *__msgp, <span class="type">size_t</span> __msgsz, <span class="type">int</span> __msgflg)</span></span><br><span class="line"><span class="comment">//                 qid        struct       			 len        flag</span></span><br><span class="line"><span class="comment">//flag</span></span><br><span class="line"><span class="comment">//		0 消息队列满则阻塞</span></span><br><span class="line"><span class="comment">//    	IPC_NOWAIT 满则立即返回</span></span><br></pre></td></tr></table></figure>

<h2 id="查看-终端"><a href="#查看-终端" class="headerlink" title="查看(终端)"></a>查看(终端)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipcs</span><br></pre></td></tr></table></figure>



<h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><h3 id="得到键值和消息队列号"><a href="#得到键值和消息队列号" class="headerlink" title="得到键值和消息队列号"></a>得到键值和消息队列号</h3><p>[ftok得到键值](#  ftok得到键值)</p>
<p>[创建&#x2F;访问消息队列](# 创建&#x2F;访问消息队列)</p>
<h3 id="利用空结构体储存读到的消息"><a href="#利用空结构体储存读到的消息" class="headerlink" title="利用空结构体储存读到的消息"></a>利用空结构体储存读到的消息</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ssize_t msgrcv(int __msqid, void *__msgp, size_t __msgsz, long __msgtyp, int __msgflg)</span></span><br><span class="line"><span class="comment">//					qid			struct			len				msg.type		flg</span></span><br><span class="line"><span class="comment">//flg	</span></span><br><span class="line"><span class="comment">//	IPC_NOWAIT 无消息立即返回不阻塞</span></span><br><span class="line"><span class="comment">//  IPC_EXCEPT 返回第一个不为msg.type的结构</span></span><br><span class="line"><span class="comment">//  IPC_NOERROR	如果满足条件的消息大于len,则截断,舍弃超出部分</span></span><br><span class="line"></span><br><span class="line">len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msgst) - <span class="number">4</span>;</span><br><span class="line">    msgrcv(qid, &amp;mymsg, len, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mymsg.msg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//int msgctl(int __msqid, int __cmd, struct msqid_ds *__buf)</span></span><br><span class="line"><span class="comment">//					qid		cmd				struct msqid_ds</span></span><br><span class="line"><span class="comment">//cmd:</span></span><br><span class="line"><span class="comment">//	IPC_STAT	 获取消息队列的msqid_ds结构存入指定位置</span></span><br><span class="line"><span class="comment">//	IPC_SET		 设置属性(仅uid,gid,mode,qbytes)</span></span><br><span class="line"><span class="comment">//  IPC_RMID 	 删消息队列</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">temp</span>;</span></span><br><span class="line">msgctl(msgid,IPC_STAT,&amp;temp);<span class="comment">//获取</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="客户端服务端通信实例"><a href="#客户端服务端通信实例" class="headerlink" title="客户端服务端通信实例"></a>客户端服务端通信实例</h1><h2 id="客户端client"><a href="#客户端client" class="headerlink" title="客户端client"></a>客户端client</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MYERROR</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;my/debug.info.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER 2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgst</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> type;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">128</span>];</span><br><span class="line">&#125; mysendmsg, myfrommsg;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">readServer</span><span class="params">(<span class="type">void</span> *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> qid = *((<span class="type">int</span> *)q);</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msgst) - <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> != msgrcv(qid, &amp;myfrommsg, len, SERVER, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myfrommsg.type == SERVER)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;server:%s\n&quot;</span>, myfrommsg.msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == ENOMSG)</span><br><span class="line">            &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                PRINTEXIT(<span class="string">&quot;msgrcv &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msgst) - <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">key_t</span> key1 = ftok(<span class="string">&quot;.&quot;</span>, c);</span><br><span class="line">    <span class="type">int</span> qid = msgget(key1, IPC_CREAT | <span class="number">0644</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, readServer, (<span class="type">void</span> *)&amp;qid);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client:\n&quot;</span>);</span><br><span class="line">        fgets(mysendmsg.msg, len, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(mysendmsg.msg, <span class="string">&quot;exit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mysendmsg.type = CLIENT;</span><br><span class="line">        mysendmsg.msg[<span class="built_in">strlen</span>(mysendmsg.msg) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != msgsnd(qid, &amp;mysendmsg, len, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsnd &quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MYERROR</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;my/debug.info.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER 2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgst</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> type;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">128</span>];</span><br><span class="line">&#125; mysendmsg, myfrommsg;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">readClient</span><span class="params">(<span class="type">void</span> *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> qid = *((<span class="type">int</span> *)q);</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msgst) - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> != msgrcv(qid, &amp;myfrommsg, len, CLIENT, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (myfrommsg.type == CLIENT)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client:\n%s\n&quot;</span>, myfrommsg.msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == ENOMSG)</span><br><span class="line">            &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                PRINTEXIT(<span class="string">&quot;msgrcv &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// char s[128] = &quot;asaaaa&quot;;</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="type">key_t</span> key1 = ftok(<span class="string">&quot;.&quot;</span>, c);                </span><br><span class="line">    <span class="type">int</span> qid = msgget(key1, IPC_CREAT | <span class="number">0644</span>); </span><br><span class="line">                                              </span><br><span class="line">    len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msgst) - <span class="number">4</span>;</span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    pthread_create(&amp;thread, <span class="literal">NULL</span>, readClient, (<span class="type">void</span> *)&amp;qid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server:\n&quot;</span>);</span><br><span class="line">        fgets(mysendmsg.msg, len, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(mysendmsg.msg, <span class="string">&quot;exit&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mysendmsg.type = SERVER;</span><br><span class="line">        mysendmsg.msg[<span class="built_in">strlen</span>(mysendmsg.msg) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != msgsnd(qid, &amp;mysendmsg, len, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsnd &quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>队列</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>线程与线程同步</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-04-08-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><h2 id="创建变量储存线程-id"><a href="#创建变量储存线程-id" class="headerlink" title="创建变量储存线程 id"></a>创建变量储存线程 id</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> pth ;<span class="comment">//线程id</span></span><br></pre></td></tr></table></figure>

<h2 id="可选-线程属性"><a href="#可选-线程属性" class="headerlink" title="(可选)线程属性"></a>(可选)线程属性</h2><p>(可选)可自定义线程属性,也可使用默认 NULL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义线程属性</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_attr_t</span> attr;<span class="comment">// 初始化线程属性 &amp;&amp; creat 也可传 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线程属性</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line">    <span class="comment">//销毁线程属性所占用的资源</span></span><br><span class="line">    pthread_attr_destroy();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线程属性，分离 or 非分离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取程属性，分离 or 非分离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line">    <span class="comment">// detachstate：</span></span><br><span class="line">    <span class="comment">//     PTHREAD_CREATE_DETACHED（分离线程）</span></span><br><span class="line">    <span class="comment">//     PTHREAD _CREATE_JOINABLE（非分离线程）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *__attr, <span class="type">int</span> *__detachstate)</span>;</span><br><span class="line"><span class="comment">//获取线程状态保存到第二个参数</span></span><br><span class="line">    <span class="comment">// 判断线程状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (detachstate == PTHREAD_CREATE_DETACHED) <span class="comment">//判断分离</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread detached\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (detachstate == PTHREAD_CREATE_JOINABLE)<span class="comment">//判断非分离</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread join\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread unknown\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="creat-线程"><a href="#creat-线程" class="headerlink" title="creat 线程"></a>creat 线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread*<span class="title function_">create</span><span class="params">(&amp;pth, <span class="literal">NULL</span>, (<span class="type">void</span> *)func, (<span class="type">void</span> \_)argv)</span>;</span><br><span class="line"><span class="comment">//(指定线程 id,线程属性,执行函数,函数参数)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *__restrict__ __newthread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *__restrict__ __attr, <span class="type">void</span> *(*__start_routine)(<span class="type">void</span> *), <span class="type">void</span> *__restrict__ __arg)</span></span><br></pre></td></tr></table></figure>

<h2 id="线程其他用法"><a href="#线程其他用法" class="headerlink" title="线程其他用法"></a>线程其他用法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_exit()<span class="comment">//退出线程</span></span><br><span class="line">pthread_join()<span class="comment">//阻塞等待回收线程 ,第二个参数保存返回值</span></span><br><span class="line">pthread_cancel() <span class="comment">//取消线程(到达取消点时取消)</span></span><br><span class="line">pthread_self();<span class="comment">//获取线程id</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="互斥量使用"><a href="#互斥量使用" class="headerlink" title="互斥量使用"></a>互斥量使用</h1><h2 id="初始化互斥量"><a href="#初始化互斥量" class="headerlink" title="初始化互斥量"></a>初始化互斥量</h2><h3 id="1-静态初始化"><a href="#1-静态初始化" class="headerlink" title="1. 静态初始化"></a>1. 静态初始化</h3><p>如果互斥锁 mutex 是静态分配的（定义在全局，或加了 static 关键字修饰），可以直接 使用宏进行初始化。(可移植性差)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>

<h3 id="2-动态初始化"><a href="#2-动态初始化" class="headerlink" title="2. 动态初始化"></a>2. 动态初始化</h3><p>局部变量应采用动态初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>)<span class="comment">//默认属性(线程间共享)</span></span><br></pre></td></tr></table></figure>

<h2 id="正常-创建线程"><a href="#正常-创建线程" class="headerlink" title="正常 创建线程"></a>正常 <a href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">创建线程</a></h2><h2 id="每个线程中"><a href="#每个线程中" class="headerlink" title="每个线程中"></a>每个线程中</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;lock);或 pthread_mutex_trylock(&amp;lock);</span><br><span class="line"><span class="comment">/*------------  使用 -------------*/</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<h2 id="销毁互斥量-仅动态初始化"><a href="#销毁互斥量-仅动态初始化" class="headerlink" title="销毁互斥量(仅动态初始化)"></a>销毁互斥量(仅动态初始化)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_destroy(&amp;lock);</span><br></pre></td></tr></table></figure>

<h1 id="条件变量-pthread-cond-t"><a href="#条件变量-pthread-cond-t" class="headerlink" title="条件变量 pthread_cond_t"></a>条件变量 pthread_cond_t</h1><blockquote>
<p><code>经常结合互斥量使用,且与互斥量使用方式类似</code></p>
</blockquote>
<h2 id="条件变量初始化"><a href="#条件变量初始化" class="headerlink" title="条件变量初始化"></a>条件变量初始化</h2><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond=THREAD_COND_INITIALIZE;</span><br></pre></td></tr></table></figure>

<h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_init();</span><br></pre></td></tr></table></figure>

<h2 id="通知与等待"><a href="#通知与等待" class="headerlink" title="通知与等待"></a>通知与等待</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pthread_cond_signal();<span class="comment">//只保证唤醒至少一条遭到阻塞的线程</span></span><br><span class="line">pthread_cond_broadcast();<span class="comment">//会唤醒所有遭阻塞的线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_cond_wait();<span class="comment">//函数将阻塞一线程，直至收到条件变量 cond的通知。</span></span><br><span class="line">pthread_cond_timedwait();<span class="comment">//参数来指定休眠时间的上限。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数abstime是一个timespec类型的结构（见23.4.2节），用以指定自Epoch（参考10.1节）以来以秒和纳秒（nanosecond）为单位表示的绝对（absolute）时间。如果abstime指定的时间间隔到期且无相关条件变量的通知，则返回ETIMEOUT错误</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>

<h1 id="生产者消费者模型之互斥量"><a href="#生产者消费者模型之互斥量" class="headerlink" title="生产者消费者模型之互斥量"></a>生产者消费者模型之互斥量</h1><h3 id="生产者-子线程"><a href="#生产者-子线程" class="headerlink" title="生产者(子线程)"></a>生产者(子线程)</h3><ol>
<li>加锁</li>
<li>判断缓冲区容量<br>空闲&#x2F;充足:<br>生产+操作+通知</li>
<li>解锁</li>
</ol>
<h3 id="消费者-主线程"><a href="#消费者-主线程" class="headerlink" title="消费者(主线程)"></a>消费者(主线程)</h3><p><strong>一定要先加锁再判断</strong></p>
<ol>
<li>加锁</li>
<li>判断<br>缓冲区空:堵塞</li>
<li>操作</li>
<li>解锁</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">char</span> header[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//缓冲区大小10</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producter</span><span class="params">(<span class="type">void</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="comment">//1. 加锁</span></span><br><span class="line">    <span class="comment">//2. 判断缓冲区容量</span></span><br><span class="line">    <span class="comment">//      空闲/充足:</span></span><br><span class="line">    <span class="comment">//          生产+操作+通知</span></span><br><span class="line">    <span class="comment">//3. 解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> temp[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//满了不生产</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(header) != <span class="number">9</span>) <span class="comment">//判断是否满</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i am producter%ld\n&quot;</span>, pthread_self());</span><br><span class="line">            <span class="built_in">strcpy</span>(temp, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(header, temp);</span><br><span class="line">            pthread_cond_signal(&amp;cond);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">customer</span><span class="params">(<span class="type">void</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="comment">//1.加锁</span></span><br><span class="line">    <span class="comment">//2.判断</span></span><br><span class="line">    <span class="comment">//      缓冲区空:堵塞</span></span><br><span class="line">    <span class="comment">//3.操作</span></span><br><span class="line">    <span class="comment">//4.解锁</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">strlen</span>(header) == <span class="number">0</span>) <span class="comment">//空了不消费</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;               %s\n&quot;</span>, header);</span><br><span class="line">        header[<span class="built_in">strlen</span>(header) - <span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;                       i am customer %ld\n&quot;</span>, pthread_self());</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">12</span>];</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, producter, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Posix-无名信号量"><a href="#Posix-无名信号量" class="headerlink" title="Posix 无名信号量"></a>Posix 无名信号量</h1><p>可用于线程间也可用于进程间<br>sem_init 函数参 2：pshared<br>取<code>0 </code>用于<code>线程</code>间；<br>取<code>非 0</code>（一般为 1）用于<code>进程间</code></p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>#include&lt;semaphore.h&gt;</p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p><code>sem_t</code> 类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> sem;<span class="comment">//规定信号量 sem 不能 &lt; 0</span></span><br></pre></td></tr></table></figure>

<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sem_init 函数</span><br><span class="line">sem_destroy 函数</span><br><span class="line">sem_wait 函数</span><br><span class="line">sem_post 函数</span><br><span class="line">sem_wait:   <span class="number">1.</span> 信号量大于 <span class="number">0</span>，则信号量--</span><br><span class="line">|           <span class="number">2.</span> 信号量等于 <span class="number">0</span>，造成线程阻塞（类比 pthread_mutex_lock）</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">sem_post： 将信号量++，同时唤醒阻塞在信号量上的线程 （类比 pthread_mutex_unlock）</span><br><span class="line">sem_trywait 函数</span><br><span class="line">sem_timedwait 函数</span><br></pre></td></tr></table></figure>

<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sem_init 函数</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">参 <span class="number">1</span>：sem 信号量</span><br><span class="line">参 <span class="number">2</span>：pshared 取 <span class="number">0</span> 用于线程间；</span><br><span class="line">              取非 <span class="number">0</span>（一般为 <span class="number">1</span>）用于进程间</span><br><span class="line">参 <span class="number">3</span>：value 指定信号量初值</span><br><span class="line"></span><br><span class="line">sem_destroy 函数</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line">sem_wait 函数</span><br><span class="line"><span class="number">1.</span> 信号量大于 <span class="number">0</span>，则信号量--</span><br><span class="line"><span class="number">2.</span> 信号量等于 <span class="number">0</span>，造成线程阻塞（类比 pthread_mutex_lock）</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line">sem_post 函数</span><br><span class="line">给信号量解锁 ++</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line">sem_trywait 函数</span><br><span class="line">尝试对信号量加锁 -- (与 sem_wait 的区别类比 lock 和 trylock)</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line">sem_timedwait 函数</span><br><span class="line">限时尝试对信号量加锁</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line">参 <span class="number">2</span>：abs_timeout 采用的是绝对时间。</span><br><span class="line">        定时 <span class="number">1</span> 秒：</span><br><span class="line">                <span class="type">time_t</span> cur = time(<span class="literal">NULL</span>); 获取当前时间。</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span>;</span> 定义 timespec 结构体变量 t</span><br><span class="line">                t.tv_sec = cur+<span class="number">1</span>; 定时 <span class="number">1</span> 秒</span><br><span class="line">                t.tv_nsec = t.tv_sec +<span class="number">100</span>;</span><br><span class="line">                sem_timedwait(&amp;sem, &amp;t); 传参</span><br></pre></td></tr></table></figure>

<h1 id="生产者消费者模型之信号量"><a href="#生产者消费者模型之信号量" class="headerlink" title="生产者消费者模型之信号量"></a>生产者消费者模型之信号量</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> header[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//缓冲区大小10</span></span><br><span class="line"><span class="type">sem_t</span> fre;</span><br><span class="line"><span class="type">sem_t</span> used;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">producter</span><span class="params">(<span class="type">void</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;fre);<span class="comment">//fre--  为负则堵塞</span></span><br><span class="line">        <span class="built_in">strcpy</span>(temp, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(header, temp);</span><br><span class="line">        sem_post(&amp;used);<span class="comment">//used++</span></span><br><span class="line">        <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">customer</span><span class="params">(<span class="type">void</span> *argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sem_wait(&amp;used);<span class="comment">//used-- 为负堵塞</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, header);</span><br><span class="line">        header[<span class="built_in">strlen</span>(header - <span class="number">3</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        sem_post(&amp;fre);<span class="comment">//fre++</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">12</span>];</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;used, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;fre, <span class="number">0</span>, <span class="number">3</span>);<span class="comment">//最多生产3个数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, producter, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;used);</span><br><span class="line">    sem_destroy(&amp;fre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><blockquote>
<p>写独占、读共享</p>
</blockquote>
<blockquote>
<p>读锁、写锁并行阻塞，写锁优先级高</p>
</blockquote>
<h2 id="定义一个读写锁变量"><a href="#定义一个读写锁变量" class="headerlink" title="定义一个读写锁变量"></a>定义一个读写锁变量</h2><p><code>pthread_rwlock_t</code> 类型 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure>





<h2 id="主要应用函数"><a href="#主要应用函数" class="headerlink" title="主要应用函数"></a>主要应用函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_rwlock_init 函数</span><br><span class="line">pthread_rwlock_destroy 函数</span><br><span class="line"></span><br><span class="line">pthread_rwlock_rdlock 函数</span><br><span class="line">pthread_rwlock_wrlock 函数</span><br><span class="line">    pthread_rwlock_tryrdlock 函数</span><br><span class="line">    pthread_rwlock_trywrlock 函数</span><br><span class="line">pthread_rwlock_unlock 函数</span><br></pre></td></tr></table></figure>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*		待完成 		*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>互斥量</tag>
        <tag>线程同步</tag>
        <tag>生产者消费者</tag>
      </tags>
  </entry>
  <entry>
    <title>守护进程Daemon</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-04-03-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8Bdaemon/</url>
    <content><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h3 id="主程序-main-函数"><a href="#主程序-main-函数" class="headerlink" title="主程序 main()函数"></a>主程序 main()函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.主程序执行 creat_daemon()函数创建守护进程,成功返回 0,失败返回-1</span><br><span class="line"></span><br><span class="line">2.主程序检查返回值并执行后台任务</span><br></pre></td></tr></table></figure>

<h3 id="子程序-creat-daemon-创建守护进程函数"><a href="#子程序-creat-daemon-创建守护进程函数" class="headerlink" title="子程序 creat_daemon()创建守护进程函数"></a>子程序 creat_daemon()创建守护进程函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建子进程，父进程退出(退出终端,前台)</span><br><span class="line"></span><br><span class="line">2.创建新会话,使子进程完全独立出来，脱离控制,成为新会话组长</span><br><span class="line"></span><br><span class="line">3.再次创建子进程(第二次保证进程不是进程组长),使无法打开终端</span><br><span class="line"></span><br><span class="line">4.切换到根目录,防止磁盘挂载占用</span><br><span class="line"></span><br><span class="line">5.重设文件权限掩码</span><br><span class="line"></span><br><span class="line">6.关闭文件描述符</span><br><span class="line"></span><br><span class="line">7.信号处理,如果对于信号处理通过怕生成子进程执行,要设置信号忽略 SIGCHLD 信号,可以避免子进程成为僵尸</span><br><span class="line"></span><br><span class="line">8.其他,可以处理别的,也可以返回主程序,执行任务,此时主程序成为守护进程</span><br></pre></td></tr></table></figure>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat_daemon</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.创建子进程，父进程退出</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2.创建新会话,使子进程完全独立出来，脱离控制</span></span><br><span class="line">        pid = setsid();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.再次创建子进程(第二次保证进程不是进程组长),使终端无法打开</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.切换目录</span></span><br><span class="line">    chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.重设文件权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.关文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NOFILE; close(i++))</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.信号处理</span></span><br><span class="line">    <span class="comment">//如果对于信号处理通过怕生成子进程执行,要设置信号忽略SIGCHLD信号,可以避免子进程成为僵尸</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.其他,可以处理别的</span></span><br><span class="line">    <span class="comment">//也可以返回主程序,执行任务,此时主程序成为守护进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == creat_daemon())<span class="comment">//检查返回值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>信号</tag>
        <tag>守护进程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Mmap文件读写操作</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-04-03-mmap%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>利用 mmap 进行文件操作以及一些进程通信操作是非常 nice 的,具体可以参考别的内容了解原理,本文只涉及 mmap 的使用</p>
<h1 id="函数原型和要点"><a href="#函数原型和要点" class="headerlink" title="函数原型和要点"></a>函数原型和要点</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">    addr:指针地址,一般<span class="literal">NULL</span>系统自动分配返回</span><br><span class="line">    length:文件长度 可以用`<span class="type">int</span> len=lseek(fd,<span class="number">0</span>,SEEK_END)`</span><br><span class="line">    prot:读写模式 可选 PROT_READ和 PROT_WRITE ,读写则用 | 连接</span><br><span class="line">    flags:修改到文件选MAP_SHARED,不更改文件选MAP_PRIVATE</span><br><span class="line">    fd: 使用mmap需要提前open文件</span><br><span class="line">        mmap需要读权限</span><br><span class="line">        mmap&lt;=open权限</span><br><span class="line">    对于新建文件提前使用 `ftruncate(fd, <span class="number">20</span>);`等确保文件大小不为<span class="number">0</span>(拓展文件)</span><br><span class="line">    offset:偏移量 <span class="number">4</span>k的整数倍    <span class="number">0</span> 开头不偏移</span><br><span class="line">    <span class="keyword">return</span>:返回一个指针指向文件流开头 常用<span class="type">char</span>*</span><br><span class="line"><span class="type">int</span> munmap(<span class="type">void</span> *addr, <span class="type">size_t</span> length);</span><br><span class="line">    addr:指向映射开头的指针</span><br><span class="line">    length:与mmap参数中的len相同</span><br><span class="line">    <span class="keyword">return</span>: <span class="number">-1</span> 出错</span><br></pre></td></tr></table></figure>

<h1 id="读写实例"><a href="#读写实例" class="headerlink" title="读写实例"></a>读写实例</h1><h2 id="1-打开文件-大于等于只读权限-不能只写"><a href="#1-打开文件-大于等于只读权限-不能只写" class="headerlink" title="1.打开文件(大于等于只读权限,不能只写)"></a>1.打开文件(大于等于只读权限,不能只写)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;cin.in&quot;</span>, O_RDWR); <span class="comment">//读的话别选O_TRUNC模式</span></span><br></pre></td></tr></table></figure>

<h2 id="2-扩展文件-可选-保证文件大小不为-0"><a href="#2-扩展文件-可选-保证文件大小不为-0" class="headerlink" title="2.扩展文件(可选,保证文件大小不为 0)"></a>2.扩展文件(可选,保证文件大小不为 0)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ftruncate(fd, <span class="number">20</span>); <span class="comment">//可存20个有效字符再加一个\0</span></span><br><span class="line"><span class="comment">// lseek(fd, 20, SEEK_END);</span></span><br><span class="line"><span class="comment">// write(fd, &#x27;\0&#x27;, 1);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-建立映射-成功可以关文件"><a href="#3-建立映射-成功可以关文件" class="headerlink" title="3.建立映射(成功可以关文件)"></a>3.建立映射(成功可以关文件)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> len = lseek(fd, <span class="number">0</span>, SEEK_END);<span class="comment">//获得文件长度</span></span><br><span class="line"><span class="type">char</span>*p=<span class="literal">NULL</span>;</span><br><span class="line">p = (<span class="type">char</span> *)mmap(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (p == MAP_FAILED)</span><br><span class="line">&#123;   </span><br><span class="line">    print(<span class="string">&quot;mmap failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    close(fd);<span class="comment">//mmap映射成功可以关文件</span></span><br></pre></td></tr></table></figure>
<h2 id="4-读写文件"><a href="#4-读写文件" class="headerlink" title="4.读写文件"></a>4.读写文件</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br></pre></td></tr></table></figure>

<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p指向文件头,原内容尾为\n\0 有换行键</span></span><br><span class="line"><span class="comment">//cat的话非变成 原str+\n+新str</span></span><br><span class="line"><span class="built_in">strcat</span>(p, <span class="string">&quot;123456789123456789123456789&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<h2 id="5-解除映射"><a href="#5-解除映射" class="headerlink" title="5.解除映射"></a>5.解除映射</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">len = munmap(p, len);<span class="comment">//解除mmap映射</span></span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">-1</span>)<span class="comment">//检查出错</span></span><br><span class="line">    PRINTEXIT(<span class="string">&quot;munmap&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="匿名映射-不显示的打开文件"><a href="#匿名映射-不显示的打开文件" class="headerlink" title="匿名映射(不显示的打开文件)"></a>匿名映射(不显示的打开文件)</h1><p>宏 MAP_ANONYMOUS (或 MAP_ANON)</p>
<p><code>p = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code></p>
<blockquote>
<p>(flags | 宏 然后 fd&#x3D;-1)</p>
</blockquote>
<p>相当于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/zero&quot;</span>, O_RDWR);</span><br><span class="line">p = mmap(<span class="literal">NULL</span>, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>信号捕捉与屏蔽</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-04-03-%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E4%B8%8E%E5%B1%8F%E8%94%BD/</url>
    <content><![CDATA[<h1 id="信号可以屏蔽-也可以捕捉"><a href="#信号可以屏蔽-也可以捕捉" class="headerlink" title="信号可以屏蔽,也可以捕捉"></a>信号可以屏蔽,也可以捕捉</h1><h1 id="信号屏蔽-阻塞"><a href="#信号屏蔽-阻塞" class="headerlink" title="信号屏蔽(阻塞)"></a>信号屏蔽(阻塞)</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;<span class="comment">//初始化信号集</span></span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);<span class="comment">//清空信号集</span></span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGINT);<span class="comment">//信号加入信号集</span></span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);<span class="comment">//设置屏蔽信号(堵塞,解除后恢复)</span></span><br><span class="line">sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);<span class="comment">//解除屏蔽</span></span><br></pre></td></tr></table></figure>
<h3 id="详解sigprocmask"><a href="#详解sigprocmask" class="headerlink" title="详解sigprocmask"></a>详解sigprocmask</h3><pre><code>   int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

   set自定义位图

   old保存旧位图

   how有
   1. SIG_BLOCK: set 表示需要屏蔽的信号。相当于 mask = mask|set

   2. SIG_UNBLOCK: set 表示需要解除屏蔽的信号。相当于 mask = mask &amp; ~set

   3. SIG_SETMASK: set 表示用于替代原始屏蔽及的新屏蔽集。相当于 mask = set 若，调用 sigprocmask 解除了对当前若干个信号的阻塞，则在 sigprocmask 返回前，至少将其中一 个信号递达。
</code></pre>
<h1 id="信号捕捉-自定义"><a href="#信号捕捉-自定义" class="headerlink" title="信号捕捉(自定义)"></a>信号捕捉(自定义)</h1><h2 id="1-捕捉函数-void-fun-int"><a href="#1-捕捉函数-void-fun-int" class="headerlink" title="1.捕捉函数(void)fun(int)"></a>1.捕捉函数(void)fun(int)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">er</span><span class="params">(<span class="type">int</span> number)</span><span class="comment">//信号捕捉函数 (void)func(int)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (number == SIGINT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number==SIGCHLD)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">pid_t</span> wpid;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,&amp;status,<span class="number">0</span>))!=<span class="number">-1</span>)<span class="comment">//防止多个进程同时死亡</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,WEXISTATUS(ststus));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-先阻塞"><a href="#2-先阻塞" class="headerlink" title="2.先阻塞"></a>2.先阻塞</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;<span class="comment">//初始化信号集</span></span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);<span class="comment">//清空信号集</span></span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD);<span class="comment">//SIGCHLD信号加入信号集</span></span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);<span class="comment">//设置屏蔽信号(堵塞,解除后恢复,只处理一次)</span></span><br></pre></td></tr></table></figure>

<h2 id="3-再注册"><a href="#3-再注册" class="headerlink" title="3.再注册"></a>3.再注册</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">new</span>, <span class="title">old</span>;</span></span><br><span class="line">new.sa_handler = er;            <span class="comment">//执行函数名(先写捕捉函数)</span></span><br><span class="line">sigemptyset(&amp;new.sa_mask);      <span class="comment">//清空捕捉屏蔽字</span></span><br><span class="line">new.sa_flags = <span class="number">0</span>;               <span class="comment">//0 默认操作(屏蔽本信号)设置捕捉屏蔽字</span></span><br><span class="line">sigaction(SIGCHLD,&amp;new,&amp;old);   <span class="comment">//信号SIGCHLD 子进程状态变化</span></span><br></pre></td></tr></table></figure>

<h2 id="4-再解除阻塞"><a href="#4-再解除阻塞" class="headerlink" title="4.再解除阻塞"></a>4.再解除阻塞</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);<span class="comment">//解除屏蔽(处理一次)</span></span><br></pre></td></tr></table></figure>

<h3 id="关于sigaction与struct-sigaction"><a href="#关于sigaction与struct-sigaction" class="headerlink" title="关于sigaction与struct sigaction"></a>关于sigaction与struct sigaction</h3><p><em>注意3点</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new.sa_handler = er;            <span class="comment">//执行函数名</span></span><br><span class="line">sigemptyset(&amp;new.sa_mask);      <span class="comment">//清空捕捉屏蔽字</span></span><br><span class="line">new.sa_flags = <span class="number">0</span>;               <span class="comment">//0 默认操作(屏蔽本信号)设置捕捉屏蔽字</span></span><br></pre></td></tr></table></figure>

<p><em>函数原型(详解struct sigaction)</em></p>
<pre><code class="c">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);

struct sigaction
&#123;
    1:
    void        (*sa_handler)(int);
    //指定信号捕捉后的处理函数名(即注册函数)。也可赋值为 SIG_IGN表忽略 或 SIG_DFL 表执行默认动作
            
    2:
    sigset_t    sa_mask;
    //sa_mask: 调用信号处理函数时，所要屏蔽的信号集合(信号屏蔽字)。注意：仅在处理函数被调用期间屏蔽生效，是临时性设置
            
    3:
    int         sa_flags;
    //sa_flags：通常设置为 0，表使用默认属性
    //重启函数 SA_INTERRURT 不重启。 SA_RESTART 重启
            
    other:
    //      void  (*sa_sigaction )(int, siginfo_t *, void *);(进程间通信)
    //      void  (*sa_restorer)(void);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title>C11泛型选择</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-03-21-c11%E6%B3%9B%E5%9E%8B%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>参考<br><a href="https://zhuanlan.zhihu.com/p/66029308">【Just For Fun】C - 宏开发 - _Generic() 泛型</a></p>
<h1 id="Generic-语法："><a href="#Generic-语法：" class="headerlink" title="_Generic() 语法："></a>_Generic() 语法：</h1><blockquote>
<p>_Generic ( controlling-expression , association-list ) </p>
</blockquote>
<blockquote>
<p>其中 association-list 為：type-name : expression &#x2F; default : expression 。<br>—— 简单来说，即是：<br>_Generic(<var>, <type1> : <exp1>, <type2> : <exp2>, …) 。</p>
</blockquote>
<h1 id="Generic-特性"><a href="#Generic-特性" class="headerlink" title="_Generic () 特性"></a>_Generic () 特性</h1><blockquote>
<p>_Generic() 是编译期的。</p>
</blockquote>
<blockquote>
<p>default 非必要。</p>
</blockquote>
<blockquote>
<p>如果类型列表中找不到对应的类型，并且没有 default，会出现编译错误。此关键字为c11新添加的关键字,会匹配第一个参数的类型,并返回自定义返回值.</p>
</blockquote>
<h1 id="例"><a href="#例" class="headerlink" title="例"></a>例</h1><p>例一:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GENERAL_ABS(x) _Generic((x),int:abs,float:fabsf,double:fabs)(x)</span></span><br></pre></td></tr></table></figure>

<p>例二:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> getTypeName(x) _Generic((x), _Bool:<span class="string">&quot;_Bool&quot;</span>,\</span></span><br><span class="line"><span class="meta">    char: <span class="string">&quot;char&quot;</span>, \</span></span><br><span class="line"><span class="meta">    signed char: <span class="string">&quot;signed char&quot;</span>, \</span></span><br><span class="line"><span class="meta">    unsigned char: <span class="string">&quot;unsigned char&quot;</span>, \</span></span><br><span class="line"><span class="meta">    short int: <span class="string">&quot;short int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    unsigned short int: <span class="string">&quot;unsigned short int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    int: <span class="string">&quot;int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    unsigned int: <span class="string">&quot;unsigned int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    long int: <span class="string">&quot;long int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    unsigned long int: <span class="string">&quot;unsigned long int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    long long int: <span class="string">&quot;long long int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    unsigned long long int: <span class="string">&quot;unsigned long long int&quot;</span>, \</span></span><br><span class="line"><span class="meta">    float: <span class="string">&quot;float&quot;</span>, \</span></span><br><span class="line"><span class="meta">    double: <span class="string">&quot;double&quot;</span>, \</span></span><br><span class="line"><span class="meta">    long double: <span class="string">&quot;long double&quot;</span>, \</span></span><br><span class="line"><span class="meta">    char *: <span class="string">&quot;pointer to char&quot;</span>, \</span></span><br><span class="line"><span class="meta">    void *: <span class="string">&quot;pointer to void&quot;</span>, \</span></span><br><span class="line"><span class="meta">    int *: <span class="string">&quot;pointer to int&quot;</span>,\</span></span><br><span class="line"><span class="meta">    default: <span class="string">&quot;other&quot;</span>)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>参数</tag>
        <tag>int</tag>
        <tag>void</tag>
        <tag>char</tag>
        <tag>long</tag>
        <tag>unsigned</tag>
        <tag>generic</tag>
      </tags>
  </entry>
  <entry>
    <title>Python正则坑之findall</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-03-16-python%E6%AD%A3%E5%88%99%E5%9D%91%E4%B9%8Bfindall/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(?&lt;=\D)1(3\d&#123;9&#125;|4[57]\d&#123;8&#125;)(?=\D)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">string = <span class="string">&#x27;&#x27;&#x27;重要的事情说8130123456789遍，我的手机号是13512346789这个\，</span></span><br><span class="line"><span class="string">不是14500998765，也不是110或119 没有人是14500998765。&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">lis = re.findall(pattern, string)</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line"><span class="comment"># [&#x27;3512346789&#x27;, &#x27;4500998765&#x27;, &#x27;4500998765&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>此时对于14500998765只匹配4500998765<br>原因在于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">带有1个括号，其输出的内容就是括号匹配到的内容，而不是整个表达式所匹配到的结果。</span><br><span class="line"></span><br><span class="line">不带有括号,其输出的内容就是整个表达式所匹配到的内容。</span><br><span class="line"></span><br><span class="line">带有2个括号的，会输出几个元组,显示捕获组匹配到的内容</span><br></pre></td></tr></table></figure>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>1.尽量不要使用(多重)括号</p>
<p>2.替换findall函数为finditer函数<br>原因为</p>
<h3 id="Python对正则表达式的支持"><a href="#Python对正则表达式的支持" class="headerlink" title="Python对正则表达式的支持"></a>Python对正则表达式的支持</h3><p>Python提供了<code>re</code>模块来支持正则表达式相关操作，下面是<code>re</code>模块中的核心函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>compile(pattern, flags&#x3D;0)</td>
<td>编译正则表达式返回正则表达式对象</td>
</tr>
<tr>
<td>match(pattern, string, flags&#x3D;0)</td>
<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>search(pattern, string, flags&#x3D;0)</td>
<td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>split(pattern, string, maxsplit&#x3D;0, flags&#x3D;0)</td>
<td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td>
</tr>
<tr>
<td>sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)</td>
<td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td>
</tr>
<tr>
<td>fullmatch(pattern, string, flags&#x3D;0)</td>
<td>match函数的完全匹配（从字符串开头到结尾）版本</td>
</tr>
<tr>
<td><code>findall</code>(pattern, string, flags&#x3D;0)</td>
<td>查找字符串所有与正则表达式匹配的模式 <code>返回字符串的列表</code></td>
</tr>
<tr>
<td><code>finditer</code>(pattern, string, flags&#x3D;0)</td>
<td>查找字符串所有与正则表达式匹配的模式 <code>返回一个迭代器</code></td>
</tr>
<tr>
<td>purge()</td>
<td>清除隐式编译的正则表达式的缓存</td>
</tr>
<tr>
<td>re.I &#x2F; re.IGNORECASE</td>
<td>忽略大小写匹配标记</td>
</tr>
<tr>
<td>re.M &#x2F; re.MULTILINE</td>
<td>多行匹配标记</td>
</tr>
</tbody></table>
<p>语法替换为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = re.finditer(pattern, string)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lis:</span><br><span class="line">    <span class="built_in">print</span>(i.group())</span><br></pre></td></tr></table></figure>
<p>即可正确匹配内容</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象编程笔记</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-03-12-python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>学习资料来源于 github 热门项目</p>
<p><a href="https://github.com/jackfrued/Python-Core-50-Courses">Python-Core-50-Courses</a></p>
<p>以及</p>
<p><a href="https://github.com/jackfrued/Python-100-Days">Python-100-Days</a></p>
<p>本文仅限于初学 python 的面向对象,笔者对于面向对象思想并不十分了解,如有错误请指出.以及本文会在笔者彻底掌握后进行修正.</p>
<h1 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h1><p><code>class Student:</code><br>或<br><code>class Student(object):</code></p>
<h1 id="类内部的函数"><a href="#类内部的函数" class="headerlink" title="类内部的函数"></a>类内部的函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name=<span class="number">0</span>,age=<span class="number">0</span></span>):</span><br><span class="line">    <span class="comment"># 初始化方法</span></span><br><span class="line">    self.name=name</span><br><span class="line">    self.age=age</span><br><span class="line">    self.score=<span class="literal">None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">创建类实例化时自动执行的函数,可以为类附加属性</span></span><br><span class="line"><span class="string">参数必须包含self 其余参数如果设置默认值可以不填</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">也有种方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, **kw):</span></span><br><span class="line"><span class="string">        if &#x27;hour&#x27; in kw and &#x27;minute&#x27; in kw and &#x27;second&#x27; in kw:</span></span><br><span class="line"><span class="string">            self._hour = kw[&#x27;hour&#x27;]</span></span><br><span class="line"><span class="string">            self._minute = kw[&#x27;minute&#x27;]</span></span><br><span class="line"><span class="string">            self._second = kw[&#x27;second&#x27;]</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            tm = time.localtime(time.time())</span></span><br><span class="line"><span class="string">            self._hour = tm.tm_hour</span></span><br><span class="line"><span class="string">            self._minute = tm.tm_min</span></span><br><span class="line"><span class="string">            self._second = tm.tm_sec</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun2</span>(<span class="params">self</span>):</span><br><span class="line"><span class="comment"># 其他函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self,doing</span>):</span><br><span class="line">    <span class="built_in">print</span>(doing)</span><br></pre></td></tr></table></figure>

<h1 id="创建类的实例-对象"><a href="#创建类的实例-对象" class="headerlink" title="创建类的实例(对象)"></a>创建类的实例(对象)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    Student1=Student()  <span class="string">&#x27;&#x27;&#x27; 创建类的实例化&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h1><blockquote>
<p>通过“类.方法”调用方法，第一个参数是接收消息的对象 self，第二个参数为类中函数的参数</p>
</blockquote>
<p><code>Student.study(Student1, &#39;学习&#39;) </code></p>
<blockquote>
<p>通过“对象.方法”调用方法，点前面的对象就是接收消息的对象，只需要传入函数参数</p>
</blockquote>
<p><code>Student1.study(&#39;学习&#39;) </code></p>
<h1 id="打印对象"><a href="#打印对象" class="headerlink" title="打印对象"></a>打印对象</h1><p>类中放置 <code>__repr__</code>函数 或 <code>__str__</code>函数 可以控制打印内容</p>
<p>Python 定义了<code>__str__()</code>和<code>__repr__()</code>两种方法<code>__str__()</code>用于显示给用户，而<code>__repr__()</code>用于显示给开发人员。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>: <span class="subst">&#123;self.age&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    st=Student()</span><br><span class="line">    <span class="built_in">print</span>(st)</span><br><span class="line">    <span class="comment"># 0 0                                  定义之后</span></span><br><span class="line">    <span class="comment"># &lt;main.Person object at 0x10c941890&gt;  未定义直接打印</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>python 中 可以用</p>
<p><code>__name表示一个私有(private)属性</code>，</p>
<p><code>_name表示一个受保护(protected)属性</code></p>
<p>若</p>
<p>类 class Student 中定义一个 <code>self.__name</code>变量</p>
<p>类外部无法访问<code>st.__name</code></p>
<p>需要<code>st._Student__name</code>访问</p>
<p>而在类内部 成员函数可以直接<code>self.__name</code> 访问</p>
<blockquote>
<p>但是 python 并没有从语法上严格保证私有属性的私密性，它只是给私有的属性和方法换了一个名字来阻挠对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，我们可以对上面的代码稍作修改就可以访问到私有的</p>
</blockquote>
<h1 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h1><h2 id="property-提供外部访问方法"><a href="#property-提供外部访问方法" class="headerlink" title="@property 提供外部访问方法"></a>@property 提供外部访问方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line"><span class="comment"># 属性访问器(getter方法) - 获取__name属性</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line">    <span class="comment">#其余内容省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    st=Student(<span class="string">&quot;姓名&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(st.name)  <span class="comment">#姓名</span></span><br><span class="line">    st.name=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(st.name)  <span class="comment"># 空串</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">#装饰器 @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tag</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name + <span class="built_in">str</span>(self.age)</span><br><span class="line"><span class="built_in">print</span>(user.tag())</span><br><span class="line"><span class="comment"># print(user.tag)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tag 与其说是一个<code>函数</code>其实更像是<code>user对象的一个属性</code>，用<code>user.tag()</code>的方法获取显得不那么自然，而使用<code>@property装饰器</code>我们就可以用 user 属性的方式来得到 tag：</p>
<p>print(user.tag)</p>
</blockquote>
<h2 id="setter-预处理"><a href="#setter-预处理" class="headerlink" title="@*.setter 预处理"></a>@*.setter 预处理</h2><p>两个同名函数打上<code>@property装饰器</code>和后<code>@*.setter装饰器</code>，当把函数作为变量赋值时会触发<code>@*.setter</code>对应的函数，当把函数作为变量读取时会触发<code>@property</code>对应的函数，因此我们可以将其用于数据的预处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self,n</span>):</span><br><span class="line">        self._age = n + <span class="number">5</span></span><br><span class="line"></span><br><span class="line">user = User(<span class="string">&#x27;xiao&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">user.age = <span class="number">5</span>  <span class="comment">#加密处理  5+5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h1><p>我们可以动态为对象添加属性</p>
<h2 id="slots-限制属性"><a href="#slots-限制属性" class="headerlink" title="__slots__ 限制属性"></a><code>__slots__</code> 限制属性</h2><p>如果不希望在使用对象时动态的为对象添加属性，可以使用 Python 的<code>__slots__</code>魔法。对于 Student 类来说，可以在类中指定<code>__slots__ = (&#39;name&#39;, &#39;age&#39;)</code>，这样 Student 类的对象只能有 name 和 age 属性，如果想动态添加其他属性将会引发异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 省略</span></span><br><span class="line">    st.sex=<span class="string">&#x27;girl&#x27;</span> <span class="comment"># 出错</span></span><br></pre></td></tr></table></figure>

<h1 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h1><h2 id="staticmethod-静态方法"><a href="#staticmethod-静态方法" class="headerlink" title="@staticmethod 静态方法"></a>@staticmethod 静态方法</h2><p>之前我们在类中定义的方法都是<code>对象方法</code>，换句话说这些方法都是<code>对象可以接收的消息</code>。除了对象方法之外，类中还可以有<code>静态方法</code>和<code>类方法</code>，这两类方法是<code>发给类的消息</code>，二者并没有实质性的区别。</p>
<blockquote>
<p>第一个参数</p>
</blockquote>
<blockquote>
<p>对象方法的是 <strong>普通对象</strong></p>
</blockquote>
<blockquote>
<p>类方法的是<strong>类对象</strong></p>
</blockquote>
<blockquote>
<p>静态方法的是<strong>没有接受消息的对象</strong> #可以不和类绑定写成普通函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod   </span><span class="comment"># 静态方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;判断三条边长能否构成三角形(静态方法)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br></pre></td></tr></table></figure>

<h2 id="classmethod-类方法"><a href="#classmethod-类方法" class="headerlink" title="@classmethod 类方法"></a>@classmethod 类方法</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 属性默认为类属性（可以给直接被类本身调用）</span></span><br><span class="line">    num = <span class="string">&quot;类属性&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 实例化方法（必须实例化类之后才能被调用）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self</span>): <span class="comment"># self : 表示实例化类后的地址id</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func1&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法（不需要实例化类就可以被类本身调用）</span></span><br><span class="line">    @<span class="built_in">classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">cls</span>):  <span class="comment"># cls : 表示没用被实例化的类本身</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func2&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(cls)</span><br><span class="line">        <span class="built_in">print</span>(cls.num)</span><br><span class="line">        cls().func1()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不传递传递默认self参数的方法（该方法也是可以直接被类调用的，但是这样做不标准）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func3</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func3&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(A.num) <span class="comment"># 属性是可以直接用类本身调用的</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># A.func1() 这样调用是会报错：因为func1()调用时需要默认传递实例化类后的地址id参数，如果不实例化类是无法调用的</span></span><br><span class="line"><span class="comment"># 未实例化时调用</span></span><br><span class="line">A.func2() <span class="comment">#显示 &lt;class &#x27;__main__.A&#x27;&gt;</span></span><br><span class="line">A.func3()</span><br></pre></td></tr></table></figure>

<h1 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h1><p>面向对象的编程语言支持在已有类的基础上创建新类，从而减少重复代码的编写。</p>
<blockquote>
<p>提供继承信息的类叫做<code>父类（超类、基类）</code></p>
</blockquote>
<blockquote>
<p>得到继承信息的类叫做<code>子类（派生类、衍生类）</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;人类&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;学生类&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;老师类&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>继承的语法是在定义类的时候，在<code>类名后的圆括号中指定当前类的父类</code>。</p>
<p>如果定义一个类的时候没有指定它的父类是谁，那么<code>默认的父类是object类</code>。object 类是 Python 中的顶级类，这也就意味着<code>所有的类都是它的子类</code>，要么直接继承它，要么间接继承它。Python 语言允许多重继承，也就是说一个类可以有一个或多个父类.</p>
<h2 id="调用父类函数"><a href="#调用父类函数" class="headerlink" title="调用父类函数"></a><code>调用父类函数</code></h2><ol>
<li><code>父类名.函数名(self)</code></li>
<li><code>super().函数名()</code></li>
<li><code>super(子类名,self).函数名()</code></li>
</ol>
<p>注意:<code>1和super不能混用</code><br>例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">    A.__init__(self)   <span class="comment">#第一种方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()<span class="comment">#第二种</span></span><br><span class="line">        <span class="built_in">super</span>(C,self).__init__()<span class="comment">#第三种</span></span><br></pre></td></tr></table></figure>

<h2 id="abstractmethod-用于继承或子类重写"><a href="#abstractmethod-用于继承或子类重写" class="headerlink" title="@abstractmethod 用于继承或子类重写"></a>@abstractmethod 用于继承或子类重写</h2><p>创建元类,子类必须重写(不能创建类对象,须继承重写)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用一</span><br><span class="line"></span><br><span class="line">创建一个基类,用于其他类继承 ,本身不能创建对象</span><br><span class="line"></span><br><span class="line">使用二</span><br><span class="line"></span><br><span class="line">在类中修饰一种方法,在子类中重写方法</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很显然，后续的代码不会创建 Employee 类的对象，因为我们需要的是具体的员工对象，所以这个类可以设计成专门用于继承的抽象类。Python 中没有定义抽象类的关键字，但是可以通过 abc 模块中名为 ABCMeta 的元类来定义抽象类。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span>(<span class="built_in">object</span>, metaclass=ABCMeta):<span class="comment"># 方法一</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="comment"># @abstractmethod   #方法二</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">voice</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># pass</span></span><br></pre></td></tr></table></figure>

<h1 id="类属性的读写删除控制"><a href="#类属性的读写删除控制" class="headerlink" title="类属性的读写删除控制"></a>类属性的读写删除控制</h1><p>1.只有<code>@property</code>表示<code>只读</code></p>
<p>2.同时有<code>@property</code>和<code>@*.setter</code>表示<code>可读可写</code></p>
<p>3.同时有<code>@property</code>和 <code>@*.setter</code> 和 <code>@*.deleter</code>表示<code>可读可写可删除</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#下面开始定义属性，3个函数的名字要一样！</span></span><br><span class="line"><span class="meta">    @property </span><span class="comment">#读</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"><span class="meta">    @name.setter </span><span class="comment">#写</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.__name=value</span><br><span class="line"><span class="meta">    @name.deleter </span><span class="comment">#删除</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self.__name</span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line"><span class="built_in">print</span> a.name <span class="comment">#读</span></span><br><span class="line">a.name=<span class="string">&#x27;python&#x27;</span>  <span class="comment">#写</span></span><br><span class="line"><span class="built_in">print</span> a.name <span class="comment">#读</span></span><br><span class="line"><span class="keyword">del</span> a.name <span class="comment">#删除</span></span><br><span class="line"><span class="comment"># print a.name</span></span><br><span class="line"><span class="comment"># a.name已经被删除</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;A&#x27; object has no attribute &#x27;_A__name</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Suite(Enum):</span><br><span class="line">    Int,Char,Double=0,1,2</span><br><span class="line">for suite in Suite:</span><br><span class="line">    print(suite , suite.value)</span><br></pre></td></tr></table></figure>

<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>用于比较类之间大小等</p>
<blockquote>
<p>排序需要比较两个 Card<code>对象</code>大小，而<code>&lt;运算符</code>又不能直接<code>作用于Card类型</code>，所以就出现了 TypeError 异常，异常消息为：’&lt;’ not supported between instances of ‘Card’ and ‘Card’。</p>
</blockquote>
<p>Python 中要实现对&lt;运算符的重载，需要在类中添加一个名为<strong>lt</strong>的魔术方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__lt__  --&gt;  &lt;</span><br><span class="line">__gt__  --&gt;  &gt;</span><br><span class="line">__le__  --&gt;  &lt;=</span><br><span class="line">__ge__  --&gt;  &gt;=</span><br><span class="line">__eq__  --&gt;  ==</span><br><span class="line">__ne__  --&gt;  !=</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>面向对象</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>实现自己的Ls命令</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-03-07-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84ls%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>&#x2F;&#x2F;目前已完成</p>
<p>&#x2F;&#x2F; -a -l -R 随机组合(包括-R 根目录)</p>
<p>&#x2F;&#x2F;目录蓝色 普通文件白色 链接文件浅蓝色</p>
<p>&#x2F;&#x2F;文件名称快速排序顺序显示</p>
<p>&#x2F;&#x2F;实现输出格式对齐</p>
<p>&#x2F;&#x2F;原理为字符串拼接</p>
<p>&#x2F;&#x2F;屏蔽 ctrl+c</p>
<p>&#x2F;&#x2F;将编译得到的可执行文件放置于&#x2F;usr&#x2F;bin&#x2F;目录下即可在任何目录下使用本命令</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>[hide]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILES 51200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCHAR 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSNONE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSA 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSL 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSI 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 8</span></span><br><span class="line"><span class="comment">//目前已完成</span></span><br><span class="line"><span class="comment">// -a -l -R 随机组合(包括-R根目录)</span></span><br><span class="line"><span class="comment">//目录蓝色 普通文件白色 链接文件浅蓝色</span></span><br><span class="line"><span class="comment">//文件名称快速排序顺序显示</span></span><br><span class="line"><span class="comment">//实现输出格式对齐</span></span><br><span class="line"><span class="comment">//原理为字符串拼接</span></span><br><span class="line"><span class="comment">//屏蔽ctrl+c</span></span><br><span class="line"><span class="comment">//将编译得到的可执行文件放置于/usr/bin/目录下即可在任何目录下使用本命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//seeerorr</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myerror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *error_string, <span class="type">int</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;line:%d   &quot;</span>, line);</span><br><span class="line">    perror(error_string);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">color_print</span><span class="params">(<span class="type">char</span> *colorkind, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//彩色打印</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(colorkind, <span class="string">&quot;blue&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(BLUE &quot;%-s&quot; NONE, name);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\e[0;34m&quot;</span></span><br><span class="line">               <span class="string">&quot;%-s&quot;</span></span><br><span class="line">               <span class="string">&quot;\e[0m&quot;</span>,</span><br><span class="line">               name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(colorkind, <span class="string">&quot;white&quot;</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(colorkind, <span class="string">&quot;&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-s&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(colorkind, <span class="string">&quot;lightblue&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\e[1;34m&quot;</span></span><br><span class="line">               <span class="string">&quot;%-s&quot;</span></span><br><span class="line">               <span class="string">&quot;\e[0m&quot;</span>,</span><br><span class="line">               name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(colorkind, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct stat</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    __mode_t st_mode;   /* File mode.  */</span></span><br><span class="line"><span class="comment">//__uid_t st_uid;          /* User ID of the file&#x27;s owner.	*/</span></span><br><span class="line"><span class="comment">//__gid_t st_gid;          /* Group ID of the file&#x27;s group.*/</span></span><br><span class="line"><span class="comment">//__off_t st_size;         /* Size of file, in bytes.  */</span></span><br><span class="line"><span class="comment">//struct timespec st_atim; /* Time of last access.  */访问</span></span><br><span class="line"><span class="comment">//struct timespec st_mtim; /* Time of last modification.  */修改</span></span><br><span class="line"><span class="comment">//struct timespec st_ctim; /* Time of last status change.  */更改</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">S_ISDIR(mode) __S_ISTYPE((mode), __S_IFDIR)//目录文件</span></span><br><span class="line"><span class="comment">S_ISCHR(mode) __S_ISTYPE((mode), __S_IFCHR)//字符设备文件</span></span><br><span class="line"><span class="comment">S_ISBLK(mode) __S_ISTYPE((mode), __S_IFBLK)//块设备文件</span></span><br><span class="line"><span class="comment">S_ISREG(mode) __S_ISTYPE((mode), __S_IFREG)//一般文件</span></span><br><span class="line"><span class="comment">S_ISFIFO(mode) __S_ISTYPE((mode), __S_IFIFO)</span></span><br><span class="line"><span class="comment">S_ISLNK(mode) __S_ISTYPE((mode), __S_IFLNK)//符号链接</span></span><br><span class="line"><span class="comment">S_ISSOCK(mode)//是否为socket</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;%s&quot;, ctime(&amp;f.st_mtim));</span></span><br><span class="line"><span class="comment">//mon jan 25 23:35:09 2021\n\0</span></span><br><span class="line"><span class="comment">//printf(&quot;%o&quot;,f.st_mode);33279-&gt;100 777</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rlen = MAXCHAR; <span class="comment">//本行剩余长度</span></span><br><span class="line"><span class="type">int</span> maxlen;         <span class="comment">//最长文件名长度</span></span><br><span class="line"><span class="type">char</span> colorkind[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">strqsort</span><span class="params">(<span class="type">char</span> *before[PATH_MAX], <span class="type">int</span> now[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = l, k = r;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = now[l];</span><br><span class="line">        <span class="keyword">while</span> (l != r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">strcmp</span>(before[now[r]], before[temp]) &gt;= <span class="number">0</span>)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="comment">//p[l] = p[r];</span></span><br><span class="line">            now[l] = now[r];</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; <span class="built_in">strcmp</span>(before[now[l]], before[temp]) &lt;= <span class="number">0</span>)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="comment">//p[r] = p[l];</span></span><br><span class="line">            now[r] = now[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r == l)</span><br><span class="line">            now[r] = temp;</span><br><span class="line"></span><br><span class="line">        strqsort(before, now, r + <span class="number">1</span>, k);</span><br><span class="line">        strqsort(before, now, j, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出一个文件名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">singlename</span><span class="params">(<span class="keyword">struct</span> stat a, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断本行是否足够打印</span></span><br><span class="line">    <span class="keyword">if</span> (rlen &lt; maxlen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        rlen = MAXCHAR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确定颜色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件类型</span></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(a.st_mode))</span><br><span class="line">        <span class="built_in">strcpy</span>(colorkind, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(a.st_mode))</span><br><span class="line">        <span class="built_in">strcpy</span>(colorkind, <span class="string">&quot;white&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(a.st_mode))</span><br><span class="line">        <span class="built_in">strcpy</span>(colorkind, <span class="string">&quot;lightblue&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISCHR(a.st_mode))</span><br><span class="line">        <span class="built_in">strcpy</span>(colorkind, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(a.st_mode))</span><br><span class="line">        <span class="built_in">strcpy</span>(colorkind, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISFIFO(a.st_mode))</span><br><span class="line">        <span class="built_in">strcpy</span>(colorkind, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISSOCK(a.st_mode))</span><br><span class="line">        <span class="built_in">strcpy</span>(colorkind, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    color_print(colorkind, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空格补齐</span></span><br><span class="line">    <span class="type">int</span> kong = maxlen - <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kong; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//留2个空隙</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    rlen -= (maxlen + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -l打印一行  没有名字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lenname</span><span class="params">(<span class="keyword">struct</span> stat a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">g</span>;</span></span><br><span class="line">    <span class="type">char</span> mtime[<span class="number">32</span>];</span><br><span class="line">    p = getpwuid(a.st_uid);</span><br><span class="line">    g = getgrgid(a.st_gid);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || g == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        myerror(<span class="string">&quot;p||g is NULL\n&quot;</span>, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//文件类型</span></span><br><span class="line">        <span class="comment">//        S_ISUID 04000 文件的(set user - id on execution)</span></span><br><span class="line">        <span class="comment">//        S_ISGID 02000 文件的(set group - id on execution)</span></span><br><span class="line">        <span class="comment">//        S_ISVTX 01000 文件的sticky 位</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(a.st_mode))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(a.st_mode))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(a.st_mode))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISCHR(a.st_mode))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(a.st_mode))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISFIFO(a.st_mode))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISSOCK(a.st_mode))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所有者权限</span></span><br><span class="line">    <span class="keyword">if</span> (a.st_mode &amp; S_IRUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.st_mode &amp; S_IWUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.st_mode &amp; S_IXUSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISUID&amp;a.st_mode)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISUID&amp;a.st_mode)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;S&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同组用户权限</span></span><br><span class="line">    <span class="keyword">if</span> (a.st_mode &amp; S_IRGRP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.st_mode &amp; S_IWGRP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.st_mode &amp; S_IXGRP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISGID&amp;a.st_mode)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISGID&amp;a.st_mode)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;S&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他用户权限</span></span><br><span class="line">    <span class="keyword">if</span> (a.st_mode &amp; S_IROTH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.st_mode &amp; S_IWOTH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.st_mode &amp; S_IXOTH)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISVTX&amp;a.st_mode)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISVTX&amp;a.st_mode)</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;T&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//link</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%4ld  &quot;</span>, a.st_nlink);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//uid gid</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-8s &quot;</span>, p-&gt;pw_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-8s &quot;</span>, g-&gt;gr_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//size</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-8ld &quot;</span>, a.st_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mtime</span></span><br><span class="line">    <span class="built_in">strcpy</span>(mtime, ctime(&amp;a.st_mtime)); <span class="comment">//mon jan 25 23:35:09 2021\n\0</span></span><br><span class="line">    mtime[<span class="built_in">strlen</span>(mtime) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s  &quot;</span>, mtime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析文件路径并修正</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">isrightfile</span><span class="params">(<span class="type">char</span> *fakepath)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stat));</span><br><span class="line">    <span class="comment">//目录补全   正误勘别</span></span><br><span class="line">    <span class="keyword">if</span> (lstat(fakepath, &amp;a) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, fakepath);</span><br><span class="line">        myerror(<span class="string">&quot;lstat&quot;</span>, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(a.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fakepath[<span class="built_in">strlen</span>(fakepath) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fakepath[<span class="built_in">strlen</span>(fakepath)] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            fakepath[<span class="built_in">strlen</span>(fakepath) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return fakepath;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">explainfakepath</span><span class="params">(<span class="type">char</span> *argv, <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入 预期</span></span><br><span class="line">    <span class="comment">//  (1)/a</span></span><br><span class="line">    <span class="comment">//  (2)     ./   ||    .</span></span><br><span class="line">    <span class="comment">//  (3) abc---&gt;(./abc)</span></span><br><span class="line">    <span class="comment">//  (4)  ./abc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) <span class="comment">//单独目录(1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(path, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(argv, <span class="string">&quot;./&quot;</span>)) <span class="comment">//(2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(path, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(argv, <span class="string">&quot;./&quot;</span>, <span class="number">2</span>) &amp;&amp; <span class="built_in">strlen</span>(argv) != <span class="number">2</span>) <span class="comment">//(4)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(path, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//(3)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(path, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(path, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    isrightfile(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对文件处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lsfile</span><span class="params">(<span class="type">int</span> kind, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//name是所有路径</span></span><br><span class="line">    <span class="comment">//nname是去除隐藏文件的所有路径</span></span><br><span class="line">    <span class="comment">//temp是文件名</span></span><br><span class="line">    <span class="comment">//name--&gt;nname-&gt;temp</span></span><br><span class="line">    <span class="type">char</span> nfilename[PATH_MAX];</span><br><span class="line">    <span class="built_in">memset</span>(nfilename, <span class="number">0</span>, PATH_MAX);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;st, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stat));</span><br><span class="line">    <span class="type">int</span> wei = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> temp[PATH_MAX];</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0</span>, PATH_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到最后一个/</span></span><br><span class="line">    wei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(name); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (name[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            wei = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理a  name得到nname</span></span><br><span class="line">    <span class="keyword">if</span> (kind &amp; LSA)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(nfilename, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (name[wei] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(nfilename, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(nfilename) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到文件名</span></span><br><span class="line">    <span class="built_in">strncpy</span>(temp, &amp;nfilename[wei], <span class="built_in">strlen</span>(nfilename) - wei);</span><br><span class="line">    temp[<span class="built_in">strlen</span>(nfilename) - wei] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    lstat(nfilename, &amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定显示方式  l</span></span><br><span class="line">    <span class="keyword">if</span> (kind &amp; LSL)</span><br><span class="line">    &#123;</span><br><span class="line">        lenname(st);</span><br><span class="line">        singlename(st, temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        rlen = MAXCHAR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        singlename(st, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对目录处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lsdir</span><span class="params">(<span class="type">int</span> kind, <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;1\n&quot;);</span></span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获得最长文件名</span></span><br><span class="line">    dir = opendir(path);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//myerror(&quot;opendir&quot;, __LINE__);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((p = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxlen &lt; <span class="built_in">strlen</span>(p-&gt;d_name))</span><br><span class="line">            maxlen = <span class="built_in">strlen</span>(p-&gt;d_name);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAXFILES)</span><br><span class="line">        myerror(<span class="string">&quot;two many files&quot;</span>, __LINE__);</span><br><span class="line">    <span class="comment">//存储文件名 path+name</span></span><br><span class="line">    dir = opendir(path);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>)</span><br><span class="line">        myerror(<span class="string">&quot;opendir&quot;</span>, __LINE__);</span><br><span class="line">    <span class="type">int</span> lenpath = <span class="built_in">strlen</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **filename = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * count);</span><br><span class="line">    <span class="keyword">if</span> (filename == <span class="literal">NULL</span>)</span><br><span class="line">        myerror(<span class="string">&quot;malloc failed&quot;</span>, __LINE__);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span> *)filename, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span> *) * count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        filename[i] = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * PATH_MAX);</span><br><span class="line">        <span class="keyword">if</span> (filename[i] == <span class="literal">NULL</span>)</span><br><span class="line">            myerror(<span class="string">&quot;malloc  i failed&quot;</span>, __LINE__);</span><br><span class="line">        <span class="built_in">memset</span>(filename[i], <span class="number">0</span>, PATH_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = readdir(dir);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">            myerror(<span class="string">&quot;readdir&quot;</span>, __LINE__);</span><br><span class="line">        <span class="comment">//path+name</span></span><br><span class="line">        <span class="built_in">strncpy</span>(filename[i], path, lenpath);</span><br><span class="line">        filename[i][lenpath] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcat</span>(filename[i], p-&gt;d_name);</span><br><span class="line">        filename[i][lenpath + <span class="built_in">strlen</span>(p-&gt;d_name)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="type">int</span> teemp[count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        teemp[i] = i;</span><br><span class="line">    strqsort(filename, teemp, <span class="number">0</span>, count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        lsfile(kind, filename[teemp[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (filename[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(filename[i]);</span><br><span class="line">            filename[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有-l就换行</span></span><br><span class="line">    <span class="keyword">if</span> (!(kind &amp; LSL))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (filename)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(filename);</span><br><span class="line">        filename = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断隐藏?</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ifhidefile</span><span class="params">(<span class="type">char</span> *path)</span> <span class="comment">//原path+filename 目录后无/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wei = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(path); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            wei = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path[wei] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历目录下所有文件夹</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">geteverydir</span><span class="params">(<span class="type">int</span> kind, <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  1.ls path</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, path);</span><br><span class="line">    lsdir(kind, path);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count</span></span><br><span class="line">    DIR *dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="type">int</span> dircount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> hidedircount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rightcount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//    char *filename[MAXFILES];</span></span><br><span class="line">    dir = opendir(path);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span> || errno == EACCES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; MAXFILES; i++)</span></span><br><span class="line">        <span class="comment">//    free(filename[i]);</span></span><br><span class="line">        <span class="comment">//return;</span></span><br><span class="line">        <span class="comment">//myerror(&quot;opendir &quot;, __LINE__);</span></span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;opendir &quot;</span>);</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((p = readdir(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxlen &lt; <span class="built_in">strlen</span>(p-&gt;d_name))</span><br><span class="line">        &#123;</span><br><span class="line">            maxlen = <span class="built_in">strlen</span>(p-&gt;d_name);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAXFILES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; MAXFILES; i++)</span></span><br><span class="line">        <span class="comment">//    free(filename[i]);</span></span><br><span class="line">        <span class="comment">//free(filename);</span></span><br><span class="line">        myerror(<span class="string">&quot;two many files&quot;</span>, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    dir = opendir(path);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span> || errno == EACCES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; MAXFILES; i++)</span></span><br><span class="line">        <span class="comment">//    free(filename[i]);</span></span><br><span class="line">        <span class="comment">//return;</span></span><br><span class="line">        <span class="comment">//myerror(&quot;opendir &quot;, __LINE__);</span></span><br><span class="line"></span><br><span class="line">        perror(<span class="string">&quot;opendir &quot;</span>);</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lenpath = <span class="built_in">strlen</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **filename = (<span class="type">char</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span> *) * count);</span><br><span class="line">    <span class="keyword">if</span> (filename == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        myerror(<span class="string">&quot;malloc &quot;</span>, __LINE__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(filename, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span> *) * count);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stat));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        filename[i] = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * PATH_MAX);</span><br><span class="line">        <span class="keyword">if</span> (filename[i] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            myerror(<span class="string">&quot;malloc &quot;</span>, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(filename[i], <span class="number">0</span>, PATH_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = readdir(dir);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(filename[i], <span class="number">0</span>, PATH_MAX);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(p-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(filename[i], <span class="number">0</span>, PATH_MAX);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// path+file-/</span></span><br><span class="line">        <span class="comment">//dircount rightcount</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf(&quot;%s\n%s\n&quot;, filename[i], path);</span></span><br><span class="line">        <span class="built_in">strncpy</span>(filename[i], path, lenpath);</span><br><span class="line">        filename[i][lenpath] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcat</span>(filename[i], p-&gt;d_name);</span><br><span class="line">        filename[i][lenpath + <span class="built_in">strlen</span>(p-&gt;d_name)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stat));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lstat(filename[i], &amp;a) == <span class="number">-1</span> || errno == EACCES)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">            <span class="comment">//myerror(&quot;lstat&quot;, __LINE__);</span></span><br><span class="line">            perror(<span class="string">&quot;lstat&quot;</span>);</span><br><span class="line">            errno = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(a.st_mode))</span><br><span class="line">        &#123;</span><br><span class="line">            dircount++; <span class="comment">//无. ..</span></span><br><span class="line">            <span class="keyword">if</span> (ifhidefile(filename[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                hidedircount++;</span><br><span class="line">                <span class="keyword">if</span> (!(kind &amp; LSA)) <span class="comment">//要隐藏</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">memset</span>(filename[i], <span class="number">0</span>, PATH_MAX);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(filename[i])) <span class="comment">//不是隐藏</span></span><br><span class="line">            &#123;</span><br><span class="line">                filename[i][<span class="built_in">strlen</span>(filename[i])] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">                filename[i][<span class="built_in">strlen</span>(filename[i]) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//不是目录</span></span><br><span class="line">            <span class="built_in">memset</span>(filename[i], <span class="number">0</span>, PATH_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (kind &amp; LSA)</span><br><span class="line">        rightcount = dircount;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rightcount = dircount - hidedircount;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="type">int</span> teemp[count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">        teemp[i] = i;</span><br><span class="line"></span><br><span class="line">    strqsort(filename, teemp, <span class="number">0</span>, count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, rightcount);</span></span><br><span class="line">    <span class="comment">//&amp;&amp; filename[teemp[i]][strlen(filename[teemp[i]]) - 1] == &#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strlen</span>(filename[teemp[i]]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rightcount &amp;&amp; <span class="built_in">strlen</span>(filename[teemp[i]]))</span><br><span class="line">        &#123;</span><br><span class="line">            maxlen = <span class="number">0</span>;</span><br><span class="line">            rlen = MAXCHAR;</span><br><span class="line">            rightcount--;</span><br><span class="line">            geteverydir(kind, filename[teemp[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, filename[teemp[i]]);</span><br><span class="line">            lsdir(kind, filename[teemp[i]]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (filename[i] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(filename[i]);</span><br><span class="line">            filename[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (filename != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(filename);</span><br><span class="line">        filename = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理路径 解析参数 分类状态处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dealpath</span><span class="params">(<span class="type">int</span> kind, <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">a</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stat));</span><br><span class="line">    <span class="keyword">if</span> (lstat(path, &amp;a) == <span class="number">-1</span> || errno == EACCES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, path);</span><br><span class="line">        perror(<span class="string">&quot;lstat&quot;</span>);</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//myerror(&quot;lstat&quot;, __LINE__);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(a.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (kind &amp; LSR)</span><br><span class="line">            geteverydir(kind, path);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, path);</span><br><span class="line">            lsdir(kind, path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:\n&quot;</span>, path);</span><br><span class="line">        lsfile(kind, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//srand((unsigned int)time(NULL));</span></span><br><span class="line">    <span class="comment">//char path[PATH_MAX];</span></span><br><span class="line">    <span class="type">char</span> *path = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * PATH_MAX);</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * PATH_MAX);</span><br><span class="line">    <span class="type">int</span> kind = LSNONE;</span><br><span class="line">    <span class="type">int</span> pathnumber = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//struct stat a;</span></span><br><span class="line">    <span class="comment">//int mode[250] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">//char temppath[PATH_MAX];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现ctrl+c处理</span></span><br><span class="line">    signal(SIGINT, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析kind  -laR</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> argvlen = <span class="built_in">strlen</span>(argv[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; argvlen; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (argv[i][j] == <span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kind |= LSL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (argv[i][j] == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kind |= LSA;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (argv[i][j] == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    kind |= LSR;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    myerror(<span class="string">&quot;不支持的参数&quot;</span>, __LINE__);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pathnumber++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ls 不带路径(包含参数处理)</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span> || pathnumber == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(path, <span class="string">&quot;./&quot;</span>);</span><br><span class="line">        <span class="comment">//lsdir(kind, path);</span></span><br><span class="line">        dealpath(kind, path);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (path != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">free</span>(path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析多路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(path, <span class="number">0</span>, PATH_MAX);</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) <span class="comment">//不支持路径名带&#x27;-&#x27;</span></span><br><span class="line">            explainfakepath(argv[i], path);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        dealpath(kind, path);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        maxlen = <span class="number">0</span>;</span><br><span class="line">        rlen = MAXCHAR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内容可能已经不是最新,最新内容查看<br><a href="https://github.com/ajian2002/cpptest/blob/master/items/big_items/linuxc/shell%26%26ls/lsyh.c">lsyh.c</a><br>[&#x2F;hide]</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ls</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux2018-2020面试题知识点总结</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-02-28-linux2018-2020%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要对于往年小组纳新必考的知识点进行归类,总结与归纳,更多细节请自行学习了解</p>
<h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><ol>
<li><p><a href="https://pan.yegetables.com/s/ZBHp">西邮 Linux 兴趣小组 2018 纳新试题(点击下载)</a></p>
</li>
<li><p><a href="https://pan.yegetables.com/s/5oTn">西邮 Linux 兴趣小组 2019 纳新试题(点击下载)</a></p>
</li>
<li><p><a href="https://pan.yegetables.com/s/pXhg">西邮 Linux 兴趣小组 2020 纳新试题(点击下载)</a></p>
</li>
</ol>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ul>
<li><p>二维数组下标以及对应值的关系(包括但不限于下标为-1 ,以及从 0 开始等)</p>
</li>
<li><p><strong>二维数组的地址存储方式以及系统寻址方式</strong></p>
<ul>
<li>对于 <code>一维数组</code> ， <code> 1[array] == array[1]</code></li>
<li>对于<code>二维数组</code> array [m] [n] ，元素 array [i] [j] 的地址是<code>(*arr) + i * N + j</code> , <code>(-1)[array][5])就是array[-1][5]</code>，即值为<code>* ((*array) + (-1)* N + 5)</code>,<code>1[array][2]</code>为<code>* ((*array) + 1* N + 2)</code></li>
</ul>
</li>
<li><p>strlen从所给void*开始向后寻找 <code>\0</code> 返回位数</p>
</li>
<li><p>sizeof 给指针,返回指针的大小 一般为8 ;若给定数组名,返回数组所占的整体大小空间,比如 <code>int a[6][4];sizeof(a)=6*4*sizeof(int)=96</code></p>
</li>
<li><p>赋值表达式的返回值是左值</p>
</li>
<li><p>字符串”\0101\xb2” 其实是一个八进制 <code>\010</code> 和 字符 <code>1</code> ,转移字符 ‘&#39; ,字符串’xb2’ ,没有十六进制,一共六个字符</p>
</li>
<li><p>对 sizeof() 的处理都是在编译阶段进行。编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。</p>
</li>
<li><p>sizeof也可以对一个函数调用求值，其结果是函数返回类型的大小，函数并不会被调用</p>
</li>
<li><p>static 以及 全局变量局部变量的作用域及生存周期问题  详情查看[C Primer Plus 12.1章内容]<br><img src="https://tu.yegetables.com/images/2021/08/24/20210824113245.png" alt="image-20210824113238162"></p>
</li>
<li><pre><code> 未经初始化的静态全局变量会被程序自动初始化为0, 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；静态变量都在全局数据区分配内存
</code></pre>
</li>
<li><pre><code> 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；
</code></pre>
</li>
<li><pre><code> 静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
</code></pre>
</li>
<li><pre><code> const修饰的数据类型是指常类型，常类型的变量或对象的值是不能被更新的。
</code></pre>
</li>
<li><pre><code> const 也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int *p1;//</span><br><span class="line">int const *p2;//指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。</span><br><span class="line">int * const p3;//指针是只读的，也就是 p3 本身的值不能被修改</span><br></pre></td></tr></table></figure></li>
<li><pre><code>  &amp;a+1:代表的是加上整个数组的大小
</code></pre>
</li>
<li><p>与 ,或 ,非 运算</p>
<ul>
<li><code>与&amp;: 同时为“1”，结果才为“1”，否则为0 </code></li>
<li><code>或|: 只要有一个为1，其值为1 </code></li>
<li><code>非~: 取反</code></li>
<li><code>异或^:两个相应位为“异”（值不同），则该位结果为1，否则为0</code></li>
</ul>
</li>
<li><p>二进制中有几个 1(原理:从右往左遇到 1,将 100&amp;011 得到 000)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (unsigned int i = 0; num; i++)</span><br><span class="line">&#123;</span><br><span class="line">    num &amp;= (num - 1);</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br></pre></td></tr></table></figure>

<ul>
<li>当有’#’或’##’的时候,宏嵌套宏并不能有效的展开，此时需要多加一层宏进行转换。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define YEAR 2018</span><br><span class="line">#define LEVELONE(x) &quot;XiyouLinux &quot;#x&quot;\n&quot;</span><br><span class="line">#define LEVELTWO(x) LEVELONE(x)</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(LEVELONE(YEAR)); //XiyouLinux YEAR</span><br><span class="line">    printf(LEVELTWO(YEAR)); //XiyouLinux 2018</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>C 语言程序从源代码到形成可执行文件经过(预处理,编译,汇编,链接),</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">预处理阶段：写好的高级语言的程序文本比如hello.c,预处理器根据#开头的命令，修改原始的程序，如#include&lt;stdio.h&gt;,将把系统中的头文件插入到程序文本中，通常是以.i结尾的文件。</span><br><span class="line">编译阶段：编译器将hello.i文件翻译成文本文件hello.s,这个是汇编语言程序。高级语言是源程序。所以注意概念之间的区别。汇编语言程序干嘛？每条语句都以标准的文本格式确切描述一条低级机器语言指令。*不同的高级语言翻译的汇编语言相同。</span><br><span class="line">汇编阶段：汇编器将hello.s翻译成机器语言指令。把这些指令打包成可重定位目标程序，即.o文件。hello.o是一个二进制文件，它的字节码是机器语言指令，不再是字符。前面两个阶段都还有字符。</span><br><span class="line">链接阶段：比如hello程序调用printf程序，它是每个C编译器都会提供的标准库C的函数。这个函数存在于一个名叫printf.o的单独编译好的目标文件中，这个文件将以某种方式合并到hello.o中。链接器就负责这种合并。得到的是可执行目标文件。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>对于结构体和联合体进行 sizeof()计算需要考虑字节对齐<img src="https://tu.yegetables.com/images/2021/08/24/20210824130603.png" alt="image-20210824130603245"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof(node)=1+3()+4+2+2()=12  //int 4字节对齐  a空空空||b||c空空</span><br><span class="line">sizeof(n)=1+3()+4=8				//  a空空空||b</span><br><span class="line">*(int *)((char *)a + 2 * sizeof(struct n))=(void*)a+16=(void*)(a[1])+4=b  </span><br></pre></td></tr></table></figure></li>
<li><p>大小端</p>
<ul>
<li>大端是高字节存放到内存的低地址</li>
<li>小端是高字节存放到内存的高地址<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char n[] = &#123;2, 1, 0, 0&#125;;</span><br><span class="line">//高地址                        低地址</span><br><span class="line">//00000000 00000000 00000001 00000010//258</span><br><span class="line">//   n3       n2       n1       n0</span><br><span class="line">printf(&quot;%d\n&quot;, *(int *)n); //258</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>对于局部变量要注意外部引用的方式<img src="https://tu.yegetables.com/images/2021/08/24/20210824132215.png" alt="image-20210824132215326"></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此题p指针为空,传入func了空指针,在func中更改p指向,退出func后未保存,s还是指向NULL</span><br></pre></td></tr></table></figure>

</li>
<li><p>对于宏替换变量时要注意变量尽可能的用括号括</p>
</li>
<li><p>malloc 申请一定空间,此时空间的初始值要记得清空,calloc </p>
</li>
<li><p>数组的地址,数组中不同元素的地址,以及地址+1 的结果要区分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[4] = &#123; 2, 0, 1, 9 &#125;;</span><br><span class="line">printf(&quot;%p, %p\n&quot;, a, &amp;a);</span><br><span class="line">printf(&quot;%p, %p\n&quot;, a + 1, &amp;a + 1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归结束条件</p>
</li>
<li><p>冒泡,选择,快排</p>
</li>
<li><p>大小端的验证</p>
</li>
<li><p>数据类型的范围以及超出范围后的数值规律</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ch = 128;//char:-128~~127    -128</span><br></pre></td></tr></table></figure>
</li>
<li><p>printf 返回值(字符个数)</p>
</li>
<li><p>&lt;&lt; &gt;&gt;移位运算符</p>
</li>
<li><p>a++以及++a 的先后顺序</p>
</li>
<li><p>以上</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>小组</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim极简学习攻略</title>
    <url>/%E5%AD%A6%E4%B9%A0/2021-02-09-vim%E6%9E%81%E7%AE%80%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>笔者使用 vim 很久了,但是一直以来对于 vim 的各种配置、快捷键、插件等的接触都避讳莫深。原因很简单–麻烦。</p>
<p>但是 vim&#x2F;vi 作为任何一个 linux 系统存在的文本编辑软件,学会使用对于我们来说是非常必要的。</p>
<p>借此机会我会整理一波最快的记忆最少的 vim 使用方法。</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h2><p>命令行直接使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim + 文件名 (不存在则新建,存在则打开)</span><br></pre></td></tr></table></figure>

<h2 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h2><p>直接打开默认进入 [<code>一般模式</code>](command mode)</p>
<p><code>一般模式</code> 下按下 <code>a i o</code> 任意一个进入[<code>编辑模式</code>](insert mode)</p>
<p><code>一般模式</code> 下输入 <code>: / ?</code> 任意一个进入[<code>命令行模式</code>](command-line mode)</p>
<p>被别的模式下按下 <code>esc</code> 返回 <code>一般模式</code></p>
<h2 id="1-键位-常用"><a href="#1-键位-常用" class="headerlink" title="1.键位(常用)"></a>1.键位(常用)</h2><ul>
<li><h3 id="在一般模式下"><a href="#在一般模式下" class="headerlink" title="在一般模式下"></a>在一般模式下</h3><ul>
<li>直接输入 <code>2↓</code> 、<code>10↑</code> 等移动 其中 <code>3&lt;enter&gt;</code> 相当于 <code>3↓</code></li>
<li><code>home</code>、<code>end</code> 移动当前列最前面、最后面</li>
<li>大写 <code>G</code> 移动到最后,还有 <code>nG</code></li>
<li><code>gg</code> 移动到最前</li>
<li><code>dd</code> 删除一整行,还有 <code>ndd</code></li>
<li><code>/word</code> 当前文件中往光标下搜 word<br><code>n</code> 继续搜 、<code>N</code> 反向搜</li>
<li><code>x</code> 相当于 <code>del</code>、 <code>X</code> 相当于 <code>backspace</code><br>所以 <code>3x</code> 、 <code>10X</code></li>
<li><code>yy</code> 复制本行,还有 <code>nyy</code></li>
<li><code>dG</code> 删除直到最后一行所有</li>
<li><code>dnG</code>, <code>d1G</code> 删除知道第 n 行所有</li>
<li>本行中 <code>d0</code> 删除光标之前 <code>d$</code> 删除光标之后</li>
<li><code>ynG</code> 类似复制 <code>y1G</code> ,<code>yG</code> 复制到文件末,<code>y0</code>,<code>y$</code> 本行复制</li>
<li><code>p</code> 粘贴到下一列</li>
<li><code>u</code> 撤销 <code>&lt;ctrl&gt;+r</code>前进</li>
<li><code>.</code> 重复上个动作</li>
<li><code>&lt;ctrl&gt;+v</code> 视图模式</li>
<li><code>:wq</code>保存退出</li>
<li><code>:w filename</code> 另存为</li>
<li><code>:e!</code> 还原成初始状态</li>
</ul>
</li>
<li><h3 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a><strong><em>多文件</em></strong></h3><ul>
<li><code>:e filename</code> 再打开一个文件</li>
<li><code>:files</code> 查看已打开文件</li>
<li><code>:bn</code> <code>:bp</code> 切换文件 (<code>:bN</code>也行)</li>
<li><code>:sp</code> 垂直分割 <code>:vs</code> 水平分割</li>
<li><code>&lt;ctrl&gt;+w+w</code>切换焦点窗口</li>
</ul>
</li>
<li><h3 id="不太常用-难记"><a href="#不太常用-难记" class="headerlink" title="不太常用(难记)"></a>不太常用(难记)</h3><ul>
<li><strong><code>:1,$s/word1/word2/gc</code></strong> 解释<br>第一行 到 最后一行 之间 找 word1 替换成 word2<br>参数 c 询问用户</li>
</ul>
</li>
</ul>
<h2 id="2-配置文件-vimrc"><a href="#2-配置文件-vimrc" class="headerlink" title="2.配置文件.vimrc"></a>2.配置文件.vimrc</h2><p>.vimrc 文件放置于~&#x2F;目录下,没有则新建</p>
<p>在这里贴上我的,其他功能可以自己根据需要自行添加,更改后保存重启 vim 生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; 显示中文帮助</span><br><span class="line">if version &gt;= 603</span><br><span class="line">	    set helplang=cn</span><br><span class="line">	        set encoding=utf-8</span><br><span class="line">	endif</span><br><span class="line">&quot; 设置鼠标可用</span><br><span class="line">set mouse=a</span><br><span class="line">&quot; 显示行号</span><br><span class="line">set number</span><br><span class="line">&quot; Tab 键的宽度</span><br><span class="line">set tabstop=4</span><br><span class="line">&quot; 统一缩进为 4</span><br><span class="line">set softtabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">&quot; 不要使用 vi 的键盘模式，而是 vim 自己的</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 语法高亮</span><br><span class="line">&quot;set syntax=on</span><br><span class="line"> &quot;Ctrl-A 选中所有内容</span><br><span class="line">map &lt;silent&gt;  &lt;C-A&gt;  gg v G</span><br><span class="line">&quot;按TAB键时命令行自动补齐&quot;</span><br><span class="line">set wildmenu</span><br><span class="line">&quot;开启文件类型检查</span><br><span class="line">filetype indent on</span><br><span class="line"></span><br><span class="line">set showmatch</span><br><span class="line">&quot;光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号</span><br><span class="line">set spell spelllang=en_us</span><br><span class="line">&quot;打开英语单词的拼写检查</span><br><span class="line">set history=1000</span><br><span class="line">&quot;Vim 需要记住多少次历史操作</span><br><span class="line">set autoread</span><br><span class="line">&quot;打开文件监视。如果在编辑过程中文件发生外部改变（比如被别的编辑器编辑了），就会发出提示</span><br><span class="line"></span><br><span class="line">colorscheme elflord</span><br><span class="line">&quot;设置vim主题配色</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-插件配置与语法补全"><a href="#3-插件配置与语法补全" class="headerlink" title="3.插件配置与语法补全"></a>3.插件配置与语法补全</h2><h3 id="vim-plug"><a href="#vim-plug" class="headerlink" title="vim-plug"></a><a href="https://github.com/junegunn/vim-plug">vim-plug</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优点</span><br><span class="line">1. 易于设置：单个文件。无需样板代码。</span><br><span class="line">2. 易于使用：简洁直观的语法</span><br><span class="line">3. 超高速并行安装/更新（与任何的+job，+python，+python3，+ruby，或Neovim）</span><br><span class="line">4. 创建浅克隆，以最大程度地减少磁盘空间使用和下载时间</span><br><span class="line">5. 按需加载可加快启动时间</span><br><span class="line">6. 可以查看和回滚更新</span><br><span class="line">7. 分支/标签/提交支持</span><br><span class="line">8. 更新后挂钩</span><br><span class="line">9. 支持外部管理的插件</span><br></pre></td></tr></table></figure>

<h3 id="安装-vim-plug"><a href="#安装-vim-plug" class="headerlink" title="安装 vim-plug"></a>安装 vim-plug</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/.vim/autoload/</span><br><span class="line">cd ~/.vim/autoload/</span><br><span class="line">wget https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>

<p>或者直接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>

<p>日常使用时,在<code>~/.vimrc</code>文件增加一段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line">--------------</span><br><span class="line">&quot;插件名称</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------</span><br><span class="line">plug#end()</span><br></pre></td></tr></table></figure>

<h3 id="语法补全"><a href="#语法补全" class="headerlink" title="语法补全"></a>语法补全</h3><p><strong><em>特别(c&#x2F;c++)</em></strong><br>在命令行安装 ccls<br>例如 ubuntu : <code>sudo apt-get install ccls</code></p>
<ol>
<li>添加插件在配置文件 <code>~/.vimrc</code> 的<code>call plug#begin</code> 与 <code>plug#end() </code>中间</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>命令行直接 vim 进入界面 ,输入<code>:PlugInstall</code> 等待安装完成</p>
</li>
<li><p>打开<a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers#ccobjective-c">Language servers</a>找到自己需要的语法补全配置(c&#x2F;c++ 直接复制 ccls 的配置文件),复制到剪贴板</p>
</li>
<li><p>输入<code>:CocConfig</code> ,按 i 进入编辑模式 ,粘贴刚才复制得到的配置,多种语言配置文件以逗号隔开,最外层补上一对大括号,保存退出</p>
</li>
<li><p>测试补全效果,一般不会报错,报错自己寻找解决办法</p>
</li>
</ol>
<h1 id="尾言"><a href="#尾言" class="headerlink" title="尾言"></a>尾言</h1><p>至此,常用的 vim 使用方法已经摸索清楚了, 笔者还遇到了不同文件间的复制粘贴等问题,并且顺利找到了解决方法,希望感兴趣的读者自行摸索。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>链表部分节点递归逆序</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-12-19-%E9%93%BE%E8%A1%A8%E9%83%A8%E5%88%86%E8%8A%82%E7%82%B9%E9%80%92%E5%BD%92%E9%80%86%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在对链表进行递归逆置的学习中，了解到了递归逆置的进阶操作，即对链表的部分节点进行逆置。思路因为基于整表逆置，故顺便进行了一番学习和了解，在此感谢大佬的<a href="https://www.zhihu.com/people/labuladong">labuladong</a>的<br><a href="https://zhuanlan.zhihu.com/p/107759633">如何纯递归反转链表的一部分</a>对我的学习和帮助，推荐大家详细阅读原文，本文只是方便自己日后复习的笔记和记录，主要以详解代码为主。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="整表递归逆置"><a href="#整表递归逆置" class="headerlink" title="整表递归逆置"></a>整表递归逆置</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">reslink8</span><span class="params">(linklist *link)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果链表本身为空或者到达最后一个节点，则返回此节点本身</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!link || !link-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> link;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始递归</span></span><br><span class="line">    <span class="comment">//一直到达最后一个节点处，并将此节点返回给temp，即temp是最后一项的指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    linklist *temp = reslink8(link-&gt;next);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不要思路绕进递归里，从最外面来看，这个递归的结果就是返回一个逆置好的队列的头指针</span></span><br><span class="line">    所以每次的图应该为</span><br><span class="line">    <span class="comment">//    link(link-&gt;next ...temp)</span></span><br><span class="line">    <span class="comment">//括号代表指向关系相反</span></span><br><span class="line">    link-&gt;next-&gt;next = link;<span class="comment">//后一个节点接到自己，即图为</span></span><br><span class="line">    <span class="comment">//(link link-&gt;next .... temp)</span></span><br><span class="line"></span><br><span class="line">    link-&gt;next = <span class="literal">NULL</span>;<span class="comment">//自己指向空</span></span><br><span class="line">    <span class="comment">//temp 因为是最后一项，所以返回temp作为原链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这种非尾递归的递归来说，尽量不要把自己绕进去，要明确递归的作用和返回，在最外层对递归的后续进行处理，这样可以有效学习掌握</p>
<h2 id="前n个节点逆置"><a href="#前n个节点逆置" class="headerlink" title="前n个节点逆置"></a>前n个节点逆置</h2><p>其实对整表逆置的判断条件和后续处理更改一下就能简单实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">linklist *xia = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">renserve</span><span class="params">(linklist * link, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xia = link-&gt;next; </span><br><span class="line">        <span class="keyword">return</span> link;</span><br><span class="line">    &#125;</span><br><span class="line">    linklist *temp = renserve(link-&gt;next, n - <span class="number">1</span>);</span><br><span class="line">    link-&gt;next-&gt;next = link;</span><br><span class="line">    link-&gt;next = xia;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是判断是否到达最后一个节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!link || !link-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在每次递归的时候n-1;<br>当n&#x3D;&#x3D;1的时候意味着到达了需要逆置的最后一个节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    xia = link-&gt;next; <span class="comment">//存下一个节点的位置</span></span><br><span class="line">    <span class="keyword">return</span> link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//link还是整个链表的第一个节点，但是每次递归给link-&gt;next后面继续添加-&gt;next 所以递归中存入xia指针的link-&gt;next 实际上在最外层来看是temp后面的节点</span></span><br></pre></td></tr></table></figure>
<p>此时需要将下一个不需要逆置的节点存进一个递归不改变值的链表指针中，以便后续处理节点之间的关系<br>在此应在函数外定义一个链表指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和之前一样进行递归，每次n-1</span></span><br><span class="line"><span class="comment">//返回排序好的队列队首</span></span><br><span class="line"></span><br><span class="line">linklist *temp = renserve(link-&gt;next, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归后的图为</span></span><br><span class="line"><span class="comment">// link（link-&gt;next...temp）xia ...</span></span><br><span class="line"></span><br><span class="line">link-&gt;next-&gt;next = link;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="comment">//(link........temp)xia  </span></span><br><span class="line"></span><br><span class="line">link-&gt;next = xia;<span class="comment">//link与xia建立联系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//temp仍是反转后链表的头节点</span></span><br><span class="line"><span class="keyword">return</span> temp;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表指定区间"><a href="#反转链表指定区间" class="headerlink" title="反转链表指定区间"></a>反转链表指定区间</h2><p>因为begin（b）肯定小于end（e）<br>所以每次递归对b-1,e-1，先到达1的肯定是b，此时e相当于需要反转的项数，<br>所以函数功能就相当于再次对e项的逆置，与上种方法相同</p>
<p>但特殊的是从b到b&#x3D;1一直在递归中<br>处理完b&#x3D;1之后要对原b项到b&#x3D;1的中间的项仍然进行逆置，本函数在每次递归语句执行完成后对前一项进行处理，直到所有递归退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//表   ...... .......   link(...temp)xia</span><br><span class="line">//下标 0 ...  原b        b=1</span><br></pre></td></tr></table></figure>
<p>而每次递归语句执行完成后的前一项为link，即对link与后面的链表进行关联（有点绕，，尽量理解）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//表   ...... .......   link(...temp)xia</span><br><span class="line">//下标 0 ...  原b        b=2</span><br></pre></td></tr></table></figure>
<p>一直到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//表   ...... link....(...temp)xia</span><br><span class="line">//下标 0 ...  原b</span><br></pre></td></tr></table></figure>
<p>递归自然结束      </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">rennserve</span><span class="params">(linklist *link, <span class="type">int</span> b, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="comment">//开始逆序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> renserve(link, e);</span><br><span class="line">    &#125;</span><br><span class="line">    linklist *temp = rennserve(link-&gt;next, b - <span class="number">1</span>, e - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下仍是递归的一部分</span></span><br><span class="line">    <span class="comment">//此时链表指针如图</span></span><br><span class="line">    <span class="comment">// .....  link (... temp) xia...</span></span><br><span class="line">    <span class="comment">//因为逆序前n项函数已经对需要逆转链表与之后的普通链表进行了关联，所以此函数只需要处理temp头与link的关系</span></span><br><span class="line">   </span><br><span class="line">    link-&gt;next = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...(link ...temp)xia ..</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> link;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外层递归来说 link为新link</span></span><br><span class="line">    <span class="comment">// 。。。新link（原link 。。。temp）xia</span></span><br><span class="line">    <span class="comment">//每次对逆置链表的最左边一项与逆置链表之前的正常链表最后一项建立联系，返回后边的排好的链表，以便外层递归继续处理，最后link一次一次退回到头节点处，完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组的传参问题</title>
    <url>/c/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>各位在写c程序的时候，经常会碰到要给一个函数传递数组的情况，最经典的可能是排序函数。</p>
<p>一维数组的传参很简单</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">abc</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[])</span>;<span class="comment">//声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line">    abc(<span class="built_in">array</span>);<span class="comment">//引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下来我们来说说二维数组</p>
<p>先来一个错误示范</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a[][],<span class="type">int</span> m,<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>，a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    foo(a,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我猜大家第一次二维数组传参的防范肯定是这样</p>
<p>而编译器肯定会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.c:3:14: error: array type has incomplete element type ‘int[]’</span><br><span class="line"> void foo(int a[][], int m, int n) &#123;</span><br><span class="line">              ^</span><br><span class="line">test.c: In function ‘main’:</span><br><span class="line">test.c:12:9: error: type of formal parameter 1 is incomplete</span><br><span class="line">     foo(a, 2, 3);</span><br></pre></td></tr></table></figure>

<p>报错在处理二维数组参数a的时候，类型不兼容。</p>
<p>C语言里面对二维数组的存储是按照一维数组来处理的，二维数组按照行展开的方式按顺序存储</p>
<p>一维数组 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int b[6]=&#123;0,1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure>

<p>二维数组 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[2][3]=&#123;</span><br><span class="line">    &#123;0,1,2&#125;,</span><br><span class="line">    &#123;3,4,5&#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>他们的空间都是连续的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a: | 0 | 1 | 2 | 3 | 4 | 5 </span><br><span class="line">b: | 0 | 1 | 2 | 3 | 4 | 5 </span><br></pre></td></tr></table></figure>

<p>所以利用二维数组进行传参</p>
<p>必须告诉编译器二维数组的列数 否则无法对二维数组进行处理</p>
<p>将函数声明改为 <code>void foo(int a[][3],int m,int n)</code> 时</p>
<p>可以正常编译</p>
<h1 id="三种方法用二维数组进行传参"><a href="#三种方法用二维数组进行传参" class="headerlink" title="三种方法用二维数组进行传参"></a>三种方法用二维数组进行传参</h1><h2 id="一、二维数组的列数是个常数"><a href="#一、二维数组的列数是个常数" class="headerlink" title="一、二维数组的列数是个常数"></a>一、二维数组的列数是个常数</h2><ol>
<li></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a[][<span class="number">3</span>], <span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line">    foo(a, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">3</span>],<span class="type">int</span> m,<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>，a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    foo(a,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
将参数a声明为一个指向数组的指针</li>
</ol>
<p>声明(*a)是一个数组，等价于int b[3]时，b是一个数组。</p>
<p>又因为本来a就是一个指针，指向一个数组，类似a是指针，指向b的。<br>注意：此时仍需要指明列长度</p>
<h2 id="二、二维数组的列是一个变量"><a href="#二、二维数组的列是一个变量" class="headerlink" title="二、二维数组的列是一个变量"></a>二、二维数组的列是一个变量</h2><p>3.c </p>
<p>显然，如果二维数组的列是一个变量的话，我们没有办法用上面的两种方法进行传参并处理</p>
<p>此时我们不能把数组继续当一个二维数组，而是理解为传进去一个地址，对地址进行操作来达到对二维数组的地址进行抽象的操作</p>
<p>这里引入一个等价转换式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[i][j]= *((int*)a+lie*i+j)</span><br></pre></td></tr></table></figure>

<p>根据我之前解释的以为数组和二维数组在程序里都是一块连续的空间</p>
<p>如图</p>
<p>一维数组 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int b[6]=&#123;0,1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure>

<p>二维数组 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[2][3]=&#123;&#123;0,1,2&#125;,&#123;3,4,5&#125;&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a: | 0 | 1 | 2 | 3 | 4 | 5 </span><br><span class="line">b: | 0 | 1 | 2 | 3 | 4 | 5 </span><br></pre></td></tr></table></figure>

<p>b[4]&#x3D;&#x3D;a[1][1]</p>
<p>4&#x3D;1*3+1<br>此时的3为二维数组的列</p>
<p>因此二位数组的任意元素可以解释为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[i][j]= *((int*)a+lie*i+j)</span><br></pre></td></tr></table></figure>
<p>下面提供实现代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> **a,<span class="type">int</span> lie，<span class="type">int</span> m,<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lie=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>，*((<span class="type">int</span>*)a+lie*i+j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    foo(a,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不管怎么样，a[i][j]不被允许。也是由编译器的寻址方式决定。</p>
</blockquote>
<p>对指针的操作不止上面的一种，如下还有集中参考形式可以供读者进行自由的操作和表达，本文只是抛砖引玉，给大家提供思考的余地，也是笔者一种笔记和备忘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.*( a[i] + j)  //代表第 i 行 第 j 列</span><br><span class="line"></span><br><span class="line">1.  *( *(a+i) + j) //同上</span><br><span class="line"></span><br><span class="line">2. *( (int *) a + i*n + j )//同上，n表示第二维数组长度,即列宽</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>求最大公约数(辗转相除)代码</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-10-10-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0(%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4)%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">yue</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    r = x % y;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = r;</span><br><span class="line">        yue(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>辗转相除法</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 家庭转专业 激活码 备忘</title>
    <url>/%E7%94%9F%E6%B4%BB/win10_%E5%AE%B6%E5%BA%AD%E8%BD%AC%E4%B8%93%E4%B8%9A_%E6%BF%80%E6%B4%BB%E7%A0%81_%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<p>win10家庭版升级专业版<br>升级密钥   GQNVQ-WF7TW-2Y3V4-KTCYM-B4G6T</p>
<p>专业版密钥(支持重装)   W6788-VNX4T-F433K-39X9H-QPBQP<br>专业版密钥激活(不支持重装) J4PXD-8DNCK-Y6KP2-4TP2B-MY33Q   </p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>韩国混乱演艺圈有感-张紫妍</title>
    <url>/%E7%94%9F%E6%B4%BB/%E9%9F%A9%E5%9B%BD%E6%B7%B7%E4%B9%B1%E6%BC%94%E8%89%BA%E5%9C%88%E6%9C%89%E6%84%9F-%E5%BC%A0%E7%B4%AB%E5%A6%8D/</url>
    <content><![CDATA[<p>公众号推送的一篇文章引起我的愤懑<br><a href="https://mp.weixin.qq.com/s/tg0roMUXzlM99-wRV6PrcA">韩国财阀狗血宫斗：父子同场性侵一女星，兄弟为夺权反目撕</a><br>说的是韩国女星张紫妍事件，韩国影视圈，财阀，政府的一摊混水 ，这场景我只在小说里见过，难以想象，难以想象。</p>
<blockquote>
<p>无题<br>ajian<br>问世间可有公正？我茫茫华夏屹立。</p>
</blockquote>
<blockquote>
<p>蔡倒文续斗财阀，自上而下根难拔。</p>
</blockquote>
<blockquote>
<p>外表光鲜后阴暗，只把韭菜头来割。</p>
</blockquote>
<blockquote>
<p>小国混乱无公道，自待大国来纷扰。</p>
</blockquote>
<blockquote>
<p>乌烟瘴气满世界，唯有资本是王道。</p>
</blockquote>
<blockquote>
<p>万幸我生于华夏，恰逢来清理门户。</p>
</blockquote>
<blockquote>
<p>此处反差何惊异，只待扪心自观察。</p>
</blockquote>
<blockquote>
<p>说我粉红又如何，辩证批判真理性。</p>
</blockquote>
<blockquote>
<p>盈满屏幕橘酸味，我自安适你来骂。</p>
</blockquote>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>韩国</tag>
      </tags>
  </entry>
  <entry>
    <title>插件Square Player使用事项</title>
    <url>/%E5%8D%9A%E5%AE%A2/%E6%8F%92%E4%BB%B6Square_Player%E4%BD%BF%E7%94%A8%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>插件目录名SQP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!!!</span><br><span class="line">&lt;sqp data-163=&quot;23682511&quot;&gt;&lt;/sqp&gt;</span><br><span class="line"> !!!</span><br></pre></td></tr></table></figure>

<p>Square Player 支持以下属性，它们分别的意义是：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>至左显示</td>
</tr>
<tr>
<td>data-title</td>
<td>歌曲名，用于自定义歌曲</td>
</tr>
<tr>
<td>data-artist</td>
<td>艺术家，用于自定义歌曲</td>
</tr>
<tr>
<td>data-cover</td>
<td>专辑封面图片链接，用于自定义歌曲</td>
</tr>
<tr>
<td>data-link</td>
<td>歌曲地址，用于自定义歌曲</td>
</tr>
<tr>
<td>data-163</td>
<td>网易云音乐的 ID 或歌名，如果编写了网易云 ID，将忽略以上歌曲设置</td>
</tr>
</tbody></table>
<p>将以上属性放在 <sqp> 标签内即可生效。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>歌曲</tag>
        <tag>定义</tag>
        <tag>用于</tag>
        <tag>属性</tag>
        <tag>data-title</tag>
      </tags>
  </entry>
  <entry>
    <title>最后一课</title>
    <url>/%E7%94%9F%E6%B4%BB/%E6%9C%80%E5%90%8E%E4%B8%80%E8%AF%BE/</url>
    <content><![CDATA[<p>!!!<br><sqp data-163="1333199831" data-title="Nightglow (崩坏3印象曲)" ></sqp><br>!!!<br>姬子主题曲</p>
<p>“琪亚娜<br>当你醒来，会看到一切都变了<br>你会发现，这个世界不再美好<br>那些平凡的日常，都将一去不会<br>但是，不要放弃，永远不要放弃<br>琪亚娜，抬起头，继续前进吧<br>去吧这个不完美的故事<br>变成你所期望的样子<br>活下去，琪亚娜<br>这就是，最后一课了<br>真想…再喝一杯啊。”</p>
<p>寻人启事<br>姓名:无量塔 姬子<br>性别:女<br>年龄:29<br>身高:167CM<br>容貌特征:红发金瞳<br>2018年12月14日，只身与空之律者展开决战，惨胜之后坠入虚空，生死下落不明，失踪时身穿弑神铠甲真红月蚀，外观为红黑色。<br>望广大群众提供消息，重金酬谢<br>联系人:休伯利安清洁工</p>
<p>纵使黑云蔽日，我也要燃烧天空，带你找回回家的路。琪亚娜，去把这个不完美的故事，变成你所期望的样子！！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>崩坏3</tag>
        <tag>姬子</tag>
      </tags>
  </entry>
  <entry>
    <title>April Is Coming Without You</title>
    <url>/%E7%94%9F%E6%B4%BB/April_is_coming_without_you/</url>
    <content><![CDATA[<p>!!!<br><sqp data-163="29732992" data-title="光るなら" ></sqp><br>!!!</p>
<p>四月是你的谎言<br>熏的自述<br>三月，病房中，父母的泪滴在地上<br>下定决心奔跑</p>
<p>脱下黑框眼镜，开始肆无忌惮，不顾一切<br>也放弃了一切</p>
<p>爱了你十年，用一个四月编织了一个谎言<br>爱上你的朋友，只把你当做友人a</p>
<p>其实我早已无法自拔</p>
<p>为了你，我放弃了钢琴，选择了提琴<br>为了你，我愿意热爱这个世界<br>只愿你能伴我最后的时间</p>
<p>和你小提琴合奏<br>和你一起训练<br>一起回家<br>一起唱小星星<br>一起买东西，<br>一起送走失的孩子<br>一起走过五月六月七月八月九月十月</p>
<p>就像恋人一样<br>见证了春的繁盛<br>夏的炽热<br>秋的凉爽<br>冬的冰寒。</p>
<p>只想在你心中种下昙花，哪怕只能一现</p>
<p>别忘掉我</p>
<p>11月我很抱歉，没能与你再一次合奏<br>我再也拿不起提琴<br>倒下的我已经无法再做梦了<br>也不再做梦了<br>更不会奔跑了</p>
<p>我很抱歉<br>为了我，让你再次重面了痛苦<br>让你挣扎到了最后<br>却在痛苦时给了你丧气的话<br>突然按下奇怪的开关<br>我放心不下你<br>我想在最后的时光里<br>和你一起<br>友人a</p>
<p>12月，你的心意传达到了<br>你真的好残忍<br>让一个无法在做梦的人<br>再次做梦<br>可能这就是爱吧</p>
<p>我喜欢你友人a<br>你会忘了我吗？<br>你会记得我吗？<br>我希望能在你心中占上一席<br>那心中的昙花<br>向晚生香。<br>——《四月是你的谎言》热评</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>番</tag>
      </tags>
  </entry>
  <entry>
    <title>Typecho评论通知支持qq微信邮件</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-04-25-typecho%E8%AF%84%E8%AE%BA%E9%80%9A%E7%9F%A5%E6%94%AF%E6%8C%81qq%E5%BE%AE%E4%BF%A1%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<p>群里有大佬推荐了<a href="https://github.com/gaobinzhan/CommentPush">github</a>这个tyoechi插件，我简单说下使用，大家可以给原项目一个star支持一下。</p>
<p>下载了项目源码后在网站目录下&#x2F;usr&#x2F;plugins&#x2F;<br>目录下解压并重命名为CommentPush</p>
<h2 id="推送服务"><a href="#推送服务" class="headerlink" title="推送服务"></a>推送服务</h2><p><a href="http://sc.ftqq.com/">Server酱</a>（微信推送）</p>
<p><a href="https://qmsg.zendee.cn/">Qmsg酱</a>（qq推送）</p>
<p><a href="https://www.aliyun.com/product/directmail">阿里云邮件</a><br>（邮箱推送）</p>
<p>进去后有具体步骤，qq推送的话就是</p>
<ol>
<li>登录网站并且复制自己的接口地址。</li>
<li>添加机器人QQ好友<br>3.在网站添加自己的qq作为接受推送的qq<br>4.在网站后台启用插件，并进入设置界面。粘贴接口地址。并选择qmsg和填写相关配置。<br><a href="https://tu.yegetables.com/image/iILq"><img src="https://tu.yegetables.com/images/2020/04/25/Screenshot_20200425-122237_Chrome_Mosaic_12_22_43.jpg" alt="Screenshot_20200425-122237_Chrome_Mosaic_12_22_43.jpg"></a></li>
</ol>
<p><img src="https://tu.yegetables.com/images/2020/04/27/Screenshot_20200425-121443_Chrome_Mosaic_0_25_50.jpg" alt="Screenshot_20200425-121443_Chrome_Mosaic_0_25_50.jpg"><br>然后可以自己测试一下能否推送成功了</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>网站</tag>
        <tag>目录</tag>
        <tag>推送</tag>
        <tag>qmsg</tag>
      </tags>
  </entry>
  <entry>
    <title>宝塔突破限制安装插件</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-04-20-%E5%AE%9D%E5%A1%94%E7%AA%81%E7%A0%B4%E9%99%90%E5%88%B6%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>因为一个项目需要mysql5.7，而我是5.6<br>切换版本时宝塔因为我内存小于1560mb禁止我安装。于是按照<a href="https://www.laoyangblog.com/575.html">老杨博客</a>的方法修改了限制</p>
<p>宝塔面板最低内存和最低CPU数限制解决方法<br>方法一：修改宝塔面板&#x2F;www&#x2F;server&#x2F;panel&#x2F;class&#x2F;panelPlugin.py文件<br>A.直接使用宝塔面板的在线文件编辑工具在文件找到&#x2F;www&#x2F;server&#x2F;panel&#x2F;class&#x2F;panelPlugin.py文件。找到137行和138行中的这俩代码。用#注释，重启面板即可</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>编程</category>
        <category>博客</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>宝塔</tag>
        <tag>文件</tag>
        <tag>面板</tag>
        <tag>panel</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>Cloudflare Cdn测试</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-04-19-cloudflare_cdn%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>晚上群里有消息可以免费撸一年短域名，果断上车</p>
<blockquote>
<p>#免费域名 一年<br>本次活动免费的后缀：（其他后缀不免费）<br>.EXPERT<br>.ME<br>.LIFE<br>.WORKS<br>.GURU<br>.BUSINESS<br>.SOCIAL<br>.ROCKS<br><a href="https://www.dynadot.com/resumeboost?utm_source=Search%20Domain%20Text&utm_medium=Resume%20Boost%20Even%20Flow&utm_campaign=Resume%20Boost%202020&drefid=148">活动链接</a></p>
</blockquote>
<p>上手后很快撸到了shazi.me这个域名，同时绑定了域名服务器到cloudflare上（ps：第一次绑定还没成功，多试了几次莽成功了）</p>
<p>备注：.me域名和.tk域名一样无法备案，意味着无法绑定到国内服务器上，</p>
<p>我把它绑到了我的美国小鸡上，测试后发现加载速度极慢，于是想给他加上cdn</p>
<p>cf自带的cdn对于国外服务器来说还是很厚道的，具体看图<br>这是套了cdn<br><img src="https://tu.yegetables.com/images/2020/04/19/Screenshot_20200419-205021_Chrome_Mosaic_21_5_29.jpg" alt="Screenshot_20200419-205021_Chrome_Mosaic_21_5_29.jpg"><br>这是没套cdn<br><img src="https://tu.yegetables.com/images/2020/04/19/Screenshot_20200419-204841_Chrome_Mosaic_21_4_34.jpg" alt="Screenshot_20200419-204841_Chrome_Mosaic_21_4_34.jpg"><br>ping检测发现套了cdn比不套其实快不了多少<br>国内测速看看<br>套了cdn<br><img src="https://tu.yegetables.com/images/2020/04/19/Screenshot_20200419-205350_Chrome_Mosaic_21_5_36.jpg" alt="Screenshot_20200419-205350_Chrome_Mosaic_21_5_36.jpg"><br>没套cdn<br><img src="https://tu.yegetables.com/images/2020/04/19/20200419_205547_Mosaic_21_6_2.jpg" alt="20200419_205547_Mosaic_21_6_2.jpg"></p>
<p>综上所述，国外服务器还是套上cdn比较好，因为cf的cdn非常简单，所以建议加上</p>
<p>还没完，我又试了试国内服务器套cf的cdn检查速度<br>套了cdn<br><img src="https://tu.yegetables.com/images/2020/04/19/Screenshot_20200419-205618_Chrome_Mosaic_21_5_44.jpg" alt="Screenshot_20200419-205618_Chrome_Mosaic_21_5_44.jpg"><br>没套cdn<br><img src="https://tu.yegetables.com/images/2020/04/19/Screenshot_20200419-205706_Chrome_Mosaic_21_5_55.jpg" alt="Screenshot_20200419-205706_Chrome_Mosaic_21_5_55.jpg"></p>
<p>国内服务器套cf的cdn简直傻逼</p>
<p>综上 ，国外还是要套cdn，国内直接访问比较好（贵的cdn速度快比较好当我没说）</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>cdn</tag>
        <tag>域名</tag>
        <tag>绑定</tag>
        <tag>后缀</tag>
      </tags>
  </entry>
  <entry>
    <title>Kindle邮件传书</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-04-17-kindle%E9%82%AE%E4%BB%B6%E4%BC%A0%E4%B9%A6/</url>
    <content><![CDATA[<p>#convert<br>如果想将文档转换为Kindle内置格式（mobi），需要在邮件标题内注明convert（即邮件标题写“convert”即可），亚马逊就会为您转换为Kindle内置文档格式并发送到你的Kindle设备，阅读非常方便。转换过程可能会比较慢，5M的文档可能要等5分钟左右</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>科技</category>
      </categories>
      <tags>
        <tag>转换</tag>
        <tag>标题</tag>
        <tag>convert</tag>
        <tag>kindle</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Qq推送博客评论（已作废）</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-04-11-qq%E6%8E%A8%E9%80%81%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%EF%BC%88%E5%B7%B2%E4%BD%9C%E5%BA%9F%EF%BC%89/</url>
    <content><![CDATA[<p>#2020年4月15日，机器人被腾讯回收，教程无效</p>
<p>今天在群里发现了一个qq机器人非公开版的，应该只属于邀请使用的机器人<br><img src="https://tu.yegetables.com/images/2020/04/11/Screenshot_20200411-012456_QQ.jpg" alt="Screenshot_20200411-012456_QQ.jpg"><br>利用这个机器人我们可以做很多事情<br>ps:更新机器人添加方法，添加qq好友2854196399即可找到机器人</p>
<p>魔改插件法<br>#开始</p>
<p>1.新建推送群，添加机器人为群机器人</p>
<p>2.开启消息推送开关，生成webhook地址并复制<br><img src="https://tu.yegetables.com/images/2020/04/11/Screenshot_20200411-012642_QQ_Mosaic_1_27_21.jpg" alt="Screenshot_20200411-012642_QQ_Mosaic_1_27_21.jpg"></p>
<ol start="3">
<li>在typecho网站目录&#x2F;usr&#x2F;plugins下新建文件夹目录名Comment2IFTTT<br>里面新建文件Plugin.php<br>填写Plugin.php<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * 评论通知推送至 IFTTT Webhooks</span><br><span class="line"> *</span><br><span class="line"> * @package Comment2IFTTT</span><br><span class="line"> * @author 神代綺凜</span><br><span class="line"> * @version 1.0.0</span><br><span class="line"> * @link https://moe.best</span><br><span class="line"> */</span><br><span class="line">class Comment2IFTTT_Plugin implements Typecho_Plugin_Interface</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 激活插件方法,如果激活失败,直接抛出异常</span><br><span class="line">     *</span><br><span class="line">     * @access public</span><br><span class="line">     * @return void</span><br><span class="line">     * @throws Typecho_Plugin_Exception</span><br><span class="line">     */</span><br><span class="line">    public static function activate() &#123;</span><br><span class="line">        Typecho_Plugin::factory(&#x27;Widget_Feedback&#x27;)-&gt;comment = array(&#x27;Comment2IFTTT_Plugin&#x27;, &#x27;whSend&#x27;);</span><br><span class="line">        return _t(&#x27;请记得进入插件配置 IFTTT Webhooks key&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 禁用插件方法,如果禁用失败,直接抛出异常</span><br><span class="line">     *</span><br><span class="line">     * @static</span><br><span class="line">     * @access public</span><br><span class="line">     * @return void</span><br><span class="line">     * @throws Typecho_Plugin_Exception</span><br><span class="line">     */</span><br><span class="line">    public static function deactivate() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取插件配置面板</span><br><span class="line">     *</span><br><span class="line">     * @access public</span><br><span class="line">     * @param Typecho_Widget_Helper_Form $form 配置面板</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public static function config(Typecho_Widget_Helper_Form $form) &#123;</span><br><span class="line">        $key = new Typecho_Widget_Helper_Form_Element_Text(&#x27;whKey&#x27;, NULL, NULL, _t(&#x27;Webhooks Key&#x27;), _t(&#x27;想要获取 Webhooks key 则需要启用 &lt;a href=&quot;https://ifttt.com/maker_webhooks&quot; target=&quot;_blank&quot;&gt;IFTTT 的 Webhooks 服务&lt;/a&gt;，然后点击右上角的“Documentation”来查看&#x27;));</span><br><span class="line">        $form-&gt;addInput($key-&gt;addRule(&#x27;required&#x27;, _t(&#x27;您必须填写 Webhooks key&#x27;)));</span><br><span class="line"></span><br><span class="line">        $event = new Typecho_Widget_Helper_Form_Element_Text(&#x27;evName&#x27;, NULL, NULL, _t(&#x27;Event Name&#x27;), _t(&#x27;Webhooks 事件名&#x27;));</span><br><span class="line">        $form-&gt;addInput($event-&gt;addRule(&#x27;required&#x27;, _t(&#x27;您必须填写 Event Name&#x27;)));</span><br><span class="line"></span><br><span class="line">        $excludeBlogger = new Typecho_Widget_Helper_Form_Element_Radio(&#x27;excludeBlogger&#x27;,</span><br><span class="line">            array(</span><br><span class="line">                &#x27;1&#x27; =&gt; &#x27;是&#x27;,</span><br><span class="line">                &#x27;0&#x27; =&gt; &#x27;否&#x27;</span><br><span class="line">            ),&#x27;1&#x27;, _t(&#x27;当评论者为博主时不推送&#x27;), _t(&#x27;启用后，若评论者为博主，则不会推送至 IFTTT Webhooks&#x27;));</span><br><span class="line">        $form-&gt;addInput($excludeBlogger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 个人用户的配置面板</span><br><span class="line">     *</span><br><span class="line">     * @access public</span><br><span class="line">     * @param Typecho_Widget_Helper_Form $form</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public static function personalConfig(Typecho_Widget_Helper_Form $form) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 推送至 IFTTT Webhooks</span><br><span class="line">     *</span><br><span class="line">     * @access public</span><br><span class="line">     * @param array $comment 评论结构</span><br><span class="line">     * @param Typecho_Widget $post 被评论的文章</span><br><span class="line">     * @return $comment</span><br><span class="line">     */</span><br><span class="line">    public static function whSend($comment, $post) &#123;</span><br><span class="line">        $options = Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;Comment2IFTTT&#x27;);</span><br><span class="line"></span><br><span class="line">        $whKey = $options-&gt;whKey;</span><br><span class="line">        $evName = $options-&gt;evName;</span><br><span class="line">        $excludeBlogger = $options-&gt;excludeBlogger;</span><br><span class="line"></span><br><span class="line">        if ($comment[&#x27;authorId&#x27;] == 1 &amp;&amp; $excludeBlogger == &#x27;1&#x27;) &#123;</span><br><span class="line">            return $comment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">function http_post_json($url, $jsonStr)</span><br><span class="line">&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_POST, 1);</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_POSTFIELDS, $jsonStr);</span><br><span class="line">    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HTTPHEADER, array(</span><br><span class="line">            &#x27;Content-Type: application/json; charset=utf-8&#x27;,</span><br><span class="line">            &#x27;Content-Length: &#x27; . strlen($jsonStr)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    $response = curl_exec($ch);</span><br><span class="line">    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);</span><br><span class="line">    curl_close($ch);</span><br><span class="line"> </span><br><span class="line">    return array($httpCode, $response);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$url = &quot;https://app.qun.qq.com/cgi-bin/api/hookrobot_send?key=fb41c74bd2dff125b3c27688671e11605e31ea69&quot;;</span><br><span class="line">$jsonStr = &#x27;&#123;&quot;content&quot;: [ &#123;&quot;type&quot;:0,&quot;data&quot;:&quot;您的博客《 &#x27;.$post-&gt;title.&#x27; 》有新评论啦! \n &#x27;.$comment[&#x27;author&#x27;].&#x27; 同学说：\n「 &#x27;.$comment[&#x27;text&#x27;].&#x27; 」&quot;&#125;]&#125;&#x27;;</span><br><span class="line">http_post_json($url, $jsonStr);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return $comment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>4.在typecho后台启用插件Comment2IFTTT<br>并在插件设置中填写webhook</p>
<p>5.大功告成<br>效果图<br><img src="https://tu.yegetables.com/images/2020/04/11/Screenshot_20200411-012302_QQ.jpg" alt="Screenshot_20200411-012302_QQ.jpg"></p>
<p>ps：感谢网友：<a href="https://2890.ltd/">OkYes! 技术博客</a>提供魔改方法和插件原作者<a href="https://moe.best/">神代綺凜</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>网站</tag>
        <tag>目录</tag>
        <tag>推送</tag>
        <tag>机器人</tag>
        <tag>新建</tag>
        <tag>添加</tag>
        <tag>插件法</tag>
      </tags>
  </entry>
  <entry>
    <title>Lovelive大法好</title>
    <url>/%E7%94%9F%E6%B4%BB/lovelive%E5%A4%A7%E6%B3%95%E5%A5%BD/</url>
    <content><![CDATA[<p>μ&#96;s一路走来的这六年中，从开始的不被看好，到巨蛋的辉煌落幕，不仅在日本本地，在海外也有一定影响力，演唱会也会有影院和海外直播。<br>她们是史上第一个以声优组合名义登上红白歌会和东蛋的组合，她们是第一个以声优组合登上日本music station的组合，她们发布的音乐作品总共获得过Oricon榜10张金唱片奖，她们靠着剧场版和两季动画的BD(这还不包括游戏，周边和演唱会)荣登2015ACG作品含金量榜第一名，2015年荣登Oricon年度艺人唱片销量排行榜第8<br><img src="https://tu.yegetables.com/images/2020/04/07/90142715859292162.png" alt="90142715859292162.png"><br>还有许多许多传奇都是她们创造的，而μ’s最重要的影响并不能用数据来证明，她们为声优与偶像的融合找到了一条新道路，这才是划时代的意义所在。虽然当年偶像大师系列做过尝试，然而偶像大师并没有成功，即使这样也应该向偶像大师致敬，但μ’s不仅创造了lovelive动画的奇迹，更是作为偶像团体冲进了主流社会，红白歌会，东蛋，music station不再是二次元文化的禁区。在她们的巅峰时期，从二次元偶像团体和三次元声优相结合取得的成就来看，她们是货真价实的前无古人，史上第一</p>
<p><img src="https://tu.yegetables.com/images/2020/04/07/95817315859262302.png" alt="95817315859262302.png"></p>
<p><img src="https://tu.yegetables.com/images/2020/04/07/78723715859274842.png" alt="78723715859274842.png"></p>
<p>如今的她们每一个人都为在为了自己的事业而奋斗，虽然μ&#96;s不在了，但业界里有每个人活跃的身影，人们也不会忘记那九个人曾经创造的奇迹</p>
<p>18个人，6年，3个小队，2个次元，1个μ’s ，感谢她们为我们带来的欢乐，如果奇迹有颜色，一定是九色交织，μ’sic forever!!! 希望我们能有重逢的一天！！<br><img src="https://tu.yegetables.com/images/2020/04/07/25674815859269092.png" alt="25674815859269092.png"><br>4.1 21：00<br>伴随着果皇最后一句歌声落下，<br>东京巨蛋下起了淅淅沥沥的小雨.<br>从此以后再也没有果皇呼唤那个太阳，<br>我的心支离破碎.</p>
<p>第二天早上醒来，<br>想起的第一件事就是：<br>FL结束了.18人与我们远去了.</p>
<p>或许是冷静下来了，<br>也或许是眼泪哭干了，<br>心中还是充满着对μ’s的期待，</p>
<p>期待着九人再一次的Live，<br>期待着她们出的下一首单曲，<br>期待着我的期待会变成真的.</p>
<p>虽然知道这些不可能发生，但还是像往常一样，<br>期待着，<br>期待着，<br>期待着……</p>
<p>在我看来，μ’s永远都不会解散<br>因为，<br>μ’s一直在我们的—<br>心中.</p>
<p>μ’sic forever！！</p>
<p><img src="https://tu.yegetables.com/images/2020/04/10/snapshot_2020-04-09-22-38-07.png" alt="snapshot_2020-04-09-22-38-07.png"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>偶像</tag>
        <tag>果皇</tag>
        <tag>lovelive</tag>
      </tags>
  </entry>
  <entry>
    <title>提问的智慧</title>
    <url>/%E7%94%9F%E6%B4%BB/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    <content><![CDATA[<p>转载自<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md">github</a><br>真心觉得写的太好了</p>
<h1 id="提问的智慧"><a href="#提问的智慧" class="headerlink" title="提问的智慧"></a>提问的智慧</h1><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square" alt="PRs Welcome"></a></p>
<p><strong>How To Ask Questions The Smart Way</strong></p>
<p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p>
<p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p>
<p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html">http://www.catb.org/~esr&#x2F;faqs&#x2F;smart-questions.html</a></p>
<p>Copyleft 2001 by D.H.Grand(nOBODY&#x2F;Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p>
<p>本中文指南是基于原文 3.10 版以及 2010 年由 <a href="https://github.com/gasolin">Gasolin</a> 所翻译版本的最新翻译；</p>
<p>协助指出翻译问题，<strong>请<a href="https://github.com/ryanhanwu/smartquestions/issues/new">发 Issue</a>，或直接<a href="https://github.com/ryanhanwu/smartquestions/compare/">发 Pull Request</a> 给我。</strong></p>
<p>本文另有<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md">繁體中文版</a>。</p>
<h2 id="原文版本历史"><a href="#原文版本历史" class="headerlink" title="原文版本历史"></a><a href="https://github.com/ryanhanwu/smartquestions/blob/master/history.md">原文版本历史</a></h2><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>许多项目在他们的使用协助&#x2F;说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p>
<p><strong>本指南不提供此项目的实际支持服务！</strong></p>
<p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p>
<p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p>
<p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p>
<p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p>
<p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p>
<p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p>
<p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p>
<p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p>
<p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p>
<p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p>
<p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p>
<p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p>
<h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p>
<ol>
<li>尝试在你准备提问的论坛的旧文章中搜索答案。</li>
<li>尝试上网搜索以找到答案。</li>
<li>尝试阅读手册以找到答案。</li>
<li>尝试阅读常见问题文件（FAQ）以找到答案。</li>
<li>尝试自己检查或试验以找到答案。</li>
<li>向你身边的强者朋友打听以找到答案。</li>
<li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li>
</ol>
<p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p>
<p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 <a href="http://groups.google.com/">Google 论坛</a>，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p>
<p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p>
<p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p>
<p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p>
<p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p>
<p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p>
<h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p>
<ul>
<li>在与主题不合的论坛上贴出你的问题。</li>
<li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li>
<li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li>
<li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li>
</ul>
<p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p>
<p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p>
<p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p>
<p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p>
<p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p>
<p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p>
<p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p>
<p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p>
<h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p>
<p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p>
<p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p>
<p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p>
<ul>
<li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li>
<li>Stack Overflow 是问写程序有关的问题。</li>
<li>Server Fault 是问服务器和网管相关的问题。</li>
</ul>
<h3 id="网站和-IRC-论坛"><a href="#网站和-IRC-论坛" class="headerlink" title="网站和 IRC 论坛"></a>网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p>
<p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p>
<p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p>
<p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p>
<p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p>
<h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p>
<ul>
<li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li>
<li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li>
<li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li>
<li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li>
</ul>
<p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p>
<p>然而，如果你<strong>确信</strong>你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p>
<p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p>
<h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p>
<p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p>
<blockquote>
<p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p>
</blockquote>
<blockquote>
<p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p>
</blockquote>
<blockquote>
<p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p>
</blockquote>
<p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p>
<p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p>
<p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p>
<p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p>
<p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p>
<p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p>
<h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p>
<p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p>
<h3 id="用清晰、正确、精准并语法正确的语句"><a href="#用清晰、正确、精准并语法正确的语句" class="headerlink" title="用清晰、正确、精准并语法正确的语句"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p>
<p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p>
<p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p>
<p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p>
<p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p>
<p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p>
<blockquote>
<p>English is not my native language; please excuse typing errors.</p>
</blockquote>
<ul>
<li>英文不是我的母语，请原谅我的错字或语法。</li>
</ul>
<blockquote>
<p>If you speak $LANGUAGE, please email&#x2F;PM me;<br>I may need assistance translating my question.</p>
</blockquote>
<ul>
<li>如果你说<strong>某语言</strong>，请寄信&#x2F;私讯给我；我需要有人协助我翻译我的问题。</li>
</ul>
<blockquote>
<p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p>
</blockquote>
<ul>
<li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li>
</ul>
<blockquote>
<p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p>
</blockquote>
<ul>
<li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li>
</ul>
<h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p>
<ul>
<li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li>
<li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li>
<li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li>
<li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li>
<li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li>
<li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li>
<li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li>
<li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li>
</ul>
<p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p>
<h3 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h3><ul>
<li>仔细、清楚地描述你的问题或 Bug 的症状。</li>
<li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li>
<li>描述在提问前你是怎样去研究和理解这个问题的。</li>
<li>描述在提问前为确定问题而采取的诊断步骤。</li>
<li>描述最近做过什么可能相关的硬件或软件变更。</li>
<li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li>
</ul>
<p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p>
<p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p>
<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p>
<h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p>
<p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p>
<h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p>
<p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p>
<p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p>
<p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p>
<h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p>
<p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p>
<p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p>
<h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6&#x2F;233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p>
</blockquote>
<p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p>
<h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p>
<p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p>
<p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p>
<h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p>
<p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p>
</blockquote>
<p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p>
<h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p>
<p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p>
<p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p>
<h3 id="清楚明确的表达你的问题以及需求"><a href="#清楚明确的表达你的问题以及需求" class="headerlink" title="清楚明确的表达你的问题以及需求"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p>
<p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p>
<p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p>
<p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p>
<h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p>
<p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译&#x2F;直译&#x2F;被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p>
<p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p>
<p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p>
<h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p>
<p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p>
<h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p>
<p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p>
<p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p>
<p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p>
<h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p>
<p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p>
<p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p>
<p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p>
<h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p>
<p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p>
<p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p>
<p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p>
<h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p>
<p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p>
<p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p>
<p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p>
<p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表&#x2F;新闻群组&#x2F;论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p>
<p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p>
<p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p>
<p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p>
<h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><p><a id="RTFM"></a></p>
<h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p>
<p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **<a href="http://lmgtfy.com/">Google 是你的朋友</a>**！）</p>
<p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p>
<p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p>
<ul>
<li><strong>你需要的信息非常容易获得</strong>；</li>
<li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li>
</ul>
<p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p>
<h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p>
<p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p>
<h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p>
<p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p>
<p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p>
<p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p>
<p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p>
<p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p>
<h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p>
<p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p>
<p>熬过去，这很正常。事实上，它是有益健康且合理的。</p>
<p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p>
<p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p>
<p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p>
<p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p>
<p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p>
<p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p>
<p>也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p>
<h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p>
<p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p>
<p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p>
<p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p>
<p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p>
<p>问题：<a href="#q5">我的程序&#x2F;设定&#x2F;SQL 语句没有用</a></p>
<p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p>
<p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p>
<p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p>
<p>问题：<a href="#q9">我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</a></p>
<hr>
<p><a id="q1"></a></p>
<blockquote>
<p>问题：我能在哪找到 X 程序或 X 资源？</p>
</blockquote>
<p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com/">Google</a> 吗？</p>
<p><a id="q2"></a></p>
<blockquote>
<p>问题：我怎样用 X 做 Y？</p>
</blockquote>
<p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p>
<p><a id="q3"></a></p>
<blockquote>
<p>问题：如何设定我的 shell 提示？？</p>
</blockquote>
<p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p>
<p><a id="q4"></a></p>
<blockquote>
<p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p>
</blockquote>
<p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p>
<p><a id="q5"></a></p>
<blockquote>
<p>问题：我的{程序&#x2F;设定&#x2F;SQL 语句}不工作</p>
</blockquote>
<p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p>
<ul>
<li>你还有什么要补充的吗？</li>
<li>真糟糕，希望你能搞定。</li>
<li>这关我有什么屁事？</li>
</ul>
<p><a id="q6"></a></p>
<blockquote>
<p>问题：我的 Windows 电脑有问题，你能帮我吗？</p>
</blockquote>
<p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p>
<p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p>
<p><a id="q7"></a></p>
<blockquote>
<p>问题：我的程序不会动了，我认为系统工具 X 有问题</p>
</blockquote>
<p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p>
<p><a id="q8"></a></p>
<blockquote>
<p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p>
</blockquote>
<p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到使用者群组的清单）。</p>
<p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p>
<p><a id="q9"></a></p>
<blockquote>
<p>问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</p>
</blockquote>
<p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p>
<h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p>
<p><strong>蠢问题</strong>：</p>
<blockquote>
<p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p>
</blockquote>
<p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p>
<p><strong>聪明问题</strong>：</p>
<blockquote>
<p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p>
</blockquote>
<p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p>
<p><strong>蠢问题</strong>：</p>
<blockquote>
<p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p>
</blockquote>
<p>他觉得都是别人的错，这个傲慢自大的提问者。</p>
<p><strong>聪明问题</strong>：</p>
<blockquote>
<p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p>
</blockquote>
<p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p>
<p><strong>蠢问题</strong>：</p>
<blockquote>
<p>我的主机板有问题了，谁来帮我？</p>
</blockquote>
<p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p>
<p><strong>聪明问题</strong>：</p>
<blockquote>
<p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p>
</blockquote>
<p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p>
<p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p>
<p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p>
<p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p>
<p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p>
<p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p>
<h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p>
<p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p>
<p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p>
<p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p>
<p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p>
<p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p>
<h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p>
<p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p>
<p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p>
<p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p>
<p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p>
<p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p>
<p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p>
<p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p>
<p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p>
<p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 系统和网络基本原理</a>。</p>
<p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a>操作。</p>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>学习</category>
        <category>科技</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>文件</tag>
        <tag>作者</tag>
        <tag>网站</tag>
        <tag>问题</tag>
        <tag>标题</tag>
        <tag>文档</tag>
        <tag>函数</tag>
        <tag>字符</tag>
        <tag>排序</tag>
        <tag>黑客</tag>
        <tag>邮件</tag>
        <tag>提问</tag>
        <tag>你</tag>
      </tags>
  </entry>
  <entry>
    <title>友链接力计划Traveling</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-04-05-%E5%8F%8B%E9%93%BE%E6%8E%A5%E5%8A%9B%E8%AE%A1%E5%88%92traveling/</url>
    <content><![CDATA[<p>#谈谈博客友链<br>   博主今日意外得知了此友链接力计划，作为小众群体一员的博主，深感近几年随着互联网的进化和发展，原本互联网到来之处流行的个人网站和博客这几年对移动端飞速发展的变化无法适应，以及各类优秀应用的崛起，还有移动端相对便捷的优势，导致一些说不清道不明好坏的变化，然而事实是个人网站和博客越来越少的人还在坚持，公众号抖音b站等各种vlog等代替原本博客的功能之一－记录生活现在被代替，而朋友圈和qq空间等熟人圈的动态功能更是将博客虐的体无完肤。<br>  这是好还是坏，人们渴望一个说说心里话的地方，又希望人们能看到又希望不看到，这种矛盾心里是当今博主们坚持下去的动力之一<del>大概</del><br>  友链是一个古老有神奇的产物，一个个陌生人在交换中互相了解，在默默关注，尤其是一些生活类博主，我们是一个个偷窥者，去看别人只想给陌生人看甚至都不想给看的东西，技术类博客也作为学习和笔记的好方法之一，不要问我什么不用某某软件来记录，问就是我也不知道。关于这种心态你可以从这里找到答案盘<br><a href="https://coolshell.cn/articles/17391.html">为什么我不在微信公众号上写文章</a><br><a href="https://blog.imoasis.cn/archives/why-blog.html">为什么选择独立博客？</a><br> 总而言之，友链是一个博客不可或缺的部分，如果是真的想要在博客中一探当代小众群体，这是个好工具。</p>
<p><img src="https://tu.yegetables.com/images/2020/04/02/travelling.png" alt="travelling.png"><br><strong><a href="https://github.com/volfclub/travellings">开往-友链接力</a></strong></p>
<blockquote>
<p>一群狼走得远……<br>#想法来自 </p>
</blockquote>
<p><a href="https://github.com/XXIIVV/webring">https://github.com/XXIIVV/webring</a></p>
<p>#使用说明</p>
<p>“开往”取自“开放的网络”。将开往的徽标插入您的网站，表示您支持开放的网络。</p>
<p>每当有用户访问加入开往的网站时，点击徽标后会随机跳转到另一个加入开往的网站。加入开往的网站越多，友链接力的规模越大，分享的流量也越多。</p>
<p>“ 网站E → 开往 → 网站X → 开往 → 网站A → 开往 → 网站M → 开往 → 网站P → 开往 → 网站L → 开往 → 网站E … ”</p>
<p>#网站应满足</p>
<p>愿为开放的网络做出贡献（如分享知识经验设计等）；<br>没有违法以及影响体验的内容（如侵入式广告等）；<br>正常更新维护中（国内无法正常访问会被移除）；<br>网站已有内容（建议已更新半年以上）；<br>强制启用 https 。<br>将徽标插入您网页明显直观的地方（让友链传递下去），提出 issues 申请收录。这一般在 3 个工作日内完成审核。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博主</tag>
        <tag>网站</tag>
        <tag>博客</tag>
        <tag>公众号</tag>
        <tag>友链</tag>
        <tag>开往</tag>
      </tags>
  </entry>
  <entry>
    <title>与Paul主题冲突苦战</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-03-19-%E4%B8%8Epaul%E4%B8%BB%E9%A2%98%E5%86%B2%E7%AA%81%E8%8B%A6%E6%88%98/</url>
    <content><![CDATA[<p>###前因<br>在使用任务清单这一博主使用率非常高,但typecho原本编辑器不支持只好使用插件来配合使用,但在pual的主题中,由于一段代码的存在,使 这条命令成了奢望.<br>###折腾.<br>显示看了一下网站源代码,在post.php 139行有一段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">        /*    (() =&gt; &#123;// 为小标题加上锚点</span><br><span class="line">                const postContent = ks.select(&#x27;.post-content&#x27;);</span><br><span class="line">                const titleArr = [];</span><br><span class="line">                for (let i = 1; i &lt; 5; i++) &#123;</span><br><span class="line">                    [...postContent.querySelectorAll(`h$&#123;i&#125;`)].forEach((item, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">const name = item.innerText.slice(-2) === &#x27;编辑&#x27; ? item.innerText.slice(0, item.innerText.length - 2) : item.innerText;</span><br><span class="line">                        titleArr.push(&#123;tier: i, name, top: window.getElementTop(item)&#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                const torTreeWrap = ks.select(&#x27;#torTree-wrap&#x27;);</span><br><span class="line">                if (titleArr.length === 1) &#123;</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">                let torTreeHTML = ` &lt;div class=&quot;torTree-title&quot;&gt;&lt;a href=&quot;javascript:window.scrollSmoothTo($&#123;titleArr[0].top&#125;)&quot;&gt;$&#123;titleArr.shift().name&#125;&lt;/a&gt;&lt;/div&gt;&lt;ul&gt;`;</span><br><span class="line">                for (let item of titleArr) &#123;</span><br><span class="line">                    torTreeHTML = torTreeHTML + `&lt;a href=&quot;javascript:window.scrollSmoothTo($&#123;item.top&#125;)&quot;&gt;&lt;li class=&quot;tier-$&#123;item.tier&#125;&quot;&gt;$&#123;item.name&#125;&lt;/li&gt;&lt;/a&gt;`</span><br><span class="line">                &#125;</span><br><span class="line">                torTreeHTML += `&lt;/ul&gt;`;</span><br><span class="line">                torTreeWrap.innerHTML = torTreeHTML;</span><br><span class="line">                torTreeWrap.removeAttribute(&#x27;style&#x27;)</span><br><span class="line">            &#125;)()*/</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>本来以为就是问题所在,没想到删了之后根本没有变化,于是经过很久的找寻和向innei以及paul大佬本人询问,在</p>
<blockquote>
<p>&#x2F;paul&#x2F;src&#x2F;main.css</p>
</blockquote>
<p>中第547行找到了代码<del>耗时两小时</del>;<br>直接删除大法没用,直接导致markdown的 - 目录命令消失;而我需要的任务清单 - [] 命令却被仅保留一个中括号,好像在嘲笑着我</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">article:not(.comment-list) li::before, .torTree li::before &#123;</span><br><span class="line">content: &#x27;\f061&#x27;;</span><br><span class="line">    font-family: FontAwesome;</span><br><span class="line"> margin-right: .4rem;</span><br><span class="line">   font-size: 10px;</span><br><span class="line">    color: currentColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我非常确定这就是我要找的的代码了,但是content这个参数代码正好是- 的替换箭头的图标,但由于不清楚如何修改使恢复原样,又卡住了.</p>
<p>innei大佬告诉我可以删去before,但对css丝毫不懂的我,却没有任何解决办法,暂且搁置吧.</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博主</tag>
        <tag>代码</tag>
        <tag>网站</tag>
        <tag>目录</tag>
        <tag>问题</tag>
        <tag>markdown</tag>
        <tag>标题</tag>
        <tag>const</tag>
        <tag>titlearr</tag>
        <tag>ner</tag>
        <tag>item</tag>
      </tags>
  </entry>
  <entry>
    <title>奥特曼系列的观看顺序</title>
    <url>/%E7%94%9F%E6%B4%BB/%E5%A5%A5%E7%89%B9%E6%9B%BC%E7%B3%BB%E5%88%97%E7%9A%84%E8%A7%82%E7%9C%8B%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>#知乎高赞<br>作者：浊酒敬岁月<br><a href="https://www.zhihu.com/question/55010095/answer/1250787763">链接</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>###第一部分 昭和系列</p>
<ul>
<li><p>[ ]《奥特曼story0》（建议观看，官方漫画，讲述了奥特之星的诞生，基本能和之后的tv衔接起来）</p>
</li>
<li><p>[x]《（初代）奥特曼》tv（建议观看，开山之作，一切荣光的开始）</p>
</li>
<li><p>[x]《奥特赛文》tv（建议观看，独立世界观，思考较深刻）</p>
</li>
<li><p>[x]《归来的奥特曼》tv（建议观看，即杰克奥特曼，世界观初成）</p>
</li>
<li><p>[x]《艾斯奥特曼》tv（建议观看，奥特兄弟成型）</p>
</li>
<li><p>[x]《泰罗奥特曼》tv（建议观看，传统的奥特六兄弟成型）</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
《雷欧奥特曼》tv（建议观看，奥特兄弟扩展至八人）</p>
</li>
<li><p>[ ]《乔尼亚斯奥特曼》tv（可看可不看，动画作）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《爱迪奥特曼》tv（建议观看，奥特兄弟扩展至九人）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《奥特物语》（可看可不看，奥特之星的琐事）</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
《40年后的真相》短视频（建议观看，填了初代奥特曼结尾的大坑，情怀满分）</p>
</li>
</ul>
<p>至此奥特曼最经典的世界观——奥特之星世界观暂时告一段落</p>
<p>###第二部分 过渡阶段</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
《葛雷奥特曼》《帕瓦特奥特曼》《USA三奥》（均可看可不看）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
哉阿斯奥特曼剧场版两部（可看可不看，搞笑作，片中有老演员客串）</p>
</li>
</ul>
<p>###第三部分 旧平成系列</p>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
《迪迦奥特曼》tv（建议观看，最具人气作品，圆谷中兴之作）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《远古复苏的巨人》（可看可不看，迪迦在远古时代的故事，对了解正史无影响）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《迪迦奥特曼最终圣战》（建议观看，片尾彩蛋大古飞鸟交接）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《戴拿奥特曼》tv（建议观看，迪迦续作，制作精良）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《戴拿奥特曼星光战士》（建议观看，迪迦戴拿首次同台）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《盖亚奥特曼》tv（建议全集观看，个人认为圆谷作品拍的最好的奥特曼）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《盖亚再现》（可看可不看，承接tv结局）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《盖亚奥特曼超时空大决战》（建议观看，平成三杰——迪迦戴拿盖亚首次同台）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《纳伊斯奥特曼》（可看可不看）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《奈欧斯奥特曼》（建议观看，世界观较为混乱，不过打斗十分流畅）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《高斯奥特曼》tv（建议观看，本人没有看过，不做评价）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
高斯奥特曼剧场版（建议观看，高斯系列我没有看过。应该是有三部？杰斯提斯、雷杰多登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
赛文ov，98、99、02三版（建议观看，承接《奥特赛文》结局并沿用其世界观，剧情内涵较丰富）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《Ultraman》（建议观看，n计划第一作，现实风格）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《奈克瑟斯奥特曼》tv（建议全集观看，承接Ultraman，带有成人向，被诸多奥迷奉为神作）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《麦克斯奥特曼》tv（建议观看，复古作，世界观回到m78）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《赛文x》（可看可不看，如果要看建议全集观看。只有几集，赛文在平行世界的故事，探讨了信息集权问题）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《梦比优斯奥特曼》tv（建议观看，奥特兄弟最后一位，情怀满分）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《梦比优斯外传之复活的皇帝》（可看可不看，小梦和机械扎姆的友谊）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《梦比优斯外传之暗黑铠甲》（可看可不看，安培拉被拉出来鞭尸）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《梦比优斯外传之希卡利的传说》（建议观看，希卡利的故事）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《梦比优斯&amp;奥特兄弟》（建议观看，时间线应该在tv之前）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《大决战！超奥特八兄弟》（建议观看，史无前例凑齐角色，情怀满分，被无数奥迷称作“圆谷最后的礼物”）</p>
</li>
</ul>
<p>###第四部分 新生代系列</p>
<p>为了方便，将赛罗列入新生代。这个时期圆谷被收购大清洗，作品改为季番，节奏快，剧情简单，世界观极其混乱，可以只挑自己喜欢的观看</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
《奥特超银河传说》（世界观拉回奥特之星，赛罗与贝利亚登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《贝利亚银河帝国》（诺亚最后一次登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《奥特曼传奇》（神秘四奥最后一位——赛迦奥特曼登场，神秘四奥说法存疑）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《赛罗奥特曼外传之有机生命体的危机》（赛罗警备队定型）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《赛罗奥特曼vs黑暗洛普斯赛罗》（雷欧赛罗师徒共战机械奥特兄弟）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《赛罗奥特曼格斗》（光辉赛罗登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《银河奥特曼》tv（新生代开启）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《银河奥特曼s》（维克特利登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《决战！奥特十勇士》（平成时期除奈欧斯外的所有主角登场，情怀作）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《奥特格斗胜利》（维克特利的故事，骑士形态登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《艾克斯奥特曼》tv（有老演员客串）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《来了！我们的奥特曼》（艾克斯的剧场版，迪迦初代客串）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《欧布奥特曼：原生之初》（欧布最初的故事）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《欧布奥特曼》tv（引入融合风格）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《赐予我羁绊之力吧！》（欧布剧场版，欧布三重形态登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《奥特格斗欧布》（欧布豪勇形态登场，彩蛋衔接捷德tv）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《捷德奥特曼》tv（贝利亚基本退出舞台）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《连接吧！愿望》（捷德剧场版，捷德究极形态登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《罗布奥特曼》tv（新生代最后两位奥特曼）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《决定了！羁绊的水晶》（罗布剧场版，格罗布，托雷基亚登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《奥特银河格斗》（新生代悉数登场，与泰迦tv衔接）</p>
</li>
</ul>
<p>###第五部分 令和时代</p>
<ul>
<li><p><input disabled="" type="checkbox"> 
《泰迦奥特曼》tv（泰罗的儿子，开创三奥设定）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《新生代之巅》（泰迦的剧场版，汇集了所有新生代奥特曼和人间体。令和第一究极奥令伽登场）</p>
</li>
<li><p><input disabled="" type="checkbox"> 
《泽塔奥特曼》tv（衔接捷德英雄传，雷欧的徒弟。特效炸裂，设定基本上不拉胯，很值得一看）</p>
</li>
</ul>
<p>…………以上便是我认为的较为合理的1966年至今的奥特曼作品观看顺序。欢迎补充</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>番</tag>
        <tag>动画</tag>
        <tag>奥特曼</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress快速搬运到typecho</title>
    <url>/%E5%AD%A6%E4%B9%A0/2020-01-17-wordpress%E5%BF%AB%E9%80%9F%E6%90%AC%E8%BF%90%E5%88%B0typecho/</url>
    <content><![CDATA[<p>上周末, 花了些时间将微博之博的程序从wordpress转到了typecho, 转换过程很顺利, 没有碰到什么问题. 之所以转程序, 是因为微博之博还有点访问量, 而这个访问量导致wordpress长期大量占用服务器资源. 不得已才转Typecho试试的.</p><p>转完以后, 才发现, 改改Typecho的代码, 装一些插件, 基本能让Typecho和wordpress功能一致. 当然wordpress那丰富的插件和主题资源是Typecho所不能比拟的.</p><p>废话不多说, 下面就是说说怎么转换具体步骤, 转换效果请看 <a href="http://itwwt.com" target="_blank" rel="noopener noreferrer">微博之博</a>:</p><h4>1. 转换程序</h4><p><span style="color: #ff0000;">实践证明, 下面过程也适用于最新版的wordpress转换, 我的wordpress就是3.4.1</span></p><blockquote><p>首先安装typecho0.8程序，安装之前请确认你的服务器支持PHP5。</p><p>下载地址：http://typecho.org/download</p><p>wordpress转typecho插件下载：<a href="http://docs.typecho.org/plugins/wordpress-to-typecho">http://docs.typecho.org/plugins/wordpress-to-typecho</a></p><p>然后将已经安装在空间里的wordpress博客移动到子目录（文件和数据建议先做好备份，以免出错）。</p><p>然后再安装typecho程序，接着将插件Wordpress to Typecho上传到typecho\usr\plugins 目录，在后台启用插件后便可以在确认了数据库信息后将文章和评论转换过来。</p><p>由于程序目前还没有友情链接的功能，链接的数据不会转换，需要手动添加链接。</p></blockquote><p>参考来源: <a href="http://www.weidao.net/1078.html">wordpress 3.2 程序转typecho最新教程</a></p><h4>2. 更换文章图片地址</h4><p>wordpress的图片保存在 /usr/uploads/ , 而Typecho则是保存在 /usr/uploads. 这时我们除了需要把 /usr/uploads/ 所有图片文件转移到 /usr/uploads 外, 还需要在phpmyadmin中执行以下SQL, 以将wordpress图片路径替换成Typecho的:</p><blockquote>UPDATE typecho_contents SET text = REPLACE(text,'http://xx.com/usr/uploads/','http://xx.com/usr/uploads/');</blockquote><h4>3. 如何在导航上显示目录分类</h4><p>找到header.php中:</p><blockquote><li<?php if($this-&gt;is('index')): ?&gt; class="current"<?php endif; ?&gt;&gt;<a href="<?php $this-&gt;options-&gt;siteUrl(); ?&gt;"&gt;首页</a&gt;</li&gt;<br/> <?php $this-&gt;widget('Widget_Contents_Page_List')-&gt;to($pages); ?&gt;<br/> <?php while($pages-&gt;next()): ?&gt;<br/> <li<?php if($this-&gt;is('page', $pages-&gt;slug)): ?&gt; class="current"<?php endif; ?&gt;&gt;<a href="<?php $pages-&gt;permalink(); ?&gt;" title="<?php $pages-&gt;title(); ?&gt;"&gt;<?php $pages-&gt;title(); ?&gt;</a&gt;</li&gt;<br/> <?php endwhile; ?&gt;</blockquote><p>替换为</p><blockquote><li<?php if($this-&gt;is('index')): ?&gt; class="current"<?php endif; ?&gt;&gt;<a href="<?php $this-&gt;options-&gt;siteUrl(); ?&gt;"&gt;<?php _e('首页'); ?&gt;</a&gt;</li&gt;<br/> <?php $this-&gt;widget('Widget_Metas_Category_List')-&gt;to($category); ?&gt;<br/> <?php while($category-&gt;next()): ?&gt;<br/> <li<?php if($this-&gt;is('category', $category-&gt;slug)): ?&gt; class="current"<?php endif; ?&gt;&gt;<a href="<?php $category-&gt;permalink(); ?&gt;" title="<?php $category-&gt;title(); ?&gt;"&gt;<?php $category-&gt;name(); ?&gt;</a&gt;</li&gt;<br/> <?php endwhile; ?&gt;</blockquote><p>参考来源: <a title="http://forum.typecho.org/topic.php?id=2414" href="http://forum.typecho.org/topic.php?id=2414">http://forum.typecho.org/topic.php?id=2414</a></p><h4>4. 首页显示摘要</h4><p>找到index.php</p><p>将</p><blockquote><?php $this-&gt;content('阅读剩余部分...'); ?&gt;</blockquote><p>替换为</p><blockquote><?php $this-&gt;excerpt(); ?&gt;</blockquote><p>如果想精确控制摘要字数, 则</p><blockquote><?php $this-&gt;excerpt(200, '...');//200就是摘要的字数 ?&gt;</blockquote><p>参考来源: <a href="http://www.52coding.cn/idlernet/blog/index.php/default/8.html">Typecho 首页显示摘要的小窍门</a></p><h4>5. 首页显示缩略图</h4><p>请安装这个插件: <a title="http://typecho.us/plugins/thumbnail.html" href="http://typecho.us/plugins/thumbnail.html">http://typecho.us/plugins/thumbnail.html</a></p><p><span style="color: #ff0000;">首次使用这个插件注意去手动创建下面的目录:</span></p><blockquote>/usr/resources/cate/<br/> /usr/resources/rand/</blockquote><p><span style="color: #ff0000;">不然是无法显示下面的默认图片地址的:</span></p><blockquote>/usr/plugins/Thumbnail/default.png</blockquote><h4>6. TypechoPing自动更新服务</h4><p>请安装这个插件: <a title="http://typecho.us/plugins/typecho-ping.html" href="http://typecho.us/plugins/typecho-ping.html">http://typecho.us/plugins/typecho-ping.html</a></p><h4>7. 显示文章浏览数</h4><p>请安装这个插件: <a title="http://typecho.us/plugins/post-views.html" href="http://typecho.us/plugins/post-views.html">http://typecho.us/plugins/post-views.html</a></p><h4>8. 博客sitemap功能</h4><p><a title="http://typecho.us/plugins/google-sitemap.html" href="http://typecho.us/plugins/google-sitemap.html">http://typecho.us/plugins/google-sitemap.html</a></p><h4>9. 关键词内链工具</h4><p><a title="http://typecho.us/plugins/hight-light-tag.html" href="http://typecho.us/plugins/hight-light-tag.html">http://typecho.us/plugins/hight-light-tag.html</a></p><p><span style="color: #ff0000;">这个插件只能根据当前文章的tag找到文章的关键词并链接.</span></p><h4>10. 如何反垃圾评论</h4><p><a title="http://typecho.us/plugins/comment-filter.html" href="http://typecho.us/plugins/comment-filter.html">http://typecho.us/plugins/comment-filter.html</a></p><p>按文中作如下设置即可:</p><blockquote>设置非中文直接失败，以及带有http/com/net等敏感关键词，需要审核后显示</blockquote><h4>11. 将带WWW的网址转向不带WWW的网址</h4><p>在.htaccess中加入:</p><blockquote>RewriteCond %{HTTP_HOST} ^www.itwwt.com [NC]<br/> RewriteRule ^(.*)$ <a href="http://itwwt.com/">http://itwwt.com/</a>$1 [L,R=301]</blockquote><p>比如我的完整.htaccess就是:</p><blockquote><p><IfModule mod_rewrite.c&gt;</p><p>RewriteEngine On<br/> RewriteBase /<br/> RewriteCond %{HTTP_HOST} ^www.itwwt.com [NC]<br/> RewriteRule ^(.*)$ <a href="http://itwwt.com/">http://itwwt.com/</a>$1 [L,R=301]<br/> RewriteCond %{REQUEST_FILENAME} !-f<br/> RewriteCond %{REQUEST_FILENAME} !-d<br/> RewriteRule ^(.*)$ /index.php/$1 [L]</p><p></IfModule&gt;</p></blockquote><h4>12. <a href="http://blog.fengyiyi.com/archives/Typecho%E4%BF%AE%E6%94%B9header-php%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E9%83%A8%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF.html" target="_blank" rel="noopener noreferrer">Typecho修改header.php自定义头部输出信息</a></h4><p><?php$this-&gt;header('keywords=&generator=&template=&pingback=&xmlrpc=&wlw=');?&gt;</p><p>操作参数及方法说明</p><p>keywords：关键词<br/> description：描述、摘要<br/> rss1：feed rss1.0<br/> rss2：feed rss2.0<br/> atom：feed atom<br/> generator：程序版本等<br/> template：模板名称<br/> pingback：文章引用<br/> xmlrpc：离线写作<br/> wlw：...</p><p>commentReply: 不输出评论回复js</p><p>注：等号（=）为空则不输出该项目，各个参数之间使用 “&” 连接。 如果需要自定义rss地址，只填上 rss2=feed订阅地址 即可。</p><p>最后, 推荐一个专门收集Typecho插件的网站: <a title="http://typecho.us/" href="http://typecho.us/">http://typecho.us/</a>, 非常不错哦.</p><p>Typecho唯一遗憾的地方是: 由于使用人数不如wordpress广泛, 所以还没有哪个社会化评论为它开发评论插件. 如果用社会化评论的通用代码的话, 最新评论, 评论数量和评论定时保存到本地都是一个很大的问题. 当然, 如果你不用社会化评论而用Typecho默认评论功能的话, 这个问题就不是问题了.</p>]]></content>
      <categories>
        <category>学习</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>文件</tag>
        <tag>代码</tag>
        <tag>插件</tag>
        <tag>网站</tag>
        <tag>目录</tag>
        <tag>转换</tag>
        <tag>问题</tag>
        <tag>博客</tag>
        <tag>typecho</tag>
        <tag>wordpress</tag>
        <tag>uploads</tag>
        <tag>usr</tag>
      </tags>
  </entry>
  <entry>
    <title>主题代码使Wordpress评论可见</title>
    <url>/%E5%AD%A6%E4%B9%A0/2019-12-05-%E4%B8%BB%E9%A2%98%E4%BB%A3%E7%A0%81%E4%BD%BFwordpress%E8%AF%84%E8%AE%BA%E5%8F%AF%E8%A7%81/</url>
    <content><![CDATA[<p><span style="color: #ff0000;">一、首先将下面给的代码，加到你的主题的 functions.php 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//短代码之评论可见   </span><br><span class="line">function reply_to_read($atts, $content=null) &#123;   </span><br><span class="line">extract(shortcode_atts(array(&quot;notice&quot; =&gt; &#x27;&lt;p class=&quot;reply-to-read&quot;&gt;&lt;span style=&quot;color:red; font-size=13px;&quot;&gt;温馨提示：&lt;/span&gt;此处内容需要&lt;a href=&quot;#respond&quot; title=&quot;评论本文&quot;&gt;评论本文&lt;/a&gt;后才能查看.&lt;/p&gt;&#x27;), $atts));   </span><br><span class="line">$email = null;   </span><br><span class="line">$user_ID = (int) wp_get_current_user()-&gt;ID;   </span><br><span class="line">if ($user_ID &gt; 0) &#123;   </span><br><span class="line">$email = get_userdata($user_ID)-&gt;user_email;   </span><br><span class="line">//对博主直接显示内容   </span><br><span class="line">$admin_email = &quot;ajian@ajian.tk&quot;; //博主Email(可修改）   </span><br><span class="line">if ($email == $admin_email) &#123;   </span><br><span class="line">return $content;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125; else if (isset($_COOKIE[&#x27;comment_author_email_&#x27; . COOKIEHASH])) &#123;   </span><br><span class="line">$email = str_replace(&#x27;%40&#x27;, &#x27;@&#x27;, $_COOKIE[&#x27;comment_author_email_&#x27; . COOKIEHASH]);   </span><br><span class="line">&#125; else &#123;   </span><br><span class="line">return $notice;   </span><br><span class="line">&#125;   </span><br><span class="line">if (empty($email)) &#123;   </span><br><span class="line">return $notice;   </span><br><span class="line">&#125;   </span><br><span class="line">global $wpdb;   </span><br><span class="line">$post_id = get_the_ID();   </span><br><span class="line">$query = &quot;SELECT `comment_ID` FROM &#123;$wpdb-&gt;comments&#125; WHERE `comment_post_ID`=&#123;$post_id&#125; and `comment_approved`=&#x27;1&#x27; and `comment_author_email`=&#x27;&#123;$email&#125;&#x27; LIMIT 1&quot;;   </span><br><span class="line">if ($wpdb-&gt;get_results($query)) &#123;   </span><br><span class="line">return do_shortcode($content);   </span><br><span class="line">&#125; else &#123;   </span><br><span class="line">return $notice;   </span><br><span class="line">&#125;   </span><br><span class="line">&#125;   </span><br><span class="line">add_shortcode(&#x27;reply&#x27;, &#x27;reply_to_read&#x27;);   </span><br></pre></td></tr></table></figure>

<p>二、然后就短代码，编写文章时插入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[reply]评论可见的内容[/reply]</span><br></pre></td></tr></table></figure>
<p>三、提醒内容也可以自定义，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[reply notice=&quot;自定义提醒回复内容&quot;]自定义提醒回复内容[/reply]</span><br></pre></td></tr></table></figure>
<p>转载自<a href="https://yfdxs.com/wordpress-comment-visible.html" rel="noopener noreferrer" target="_blank">本文由 远方的雪山 作者：萨龙龙 发</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>int</tag>
        <tag>array</tag>
        <tag>else</tag>
        <tag>作者</tag>
        <tag>博主</tag>
        <tag>代码</tag>
        <tag>email</tag>
        <tag>notice</tag>
        <tag>return</tag>
        <tag>reply</tag>
        <tag>user_id</tag>
      </tags>
  </entry>
  <entry>
    <title>免流混淆参数</title>
    <url>/%E5%AD%A6%E4%B9%A0/2019-12-02-%E5%85%8D%E6%B5%81%E6%B7%B7%E6%B7%86%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<div>全国联通沃商店：game.hxll.wostore.cn</div><div>全国联通沃商店：music.hxll.wostore.cn</div><div>全国联通沃商店：video.hxll.wostore.cn</div><div>沃阅读混淆参数：partner.iread.wo.com.cn</div><div>全国联通沃商店高级：game.hxll.wostore.cn#Connection: Keep-Alive\nAccept-Encoding: gzip</div><div>全国联通沃商店高级：music.hxll.wostore.cn#Connection: Keep-Alive\nAccept-Encoding: gzip</div><div>沃阅读高级：partner.iread.wo.com.cn#Connection: Keep-Alive\nAccept-Encoding: gzip</div><div>全国联通沃音乐：box.10155.com</div><div><br></div><div>通用免流混淆参数A</div><div><br></div><div>QQ音乐混淆参数：dl.stream.qqmusic.com</div><div>梦想e卡混淆参数：imhdfs.icbc.com.cn</div><div>梦想e卡混淆参数(福建已免)：v.icbc.com.cn</div><div>爱奇艺混淆参数：data.video.qiyi.com</div><div>优酷混淆参数：vali-dns.cp31.ott.cibntv.net</div><div>高德地图混淆参数：mps.amap.com</div><div>央视影音混淆参数：asp.cntv.myalicdn.com</div><div>百度贴吧混淆参数：static.tieba.baidu.com</div><div>微信混淆参数(遵义广州已免)：short.weixin.qq.com</div><div>虾米音乐混淆参数：pic.xiami.net</div><div>天翼视讯混淆参数：vod3.nty.tv189.cn</div><div>钉钉混淆参数：tms.dingtalk.com</div><div>微博混淆参数：tobe.vip.weibo.com</div><div>微博混淆参数：new.vip.weibo.cn</div><div>微博混淆参数：simg.s.weibo.com</div><div>优酷混淆参数：push.m.youku.com</div><div>优酷混淆参数：api.mobile.youku.com</div><div>书旗混淆参数：spend1.shuqireader.com</div><div>书旗混淆参数：c1.shuqireader.com</div><div>优酷混淆参数：www.youku.com</div><div><br></div><div>通用免流混淆参数B</div><div><br></div><div>优酷：vali-dns.cp31.ott.cibntv.net#Range:bytes=25165824-32586598\nAccept:&nbsp;/</div><div>爱看4G：ltevod.tv189.cn#Connection: Keep-Alive\nAccept-Encoding: gzip</div><div>沃音乐：woif.10155.com#Accept-Encoding: gzip</div><div>微信(深圳已免)：szminorshort.weixin.qq.com#Upgrade: mmtls\nAccept:&nbsp;/\nConnection: close\nContent-Length: 533\nContent-Type: application/octet-stream</div><div>淘宝：adashbc.m.taobao.com#Accept-Encoding: gzip</div><div>央视影音：asp.cntv.myalicdn.com#Icy-MetaData: 1</div><div>抖音：dm.toutiao.com#Connection: Keep-Alive\nAccept-Encoding: gzip</div><div>百度：tbcdn.hiphotos.baidu.com#needginfo: 1/nConnection: Keep-Alive/nUser-Agent: bdtb for Android 9.0.8.0</div><div>爱奇艺：data.video.qiyi.com#Accept:&nbsp;/</div><div>美团：apimeishi.meituan.com#Connection: Keep-Alive</div><div>高德地图：mps.amap.com#Connection: Keep-Alive\nAccept-Encoding: gzip\nContent-Length: 680</div><div><br></div><div>移动</div><div><br></div><div><a href="http://www.10086.cn">www.10086.cn</a></div><div>mm.10086.cn</div><div>抖音卡头条卡定向 有定向包可用：dm.toutiao.com</div><div>抖音卡头条卡定向 有定向包可用：v9-dy.ixigua.com</div><div><br></div><div>电信</div><div><br></div><div>天翼视讯：h5.nty.tv189.com</div><div>天翼视讯：vod3.nty.tv189.cn</div><div>爱玩4G：open.4g.play.cn</div><div>爱看4G： ltetp.tv189.com</div><div>湖北电信：hb.10000shequ.com</div><div>湖北电信：hb.10000shequ.com:8081</div><div>电信天翼：dy3.nty.tv189.cn</div><div>电信天翼：ltewap.tv189.com</div><div>电信天翼：tp.nty.tv189.com</div><div>电信天翼：ltewap.tv189.com/ik4g/v/C40605803.html?appid=115020310073&amp;token=baebaf0fda892726032db7e8f2f7e0ee&amp;devid=000001&amp;version=5.3.13.14ctch1&amp;channelid=01832020\r\n</div><div>电信爱听：dl.music.189.cn/res/V/1388/mp3/33/58/94/1388335894003000.mp3?mb=15380197563&amp;fs=10104163&amp;s=800&amp;n=&amp;id=63696337&amp;M=online&amp;sid=240387514</div><div>电信爱玩：open.4g.play.cn/api/v2/egame/log.json&amp;access_token=dc15d6902663913b10a6ff56ae4e0c44&amp;imsi=460022443530655&amp;vc=145&amp;app_key=8888015&amp;channel_id=20310025</div><div>电信大王卡(可欠费使用)：lt.hn.189.cn:1082</div><div>阿里鱼卡：mps.amap.com#Connection: Keep-Alive\nAccept-Encoding: gzip\nContent-Length: 680</div><div><br></div><div>联通</div><div><br></div><div>山东联通：m.t.17186.cn</div><div>联通114圣子全国：114.255.201.163(重庆、河南、福建、湖南等地)</div><div>哔哩哔哩：i1.hdslb.com</div><div>哔哩哔哩：i0.hdslb.com</div><div>浙江联通wo+：w.zj165.com</div><div>联通wotv全国：wotv.17wo.cn（浙江、安徽、江苏）</div><div>河北：hb.10000shequ.com</div><div>湖北(优先wap接入点不免net)：box.10155.com</div><div>沃音乐：box.10155.com(四川、湖北、重庆、河北等)</div><div>沃阅读：partner.iread.wo.com.cn(北京、河南等)</div><div>工商e卡：v.icbc.com.cn</div><div>m.icbc.com.cn</div><div>m.mall.icbc.com.cn</div><div>elife.icbc.com.cn</div><div>act.icbc.com.cn</div><div>hit.icbc.com.cn</div><div>pv.mall.icbc.com.cn</div><div>mybank.icbc.com.cn</div><div>腾讯大王卡：szminorshort.weixin.qq.com#Upgrade: mmtls\nAccept:&nbsp;/\nConnection: close\nContent-Length: 533\nContent-Type: application/octet-stream</div><div>腾讯大王卡：tx.flv.huya.com</div><div>腾讯大王卡：short.weixin.qq.com</div><div>腾讯大王卡：szextshort.weixin.qq.com</div><div>short.weixin.qq.com</div><div>百度圣卡：data.video.qiyi.com</div><div>阿里宝卡：vali-dns.cp31.ott.cibntv.net</div><div>阿里宝卡微博卡：gw.alicdn.com</div><div>优酷：api.mobile.youku.com</div><div>米粉api：api.ad.xiaomi.com</div><div>小米应用商店：data.mistat.xiaomi.com</div><div>小米直播：zbupic.zb.mi.com</div><div>小米充值：f100.g.mi.com</div><div>小米商城：mi.com</div><div><br></div><div><br></div><div>摘自冰灵云</div><div><br></div><div><br></div><div><!--emptysign--></div>]]></content>
      <categories>
        <category>学习</category>
        <category>科技</category>
      </categories>
      <tags>
        <tag>混淆</tag>
        <tag>参数</tag>
        <tag>gzip</tag>
        <tag>connection</tag>
        <tag>联通沃</tag>
      </tags>
  </entry>
  <entry>
    <title>Csgo准星</title>
    <url>/%E7%94%9F%E6%B4%BB/csgo%E5%87%86%E6%98%9F/</url>
    <content><![CDATA[<p>cl_crosshairalpha “255”;cl_crosshaircolor “1”;cl_crosshaircolor_b “50”;cl_crosshaircolor_r “50”;cl_crosshaircolor_g “250”;cl_crosshairdot “0”;cl_crosshair_t “0”;cl_crosshairgap “-11”;cl_crosshairsize “2.5”;cl_crosshairstyle “4”;cl_crosshairusealpha “1”;cl_crosshairthickness “2”;cl_fixedcrosshairgap “-11”;cl_crosshair_outlinethickness “0.7”;cl_crosshair_drawoutline “1”;</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>cl_crosshairstyle</tag>
        <tag>cl_crosshairgap</tag>
        <tag>cl_crosshair_t</tag>
        <tag>cl_crosshairsize</tag>
        <tag>cl_crosshairdot</tag>
      </tags>
  </entry>
  <entry>
    <title>樱花飘落的速度是秒速五厘米</title>
    <url>/%E7%94%9F%E6%B4%BB/%E6%A8%B1%E8%8A%B1%E9%A3%98%E8%90%BD%E7%9A%84%E9%80%9F%E5%BA%A6%E6%98%AF%E7%A7%92%E9%80%9F%E4%BA%94%E5%8E%98%E7%B1%B3/</url>
    <content><![CDATA[<p>!!!<br><sqp data-163="540968" data-title="One more time, One more chance" ></sqp><br>!!!</p>
<p>明里，我们一直在转学，都习惯了呢。<br>明里，看到你给我来信的那一天，我好高兴，连樱花飘落的样子，都变得那么美好。<br>明里，我真后悔，那时候我没能安慰你，只顾及到自己的心情。你应该比我更不安吧？<br>明里，我要来找你了，说实话，这还是我第一次走这段路线呢，希望一切都能顺利。<br>明里，一向准时的电车误点了，希望你不要在那里等我。<br>明里，没想到你还在那里。<br>明里，你做的米团真好吃，我再也没吃过比这更好的了。<br>明里，在仓库里度过的那一夜真美好，我们紧紧相拥在一起，这样的日子，恐怕以后就不能有了吧？明里，我们又要分开了。<br>明里，好多年过去了，习惯性的写着没有收件人的短信，是因为想你了么？澄田那家伙，恐怕我要辜负她了。<br>……明里，看来贵树命里终究不会有你啊。明里，如果真有下辈子这种东西的话，我还会选择继续喜欢你。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>明</tag>
        <tag>贵树命</tag>
        <tag>收件人</tag>
        <tag>米团</tag>
        <tag>里</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌锁</title>
    <url>/%E5%AD%A6%E4%B9%A0/2019-12-02-%E8%B0%B7%E6%AD%8C%E9%94%81/</url>
    <content><![CDATA[<p>#方法一<br>进twrp删除<code>/system/priv- app/setupwizard.apk</code>的后缀，重启进系统后登录谷歌帐号再退出，再进twrp把apk后缀改回来</p>
<p>#方法二:<br>进入第三方rec,挂载system,然后用rec文件管理器删掉<code>system/priv-app/setupwizard/setupwizard.apk</code>(注意:MIUI系统会卡米)</p>
<p>#方法三:<br>开机向导拨号盘输入*#812#跳过</p>
<p>#方法四:adb<br><code><br>adb shell settings put secure user_setup_complete 1<br>adb shell settings put global device_provisioned 1<br></code><br>一般情况下开机向导无法跳过的,可以用电脑安装Adb工具包,(小白推荐奇兔刷机),然后手机进入rec,挂载System后在Adb运行以上命令,然后开机即可</p>
<p>#方法五:<br>1.把build.prop拿出来<code>adb pull /system/build.prop ~/Desktop/</code><br>2.修改重点: <code>ro.setupwizard.mode=DISABLE</code><br>3.push回去<code>adb push ~/Desktop/build.prop /system/build.prop</code><br>如果提示<br><code>adb: error: failed to copy ‘/home/aaron/Desktop/build.prop’ to ‘/system/build.prop’: remote couldn’t create file:Read-only file system</code><br>则挂载System之后再执行(手动移动出来修改再放回去也行)&#x2F;home&#x2F;aaron&#x2F;Desktop&#x2F;build.prop: 0 files pushed. 0.9 MB&#x2F;s (8949 bytes in 0.009s)<br><code>adb remount</code></p>
<p>#方法六:<br>在无线网连接界面点开机向导四个角(左上。右上。右下。左下),可跳过(新版Gapps不一定有用)</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>科技</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>adb</tag>
        <tag>system</tag>
        <tag>desktop</tag>
        <tag>rec</tag>
        <tag>向导</tag>
      </tags>
  </entry>
  <entry>
    <title>Zfaka搭建</title>
    <url>/%E5%AD%A6%E4%B9%A0/2019-11-21-zfaka%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/12/06/WbzoY2u8ZXCQ9H5.jpg"><br>本站来源于github开源项目 <a href="https://github.com/zlkbdotnet/zfaka" target="_blank" rel="noopener noreferrer">查看链接</a></p>
<p>本人建成网站 <a href="https://ajian.store" target="_blank" rel="noopener noreferrer">查看链接</a></p>
<p>接下来详细说一说建站步骤（全程使用宝塔搭建）</p>
<p>#一.拥有一个虚拟空间或者云服务器</p>
<p>自行选择 ①云服务器 ②虚拟空间</p>
<p>###1.1购买云服务器（vps）</p>
<p>推荐去处 阿里云，腾讯云等国内巨头或者vultr等国外著名商家购买，价格在一个月2到5美刀不等，还有些不知名的低价云服务器，为了各位数据安全，请自行斟酌。</p>
<p>###1.2初始运行</p>
<p>购买完毕后，我们得到一个用户名和密码，用于服务器后端登陆，windows请使用xshell等软件，安卓请使用juicessh <a href="https://play.google.com/store/apps/details?id=com.sonelli.juicessh" target="_blank" rel="noopener noreferrer">查看链接</a>等ssh软件，下载地址 <a href="https://play.google.com/store/apps/details?id=com.sonelli.juicessh" target="_blank" rel="noopener noreferrer">查看链接</a></p>
<p>用这类ssh软件输入刚才得到的账号密码，登入我们的服务器</p>
<p>###1.3 初始化运行</p>
<p>不同服务商提供的机器配置不同，为了能够正常使用，先装一些常用命令</p>
<pre><code>yum update -y
yum install -y curl vim wget unzip git
</code></pre>
<p>（ps：第一个更新命令时间很长，而且到最后一个项目时可能会卡住，建议ctrl+c退出再重新执行即可解决）</p>
<p>安装宝塔 访问bt.cn在官网找到各自系统的最新宝塔面板命令，运行后得到</p>
<p>Bt-Panel: <a href="http://173.0.0.82/###:8888/####">http://173.82.###:8888/####</a></p>
<p>username: lb9###</p>
<p>password: e28###9</p>
<p>访问这个网址输入账号密码，进入宝塔面板(根据自己的填写,我做个示范)</p>
<p>###1. 4虚拟主机一般自带宝塔，没有的话参考①自行安装，我用的不多就不多逼逼了。</p>
<p>#二.宝塔面板相关配置</p>
<p>###2.1初配置<br> 第一次进入会选择安装，选择左边的lnmp，选择合适的nginx，mysql，php，</p>
<p>等版本，（php推荐点7.*版本，本人7.3版本）</p>
<p>###2.2 新建网站<br>从侧栏进入网站页，新建网站，输入域名（没有域名的可以输服务器地址）注意点击创建数据库，数据库用户名密码自行输入</p>
<img src="https://pic3.superbed.cn/item/5de9e9d2f1f6f81c50fa4ff9.jpg" alt="" />

<p>###2.3 下载网站源码<br>访问 <a href="https://github.com/zlkbdotnet/zfaka/archive/master.zip" target="_blank" rel="noopener noreferrer">查看链接</a> 或者 <a href="https://www.lanzous.com/i7f646d" target="_blank" rel="noopener noreferrer">查看链接</a> 下载，然后在宝塔中进入网站根目录，上传刚才下载的zip压缩包，选择在线解压</p>
<p>###2.4 设置伪静态和网站目录</p>
<img src="https://pic2.superbed.cn/item/5de9eab1f1f6f81c50fa759b.jpg" alt="" />
<img src="https://pic2.superbed.cn/item/5de9eab1f1f6f81c50fa7598.jpg" alt="" />

<p>点击网址，在网站目录一项关闭跨站攻击，在网站目录选择&#x2F;www&#x2F;wwwroot&#x2F;***&#x2F;zfaka~master，保存后设置运行目录为&#x2F;public</p>
<p>在伪静态一栏粘贴<br><code>location / &#123; if (!-e $request_filename) &#123; rewrite ^/(.*)$ /index.php?$1 last; &#125; &#125;</code></p>
<p>###2.4.1 ssl<br>(可选，在ssl一栏申请let’s encrypt证书</p>
<p>勾选域名，输入邮箱申请，成功后可在右上角开启强制https登录</p>
<p>###2.5 关闭path_info<br>如图所示，记得保存</p>
<img src="https://pic3.superbed.cn/item/5de9ec3ef1f6f81c50fab40b.jpg" alt="" />

<p>进入&#x2F;nginx&#x2F;conf目录后自己找和刚才pho版本一个名字的文件，别选错了，图上是php7.1,请根据自己情况选择文件。</p>
<p>###2.6 安装yaf</p>
<p>在软件商店找到自己刚才安装的php，点击设置，在安装拓展一栏找到yaf并安装</p>
<p>在配置文件一栏，划到文件最底下，插入指令<code>yaf.use_namespace=1</code></p>
<p>（不用管分号什么的）保存，重启php。</p>
<p>###2.7 回到网站根目录</p>
<p>需要进入进入conf目录下，application.ini.new 重置名为 application.ini 此时请直接访问站点即可</p>
<p>###2.8 进入安装程序，<br>第一页全部打勾后第二页输入数据库名称，密码，用户名等，这些信息可在宝塔面板侧栏数据库找到，安装完成得到一个用户名和密码，复制后进去后台界面，输入并登入。</p>
<p>###2.9 修改mysql<br>自行寻找修改密码处，修改完毕后回到宝塔，在数据库一栏点击管理，进入mysql界面，找到数据库里面admin-user一项，修改第一项刚才的用户名，并保存退出。</p>
<p>###3.0 重新登录<br>进入后台，自行配置</p>
<p><img src="https://pic1.superbed.cn/item/5dea64fbf1f6f81c50151d32.jpg"></p>
<p>好累啊，这期教程就到这里了，下一期会出一个zfaka的支付对接方案，对接平台是易付通，这个让我省心的东西。我前前后后建了七八次站了，真的很累，但是成就感满满，这几天为了这个崩三都忘了肝了，拜了拜了，体力都溢出了，我去守护崩坏世界了。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>科技</category>
      </categories>
      <tags>
        <tag>宝塔</tag>
        <tag>服务器</tag>
        <tag>zfaka</tag>
        <tag>发卡平台</tag>
      </tags>
  </entry>
</search>
