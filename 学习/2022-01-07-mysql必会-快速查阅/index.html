<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="随缘更新技术文章" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Mysql必会-快速查阅 |  Copy on Write</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="https://tu.yegetables.com/images/2021/02/08/1612775550764_192x192.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/feed.xml" title="Copy on Write" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-学习/2022-01-07-mysql必会-快速查阅"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Mysql必会-快速查阅
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/%E5%AD%A6%E4%B9%A0/2022-01-07-mysql%E5%BF%85%E4%BC%9A-%E5%BF%AB%E9%80%9F%E6%9F%A5%E9%98%85/" class="article-date">
  <time datetime="2022-01-07T13:10:06.000Z" itemprop="datePublished">2022-01-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">32 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>主键（primary key）一列（或一组列），其值能够唯一区分表中每个行。</p>
<p>表中的任何列都可以作为主键，只要它满足以下条件：</p>
<p> 任意两行都不具有相同的主键值；</p>
<p> 每个行都必须具有一个主键值（主键列不允许NULL值）。</p>
<p> 不更新主键列中的值；</p>
<p> 不重用主键列的值；</p>
<p> 不在主键列中使用可能会更改的值</p>
<h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>返回当前选择的数据库内可用表的列表。</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> COLUMNS <span class="keyword">from</span> table1;</span><br><span class="line"><span class="keyword">DESCRIBE</span> customers;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>是 <span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> customers;的一种快捷方式。</span><br><span class="line"></span><br><span class="line">要 求 给 出 一 个 表 名 （ 这 个 例 子 中 的 <span class="keyword">FROM</span> customers），它对每个字段返回一行，行中包含字段名、数据类型、是否允许<span class="keyword">NULL</span>、键信息、默认值以及其他信息（如字段cust_id的 auto_increment）。</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207091104096.png" alt="image-20211207091104096"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELP <span class="keyword">SHOW</span>;显示允许的<span class="keyword">SHOW</span>语句。</span><br></pre></td></tr></table></figure>



<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>  id <span class="keyword">from</span> products;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id告诉MySQL只返回不同（唯一）的id行，使用<span class="keyword">DISTINCT</span>关键字，它必须直接放在列名的前面</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>不能部分使用<span class="keyword">DISTINCT</span> <span class="keyword">DISTINCT</span>关键字应用于所有列而 不仅是前置它的列。如果给出<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id, prod_price，除非指定的两个列都不同，否则所有行都将被 检索出来</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LIMIT <span class="number">5</span>指示MySQL返回 不多于<span class="number">5</span>行。</span><br><span class="line">LIMIT <span class="number">5</span>, <span class="number">5</span>指示MySQL返回从行<span class="number">5</span>开始的<span class="number">5</span>行。第一个数为开始位置，第二个数为要检索的行数。</span><br><span class="line"></span><br><span class="line">行数从<span class="number">0</span></span><br><span class="line"></span><br><span class="line"> LIMIT <span class="number">4</span> <span class="keyword">OFFSET</span> <span class="number">3</span>意为从行<span class="number">3</span>开始取<span class="number">4</span>行，就像LIMIT <span class="number">3</span>, <span class="number">4</span>一样</span><br></pre></td></tr></table></figure>

<h3 id="排序-order-by"><a href="#排序-order-by" class="headerlink" title="排序  order by"></a>排序  order by</h3><p>默认升序</p>
<p>为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。</p>
<p>ORDER BY子句取一个或多个列的名字，据此对输出进行排序。</p>
<p>可以使用非显示列 进行排序 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  id <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>

<h5 id="多列排序"><a href="#多列排序" class="headerlink" title="多列排序"></a>多列排序</h5><p>为了按多个列排序，只要指定列名，列名之间用逗号分开即可（就像选择多个列时所做的那样）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  id <span class="keyword">from</span> products <span class="keyword">order</span> <span class="keyword">by</span> price,name;</span><br></pre></td></tr></table></figure>

<p>先按price排序,相同price 按 name 排序</p>
<h5 id="降序-order-by-desc"><a href="#降序-order-by-desc" class="headerlink" title="降序 order by  desc"></a>降序 order by  desc</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">DESC</span>关键字只应用到直接位于其前面的列名</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>, name;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 降序排price , 再排name</span><br></pre></td></tr></table></figure>



<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>​         between low and high</p>
<p>​		 where name IS NULL   &#x2F;&#x2F; 判断空值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> abc和ABC mysql中默认相同</span><br></pre></td></tr></table></figure>

<p>单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不<br>用引号。</p>
<h4 id="and-or"><a href="#and-or" class="headerlink" title="and  or"></a>and  or</h4><p>SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> (a<span class="operator">=</span><span class="number">1</span> <span class="keyword">or</span> b<span class="operator">=</span><span class="number">2</span> ) <span class="keyword">and</span> c<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认计算次序，即使它确实是你想要的东西也是如此。使用圆括号没有什么坏处，它能消除歧义。</p>
<h4 id="in-not"><a href="#in-not" class="headerlink" title="in not"></a>in not</h4><p>IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全都括在圆括号中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">100</span>,<span class="number">200</span>)   <span class="operator">/</span><span class="operator">/</span> <span class="number">100</span> 或 <span class="number">200</span> </span><br></pre></td></tr></table></figure>

<p>为什么要使用IN操作符？其优点具体如下。<br> 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。<br> 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。<br> IN操作符一般比OR操作符清单执行更快。<br> IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</p>
<p>NOT WHERE子句中用来否定后跟条件的关键字。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> <span class="keyword">in</span> (a,b)</span><br></pre></td></tr></table></figure>

<h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p>为在搜索子句中使用通配符，必须使用LIKE操作符</p>
<p>LIKE指示 MySQL 后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。</p>
<h4 id="任何字符任意次数"><a href="#任何字符任意次数" class="headerlink" title="% 任何字符任意次数"></a>% 任何字符任意次数</h4><p>最常使用的通配符是百分号（%）。在搜索串中，%表示任何字符出现任意次数</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207101953246.png" alt="image-20211207101953246"></p>
<p>还可以使用 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%abc%     匹配  ( 100abc21 ,    abc3  , 1abc )</span><br></pre></td></tr></table></figure>

<p>即使是WHERE prod_name LIKE ‘%’也不能匹配用值NULL作为产品名的行。</p>
<h4 id="任意字符-1-次"><a href="#任意字符-1-次" class="headerlink" title="_   任意字符 1 次"></a>_   任意字符 1 次</h4><p> 匹配任意字符  但下划线只匹配单个字符而不是多个字符。</p>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>REGEXP 关键字</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> name regexp <span class="string">&#x27;1000&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207104318527.png" alt="image-20211207104318527"></p>
<p>LIKE匹配整个串而REGEXP匹配子串。利用定位符，通过用^开始每个表达式，用$结束每个表达式，可以使<br>REGEXP的作用与LIKE一样。</p>
<p>MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大<br>小写，可使用BINARY关键字，如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="type">BINARY</span> <span class="string">&#x27;JetPack .000&#x27;</span></span><br></pre></td></tr></table></figure>

<p>两个以上的OR条件 可以给出两个以上的OR条件。例如，<code>&#39;1000 | 2000 | 3000&#39;</code>将匹配1000或2000或3000</p>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义 \\"></a>转义 <code>\\</code></h4><p>为了匹配特殊字符，必须用<code>\\</code>为前导。</p>
<p><code>\\-</code>  表示查找<code>-</code>  <code>\\.</code>表示查找<code>.</code></p>
<p>为了匹配反斜杠（\）字符本身，需要使用<code>\\\</code></p>
<p>多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身。但MySQL要求两个反斜杠（MySQL<br>自己解释一个，正则表达式库解释另一个）</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207104911297.png" alt="image-20211207104911297"></p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207105037565.png" alt="image-20211207105037565"></p>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207105144297.png" alt="image-20211207105144297"></p>
<h2 id="计算字段-和-函数"><a href="#计算字段-和-函数" class="headerlink" title="计算字段 和 函数"></a>计算字段 和 函数</h2><p>计算字段并 不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。</p>
<h3 id="拼接Concat"><a href="#拼接Concat" class="headerlink" title="拼接Concat()"></a>拼接Concat()</h3><p>在MySQL的SELECT语句中，可使用 <code>Concat()</code>函数来拼接两个列。</p>
<p>Concat()需要一个或多个指定的串，各个串之间用逗号分隔。</p>
<p>多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207110011587.png" alt="image-20211207110011587"></p>
<h3 id="Trim-去空格"><a href="#Trim-去空格" class="headerlink" title="Trim()去空格"></a>Trim()去空格</h3><p>RTrim()   LTrim()  Trim()   </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Concat( RTrim(name) , <span class="string">&#x27;(&#x27;</span> , RTrim(country) , <span class="string">&#x27;)&#x27;</span> ) <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>

<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>从前面的输出中可以看到，SELECT语句拼接地址字段工作得很好。但此新计算列的名字是什么呢？实际上它没有名字，它只是一个值。一个未命名的列不能用于客户机应用中，因为客户机没有办法引用它。</p>
<p>别名用AS关键字赋予。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Concat( RTrim(name) , <span class="string">&#x27;(&#x27;</span> , RTrim(country) , <span class="string">&#x27;)&#x27;</span> ) <span class="keyword">as</span> myname  <span class="keyword">from</span> vendors <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure>

<p>client可以用 别名 当作列名 去使用</p>
<p>别名还有其他用途。常见的用途包括在实际 的表列名包含不符合规定的字符（如空格）时重新命名它，在<br>原来的名字含混或容易误解时扩充它</p>
<p>别名除了用于列名和计算字段外，SQL还允许给表名起别名。这样做有两个主要理由：<br> 缩短SQL语句；<br> 允许在单条SELECT语句中多次使用相同的表。</p>
<p>应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">from</span> table1 <span class="keyword">as</span> a, table2 <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">where</span></span><br></pre></td></tr></table></figure>



<h3 id="算术计算"><a href="#算术计算" class="headerlink" title="算术计算"></a>算术计算</h3><p>计算字段的另一常见用途是对检索出的数据进行算术计算</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207110735865.png" alt="image-20211207110735865"></p>
<p> 支持  加减乘除</p>
<h3 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h3><p>能运行在多个系统上的代码称 为可移植的（portable）。相对来说，多数SQL语句是可移植的，<br>在SQL实现之间有差异时，这些差异通常不那么难处理。而函 数的可移植性却不强。几乎每种主要的DBMS的实现都支持其 他实现不支持的函数，而且有时差异还很大。</p>
<h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><p><code>Trim()去空格</code></p>
<p><code>Upper()转大写</code></p>
<p><code>Length() 返回串长</code></p>
<p><code>Left()</code> 返回串左边的字符</p>
<p><code>Locate()</code> 找出串的一个子串</p>
<p><code>Lower()</code> 将串转换为小写</p>
<p><code>LTrim()</code> 去掉串左边的空格</p>
<p><code>Right()</code> 返回串右边的字符</p>
<p><code>RTrim()</code> 去掉串右边的空格</p>
<p><code>SubString()</code> 返回子串的字符</p>
<p><code>Soundex()</code> 返回串的SOUNDEX值  </p>
<p> SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207111511553.png" alt="image-20211207111511553"></p>
<h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><p>一般，应用程序不使用用来存储日期和时间的格式，因此日期和时间函数总是被用来读取、统计和处理这些值。由于这个原因，日期和时间函数在MySQL语言中具有重要的作用。</p>
<p>不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。因此，2005年9月1日，给出为2005-09-01。虽然其他的日期格式可能也行，但这是首选的日期格式，因为它排除了多义性</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207112051616.png" alt="image-20211207112051616"></p>
<p>基本的日期比较</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> data<span class="operator">=</span><span class="string">&#x27;2002-05-15&#x27;</span></span><br></pre></td></tr></table></figure>

<p>比 如 ， 存 储 的 order_date 值 为 2005-09-01 11:30:05，则WHERE order_date &#x3D; ‘2005-09-01’失败。</p>
<p>即使给出具有该日期的一行，也不会把它检索出来，因为WHERE匹配失败。</p>
<p>MySQL仅将给出的日期与列中的日期部分进行比 较，而不是将给出的日期与整个列值进行比较</p>
<p>为此，必须使用Date() 函数。Date(order_date)指示MySQL仅提取列的日期部分</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span>  <span class="type">Date</span>(data)<span class="operator">=</span><span class="string">&#x27;2002-05-15&#x27;</span></span><br></pre></td></tr></table></figure>



<p>如果你想检索出2005年9月下的 所有订单，怎么办？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span>  <span class="type">Date</span>(data) <span class="keyword">between</span> <span class="string">&#x27;2002-05-01&#x27;</span> <span class="keyword">and</span>  <span class="string">&#x27;2002-05-31&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">Year</span>(data)<span class="operator">=</span><span class="number">2002</span> <span class="keyword">and</span> <span class="keyword">Month</span>(data)<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h4 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h4><p>这些函数一般主要用于代数、三角 或几何运算，</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207112658152.png" alt="image-20211207112658152"></p>
<h4 id="汇总表本身信息"><a href="#汇总表本身信息" class="headerlink" title="汇总表本身信息"></a>汇总表本身信息</h4><p>我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提 供了专门的函数。使用这些函数，MySQL查询可用于检索数据，以便分 析和报表生成。</p>
<p> 确定表中行数（或者满足某个条件或包含某个特定值的行数）。</p>
<p> 获得表中行组的和。</p>
<p>找出表列（或所有行或某些特定的行）的最大值、最小值和平均值</p>
<p>上述例子都需要对表中数据（而不是实际数据本身）汇总。因此 ， 返回实际表数据是对时间和处理资源的一种浪费（更不用说带宽了）。重 复一遍，实际想要的是汇总信息。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207112943225.png" alt="image-20211207112943225"></p>
<h5 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h5><p>只用于单个列 AVG()只能用来确定特定数值列的平均值，而 且列名必须作为函数参数给出。为了获得多个列的平均值， 必须使用多个AVG()函数。</p>
<p>AVG()函数忽略列值为NULL的行。</p>
<h5 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h5><p>可利用COUNT()计算行的数目。</p>
<p>COUNT()函数有两种使用方式。</p>
<p>​	 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</p>
<p>​	 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值</p>
<h5 id="MAX-x2F-MIN"><a href="#MAX-x2F-MIN" class="headerlink" title="MAX &#x2F; MIN"></a>MAX &#x2F; MIN</h5><p>MAX()返回指定列中的最大值。MAX()要求指定列名</p>
<p>在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行。MIN()返回最前面的行</p>
<p>忽略列值为NULL的行</p>
<h5 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h5><p>SUM()用来返回指定列值的和（总计）。</p>
<h5 id="distinct-排除"><a href="#distinct-排除" class="headerlink" title="distinct 排除"></a>distinct 排除</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">AVG</span>( <span class="keyword">DISTINCT</span> price  ) <span class="keyword">from</span> products <span class="keyword">where</span> id <span class="operator">=</span><span class="number">10086</span>;</span><br></pre></td></tr></table></figure>

<p>只对不同价格的商品计算平均值</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>单个组 的聚集函数 可以统计 Count &#x2F;Sum 等</p>
<p>但如果要返回多个有细微区别的 组的数据  </p>
<p>这就是分组显身手的时候了。分组允许把数据分为多个逻辑组，以 便能对每个组进行聚集计算。</p>
<p>在具体使用GROUP BY子句前，需要知道一些重要的规定。</p>
<p> GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。</p>
<p> 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</p>
<p> GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</p>
<p> 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</p>
<p> 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</p>
<p> GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p>
<h3 id="创建分组-group-by"><a href="#创建分组-group-by" class="headerlink" title="创建分组 group by"></a>创建分组 group by</h3><p>SELECT语句的GROUP BY子句中建立的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure>

<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207114232745.png" alt="image-20211207114232745"></p>
<p>使用ROLLUP 使用WITH ROLLUP关键字，可以得到每个分组以 及每个分组汇总级别（针对每个分组）的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id ,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id <span class="keyword">with</span> <span class="keyword">rollup</span> ;</span><br></pre></td></tr></table></figure>



<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207114734309.png" alt="image-20211207114734309"></p>
<h3 id="过滤分组-having"><a href="#过滤分组-having" class="headerlink" title="过滤分组 having"></a>过滤分组 having</h3><p><code>HAVING</code>非常类似于WHERE。事实上，目前为止所 学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是 WHERE过滤行，而HAVING过滤分组。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207125607913.png" alt="image-20211207125607913"></p>
<p>分组不等于排序,  有了  Group By  不要忘记使用 Order By 来确保正确顺序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_id ,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num_prods <span class="keyword">from</span> products <span class="keyword">group</span> <span class="keyword">by</span> vend_id  <span class="keyword">having</span>  num_prods <span class="operator">&gt;</span><span class="number">100</span>  <span class="keyword">order</span> <span class="keyword">by</span> num_prods ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 此语句     用count 计算 num , 按照 id 分组 , 保留 num <span class="operator">&gt;</span><span class="number">50</span> , 并按照  num  排序</span><br></pre></td></tr></table></figure>



<p>select 中 各个字句 先后顺序 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">from</span><br><span class="line">where</span><br><span class="line">group by</span><br><span class="line">having</span><br><span class="line">order by</span><br><span class="line">limit</span><br></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>SQL还允许创建子查询（subquery），即嵌套在其他查询中的查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> others <span class="keyword">where</span> order_num <span class="keyword">in</span> (<span class="number">20005</span>,<span class="number">20007</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> others <span class="keyword">where</span> order_num <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>可见，在WHERE子句中使用子查询能够编写出功能很强并且很灵活的 SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于 性能的限制，不能嵌套太多的子查询。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207165247697.png" alt="image-20211207165247697"></p>
<h2 id="联结-join"><a href="#联结-join" class="headerlink" title="联结 join"></a>联结 join</h2><p>外键（foreign key） 外键为某个表中的一列，它包含另一个表 的主键值，定义了两个表之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 情景模拟</span><br><span class="line">假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢</span><br><span class="line"></span><br><span class="line">关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relational））互相关联。</span><br><span class="line"></span><br><span class="line">在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。vendors表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为主键（primary key）（在第1章中首次提到），可以是供应商ID或任何其他唯一值。</span><br><span class="line"></span><br><span class="line">products表只存储产品信息，它除了存储供应商ID（vendors表的主键）外不存储其他供应商信息。vendors表的主键又叫作products的外键，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。</span><br><span class="line"></span><br><span class="line">这样做的好处如下：</span><br><span class="line"> 供应商信息不重复，从而不浪费时间和空间；</span><br><span class="line"> 如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动；</span><br><span class="line"> 由于数据无重复，显然数据是一致的，这使得处理数据更简单。</span><br></pre></td></tr></table></figure>

<p>如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？<br>答案是使用联结。简单地说，联结是一种机制，用来在一条SELECT<br>语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返<br>回一组输出，联结在运行时关联表中正确的行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果在products表中插入拥有非法供应商ID（即没有在vendors表中出现）的供应商生产的产品，则这些</span><br><span class="line">产品是不可访问的，因为它们没有关联到某个供应商。</span><br><span class="line">为防止这种情况发生，可指示MySQL只允许在products表的供应商ID列中出现合法值（即出现在vendors表中的供应商）。</span><br><span class="line">这就是维护引用完整性，它是通过在表的定义中指定主键和外键来实现的。</span><br></pre></td></tr></table></figure>

<h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> table1.id<span class="operator">=</span>table2.id</span><br></pre></td></tr></table></figure>

<p>笛卡儿积（cartesian product） 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。</p>
<h3 id="内连结"><a href="#内连结" class="headerlink" title="内连结"></a>内连结</h3><p>目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结</p>
<p>内连结有关键词 Inner Join  on</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> table1 <span class="keyword">inner</span> <span class="keyword">join</span> table2 <span class="keyword">on</span> table1.id<span class="operator">=</span>table2.id</span><br></pre></td></tr></table></figure>

<p>尽量不要使用 * 通配符在 内连结 ,有 笛卡尔积问题</p>
<h3 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> p1.id , p1.name </span><br><span class="line"><span class="keyword">from</span> products <span class="keyword">as</span> p1,products <span class="keyword">as</span> p2</span><br><span class="line"><span class="keyword">where</span> p1.id<span class="operator">=</span>p2.id <span class="keyword">and</span> p2.id<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对表设置别名  对一张表设置两个别名 分别使用 </p>
<p>用自联结而不用子查询 自联结通常作为外部语句用来替代 从相同表中检索数据时使用的子查询语句。虽然最终的结果是 相同的，但有时候处理联结远比处理子查询快得多。</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。</p>
<p>内部联结）返回所有数据，甚 至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次</p>
<p>系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一<br>般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207192551674.png" alt="image-20211207192551674"></p>
<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> table1 <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> table2  <span class="keyword">on</span> table1.id<span class="operator">=</span>table2.id</span><br></pre></td></tr></table></figure>

<p>使用<code>outer join</code> 语法时必须指定 <code>right </code>还是 <code>left</code></p>
<p>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字 指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT 指出的是OUTER JOIN左边的表）</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207193124571.png" alt="image-20211207193124571"></p>
<p>表中指定 <code>left outer join</code> 指定了 customers 为拥有所有行的表 , 所以 cust_id 不为空, orders 表可能有空</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存在两种基本的外部联结形式：左外部联结 和右外部联结。它们之间的唯一差别是所关联的表的顺序不</span><br><span class="line">同。换句话说，左外部联结可通过颠倒FROM或WHERE子句中 表的顺序转换为右外部联结。因此，两种类型的外部联结可互</span><br><span class="line">换使用，而究竟使用哪一种纯粹是根据方便而定。</span><br></pre></td></tr></table></figure>



<h2 id="组合查询union"><a href="#组合查询union" class="headerlink" title="组合查询union"></a>组合查询union</h2><p>MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个<br>查询结果集返回。</p>
<p>有两种基本情况，其中需要使用组合查询：<br> 在单个查询中从不同的表返回类似结构的数据；<br> 对单个表执行多个查询，按单个查询返回数据。</p>
<p>利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集。</p>
<p>UNION的使用很简单。所需做的只是给出每条SELECT语句，在各条语句之间放上关键字UNION。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207194637041.png" alt="image-20211207194637041"></p>
<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207194643905.png" alt="image-20211207194643905"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="number">1</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>在这个简单的例子中，使用UNION可能比使用WHERE子句更为复杂。但对于更复杂的过滤条件，或者从多个表（而不是单个表）中检索数据 的情形，使用UNION可能会使处理更简单。</p>
<p><strong>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</strong></p>
<p><strong>UNION从查询结果集中自动去除了重复的行</strong></p>
<p>这是UNION的默认行为，但是如果需要，可以改变它。事实上，如果 想返回所有匹配行，可使用<code>UNION ALL</code>而不是UNION。</p>
<p>UNION ALL为UNION的一种形式，它完成 WHERE子句完成不了的工作。如果确实需要每个条件的匹配行全<br>部出现（包括重复行），则必须使用UNION ALL而不是WHERE。</p>
<h3 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h3><p><strong>最后一条 select 的 order by 对整个结果集 起作用</strong></p>
<p>SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只 能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。对 于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一 部分的情况，因此不允许使用多条ORDER BY子句。</p>
<h2 id="全文本搜索-待补充"><a href="#全文本搜索-待补充" class="headerlink" title="全文本搜索 (待补充)"></a>全文本搜索 (待补充)</h2><p>并非所有引擎都支持全文本搜索 正如第21章所述，MySQL 支持几种基本的数据库引擎。并非所有的引擎都支持本书所描 述的全文本搜索。两个最常使用的引擎为MyISAM和InnoDB， 前者支持全文本搜索，而后者不支持 </p>
<p>如果你的应用中需要全文本搜索功能，应该记住这一点</p>
<h2 id="插入-更新-删除"><a href="#插入-更新-删除" class="headerlink" title="插入 更新 删除"></a>插入 更新 删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 插入完整的行；</span><br><span class="line"> 插入行的一部分；</span><br><span class="line"> 插入多行；</span><br><span class="line"> 插入某些查询的结果</span><br></pre></td></tr></table></figure>

<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 (colum1,colum2,....) <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>



<p>如果 检索 比 插入重要 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> low priority <span class="keyword">into</span> .....</span><br></pre></td></tr></table></figure>

<p>多行插入 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 (colum1,colum2,....) <span class="keyword">values</span> </span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>insert select   ( 注意  不含主键 ??)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 (colum1,colum2,....)</span><br><span class="line"><span class="keyword">select</span>  colum1,colum2,....</span><br><span class="line"><span class="keyword">from</span> table2;</span><br></pre></td></tr></table></figure>

<p>INSERT SELECT中的列名不一定要求列名匹配。</p>
<p>事实上，MySQL甚至不关心SELECT返回的列名。它使用的是 列的位置，因此SELECT中的第一列（不管其列名）将用来填充 表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，</p>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>省略 where  会 更新表所有 行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> table1 </span><br><span class="line"><span class="keyword">set</span> column1<span class="operator">=</span><span class="string">&#x27;2&#x27;</span> ,column2<span class="operator">=</span><span class="string">&#x27;3&#x27;</span> </span><br><span class="line"><span class="keyword">where</span>   ...</span><br></pre></td></tr></table></figure>

<p>在UPDATE语句中使用子查询 UPDATE语句中可以使用子查 询，使得能用SELECT语句检索出的数据更新列数据。</p>
<p>ignore 关键字 如果用UPDATE语句更新多行，并且在更新这些 行中的一行或多行时出一个现错误，则整个UPDATE操作被取消 （错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> IGNORE ......</span><br></pre></td></tr></table></figure>

<p>update set &#x3D;null 置为空,删除效果</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>省略 where  会 删除表所有 行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table1</span><br><span class="line"><span class="keyword">where</span></span><br></pre></td></tr></table></figure>



<p>DELETE删除整行而不是删除列。为了 删除指定的列，请使用UPDATE语句。</p>
<h2 id="创建摧毁表"><a href="#创建摧毁表" class="headerlink" title="创建摧毁表"></a>创建摧毁表</h2><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> name1</span><br><span class="line">(</span><br><span class="line">    column1 type1 ...  ,</span><br><span class="line">    column1 type1 ...  ,</span><br><span class="line">)Engine<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<h5 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h5><p>表的主键可以在创建表时用 PRIMARY KEY关键字指定。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">primary</span> key ( column1 ,column2 )</span><br></pre></td></tr></table></figure>



<p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207205757751.png" alt="image-20211207205757751"></p>
<h5 id="AUTO-INCREMENT-自增"><a href="#AUTO-INCREMENT-自增" class="headerlink" title="AUTO_INCREMENT 自增"></a>AUTO_INCREMENT 自增</h5><p>每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。</p>
<p>那么，如何在使用AUTO_INCREMENT列时获得这个值呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_insert_id() </span><br></pre></td></tr></table></figure>

<p>此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于 后续的MySQL语句。</p>
<h5 id="IF-NOT-EXISTS"><a href="#IF-NOT-EXISTS" class="headerlink" title="IF NOT EXISTS"></a>IF NOT EXISTS</h5><p>如果你仅想在一个表不存在时创建它，应该在表名后给出<code>IF NOT EXISTS</code>。这样做不检查已有表的模式是否与你打算创建 的表模式相匹配。它只是查看表名是否存在，并且仅在表名不 存在时创建它。</p>
<h5 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h5><p>创建表时 指定列 能否为空值</p>
<p>主键中只能使用不允许NULL值的列</p>
<h5 id="default"><a href="#default" class="headerlink" title="default"></a>default</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column1 type1  <span class="keyword">NOT</span> <span class="keyword">NULL</span>  <span class="keyword">DEFAULT</span> <span class="number">1</span> ,</span><br></pre></td></tr></table></figure>

<h5 id="engine"><a href="#engine" class="headerlink" title="engine"></a>engine</h5><p><img src="https://tu.yegetables.com/images/2021/12/07/image-20211207210620031.png" alt="image-20211207210620031"></p>
<p>外键不能跨引擎 混用引擎类型有一个大缺陷。外键（用于 强制实施引用完整性，如第1章所述）不能跨引擎，即使用一 个引擎的表不能引用具有使用不同引擎的表的外键。</p>
<h5 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line">(</span><br><span class="line">		O_Id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		OrderNo <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		P_Id <span class="type">int</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (O_Id),</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY (P_Id) <span class="keyword">REFERENCES</span> Persons(P_Id)</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>如需命名 <span class="keyword">FOREIGN</span> KEY 约束，并定义多个列的 <span class="keyword">FOREIGN</span> KEY 约束</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> fk_PerOrders <span class="keyword">FOREIGN</span> KEY (P_Id) <span class="keyword">REFERENCES</span> Persons(P_Id)</span><br><span class="line">    </span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h3 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h3><h4 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h4><p>add</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1 <span class="keyword">add</span>  </span><br><span class="line">column1 type1  <span class="keyword">NOT</span> <span class="keyword">NULL</span>  <span class="keyword">DEFAULT</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p>drop</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1 <span class="keyword">drop</span></span><br><span class="line">column1 ;</span><br></pre></td></tr></table></figure>

<p>外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1</span><br><span class="line"><span class="keyword">add</span> </span><br><span class="line"><span class="keyword">foreign</span> key ( table1.colnm1 ) <span class="keyword">references</span> table2 (table2.colnm2 )</span><br></pre></td></tr></table></figure>

<p>如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_PerOrders</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (P_Id) <span class="keyword">REFERENCES</span> Persons(P_Id)</span><br></pre></td></tr></table></figure>

<p>撤销外键</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Orders</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_PerOrders</span><br></pre></td></tr></table></figure>





<p>一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY(唯一约束的键)。</p>
<h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table1;</span><br></pre></td></tr></table></figure>



<h3 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="keyword">table</span> table1 <span class="keyword">to</span> table2;</span><br></pre></td></tr></table></figure>





<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<p>作为视图，它不包含表中应该有的任何列或数据，它包含的是一个SQL查询的数据</p>
<p>下面是视图的一些常见应用。</p>
<p> 重用SQL语句。</p>
<p> 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</p>
<p> 使用表的组成部分而不是整个表。</p>
<p> 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</p>
<p> 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p>
<p>重要的是知道视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p>
<p>最常见的规则和限制。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</span><br><span class="line"> 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</span><br><span class="line"> 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</span><br><span class="line"> ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</span><br><span class="line"> 视图不能索引，也不能有关联的触发器或默认值。</span><br><span class="line"> 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。</span><br></pre></td></tr></table></figure>

<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>CREATE VIEW语句</p>
<p>用SHOW CREATE VIEW viewname；来查看创建视图的语句。</p>
<p>DROP删除视图，其语法为DROP VIEW viewname;。</p>
<p>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> viewname1 <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> ...</span><br><span class="line">....;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> viewname1;</span><br></pre></td></tr></table></figure>



<p>常用来格式化一些 数据</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208124935876.png" alt="image-20211208124935876"></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新一个视图将更新其基表</p>
<p>但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不 能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实 际上意味着，如果视图定义中有以下操作，则不能进行视图的更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">group by </span><br><span class="line">having</span><br><span class="line">连结</span><br><span class="line">子查询</span><br><span class="line">并</span><br><span class="line">聚集函数 Distinct</span><br><span class="line">导出（计算）列。</span><br></pre></td></tr></table></figure>

<p>将视图用于检索 一般，应该将视图用于检索（SELECT语句） 而不用于更新（INSERT、UPDATE和DELETE）</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程简单来说，就是为以后的使用而保存 的一条或多条MySQL语句的集合。可将其视为批文件</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> funname1 ( </span><br><span class="line">    arg1, </span><br><span class="line">    arg2  <span class="operator">/</span><span class="operator">/</span> 可选参数</span><br><span class="line">) </span><br></pre></td></tr></table></figure>



<h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> funname1( 可选参数 )</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> .....</span><br><span class="line">	<span class="keyword">from</span> ... ;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>如果存储过程接受参数，它们将在()中列举出来。此存储过程没</span><br><span class="line">有参数，但后跟的()仍然需要。<span class="keyword">BEGIN</span>和<span class="keyword">END</span>语句用来限定存储过程体，过</span><br><span class="line">程体本身仅是一个简单的<span class="keyword">SELECT</span>语句</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> funame1;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> IF <span class="keyword">EXISTS</span> funname1;</span><br></pre></td></tr></table></figure>

<h3 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h3><h5 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> funname1( </span><br><span class="line">	<span class="keyword">out</span> p1 <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">out</span> p2 <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">out</span> p3 <span class="type">decimal</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">Min</span>(price)</span><br><span class="line">	<span class="keyword">into</span> p1</span><br><span class="line">	<span class="keyword">from</span> products;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">Max</span>(price)</span><br><span class="line">	<span class="keyword">into</span> p2</span><br><span class="line">	<span class="keyword">from</span> products;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">Avg</span>(price)</span><br><span class="line">	<span class="keyword">into</span> p3</span><br><span class="line">	<span class="keyword">from</span> products;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>解析</p>
<ol>
<li><p>参数 p1,p2,p3   都是 out 参数  用来传出 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in  传入参数</span><br><span class="line">out 传出参数</span><br><span class="line">inout  传入传出参数</span><br><span class="line"></span><br><span class="line">decimal 十进制</span><br></pre></td></tr></table></figure>


</li>
<li><p><code> into</code> 用来给变量赋值</p>
</li>
</ol>
<p>记录集不是允许的类型，因此，不能通过一个参数返回 多个行和列。这就是前面的例子为什么要使用3个参数</p>
<h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">call</span> funname1 (</span><br><span class="line">    		<span class="variable">@min</span>_arg,</span><br><span class="line">             <span class="variable">@max</span>_arg,</span><br><span class="line">             <span class="variable">@avg</span>_arg</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>所有MySQL变量都必须以@开始。</p>
<p>由于此存储过程要求3个参数，因此必须正好传递3个参数</p>
<h5 id="拿取参数"><a href="#拿取参数" class="headerlink" title="拿取参数"></a>拿取参数</h5><p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208170936471.png" alt="image-20211208170936471"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@min</span>_arg ;</span><br></pre></td></tr></table></figure>



<h3 id="显示存储过程"><a href="#显示存储过程" class="headerlink" title="显示存储过程"></a>显示存储过程</h3><p>显示用来创建一个存储过程的CREATE语句</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> funname1;</span><br></pre></td></tr></table></figure>

<p>列出所有存储过程</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS</span><br></pre></td></tr></table></figure>





<h2 id="游标-待补充"><a href="#游标-待补充" class="headerlink" title="游标 (待补充)"></a>游标 (待补充)</h2><p>需要在检索出来的行中前进或后退一行或多行。这就是使用 游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</p>
<p> 不像多数DBMS，MySQL游标只能用于存储过程（和函数）。</p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>MySQL语句在需要时被执行，存储过程也是如此。但是，如果你 想要某条语句（或某些语句）在事件发生时自动执行</p>
<p>所有这些例子的共同之处是它们都需要在某个表发生更改时自动 处理。这确切地说就是触发器。</p>
<p>触发器是MySQL响应以下任意语句而 自动执行的一条MySQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DELETE；</span><br><span class="line">INSERT；</span><br><span class="line">UPDATE;</span><br><span class="line">begin   ....   end;</span><br></pre></td></tr></table></figure>

<p>其他MySQL语句不支持触发器</p>
<p> 应该用触发器来保证数据的一致性（大小写、格式等）。在触发器<br>中执行这种类型的处理的优点是它总是进行这种处理，而且是透<br>明地进行，与客户机应用无关。</p>
<p>触发器的一种非常有意义的使用是创建审计跟踪。使用触发器，<br>把更改（如果需要，甚至还有之前和之后的状态）记录到另一个<br>表非常容易。</p>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><p>在创建触发器时，需要给出4条信息：<br> 唯一的触发器名；<br> 触发器关联的表；<br> 触发器应该响应的活动（DELETE、INSERT或UPDATE）；<br> 触发器何时执行（处理之前或之后）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> name </span><br><span class="line">after<span class="operator">|</span>before 		<span class="keyword">insert</span><span class="operator">|</span><span class="keyword">update</span><span class="operator">|</span><span class="keyword">delete</span>  	<span class="keyword">on</span> table1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>   <span class="operator">/</span><span class="operator">/</span>这个触发器还指定 FOREACH <span class="type">ROW</span>，因此代码对每个插入行执行。</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;aaaaa&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>只有表才支持触发器，视图不支持（临时表也不 支持）。</p>
<p>单一触发器不能与多个事件或多个表关联，所 以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义 两个触发器。</p>
<p>如果BEFORE触发器失败，则MySQL将不执行请 求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL<br>将不执行AFTER触发器（如果有的话）。</p>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> name;</span><br></pre></td></tr></table></figure>

<p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它， 然后再重新创建。</p>
<h3 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h3><p>在INSERT触发器代码内，可引用一个名为<code>NEW</code>的虚拟表，访问<code>被插入的行</code>；</p>
<p>对于<code>AUTO_INCREMENT</code>列，NEW在INSERT<code>执行之前包含0</code>，在<code>INSERT执行之后包含新的自动生成值</code>。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208190029679.png" alt="image-20211208190029679"></p>
<h3 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h3><p> 在DELETE触发器代码内，你可以引用一个名为<code>OLD</code>的虚拟表，访问被删除的行；</p>
<p><code>OLD</code>中的值全都是<code>只读</code>的，不能更新。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> name1 </span><br><span class="line">before <span class="keyword">delete</span> <span class="keyword">on</span> table1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> table2 (column1,column2 ...)</span><br><span class="line">	<span class="keyword">values</span> (old.column1, old.column2 ...) ;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>这个例子是 对每个删除行进行备份到 table2 中</p>
<h3 id="update-2"><a href="#update-2" class="headerlink" title="update"></a>update</h3><p>在UPDATE触发器代码中，你可以引用一个名为<code>OLD</code>的虚拟表访问 以前（UPDATE语句前）的值，引用一个名为<code>NEW</code>的虚拟表访问新更新的值；</p>
<p>在<code>BEFORE UPDATE</code>触发器中，<code>NEW</code>中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</p>
<p><code>OLD</code>中的值全都是只读的，不能更新。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>并非所有引擎都支持事务处理</p>
<p>事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</p>
<p>事务（transaction）指一组SQL语句；</p>
<p>回退（rollback）指撤销指定SQL语句的过程；</p>
<p>提交（commit）指将未存储的SQL语句结果写入数据库表；</p>
<p>保留点（savepoint）指事务处理中设置的临时占位符（place-<br>holder），你可以对它发布回退（与回退整个事务处理不同）。</p>
<p>你不能回退CREATE或DROP操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction  ;</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"><span class="keyword">rollback</span> ; <span class="operator">/</span><span class="operator">/</span> <span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure>

<p>当COMMIT或ROLLBACK语句执行后，事务会自 动关闭（将来的更改会隐含提交）。</p>
<h4 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h4><p>为了支持回退部分事务处理，必须能在事务处理块中合适的位置放 置占位符。这样，如果需要回退，可以回退到某个占位符</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">savepoint</span>  delete1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> delete1;</span><br></pre></td></tr></table></figure>



<p>保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放 </p>
<p>或者手动 <code>release savepoint</code></p>
<h4 id="更改默认提交行为"><a href="#更改默认提交行为" class="headerlink" title="更改默认提交行为"></a>更改默认提交行为</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p> 字符集 character   为字母和符号的集合；</p>
<p> 编码       为某个字符集成员的内部表示；</p>
<p> 校对    collation    为规定字符如何比较的指令。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208192511630.png" alt="image-20211208192511630"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208192556076.png" alt="image-20211208192556076"></p>
<h2 id="权限控制-待补充"><a href="#权限控制-待补充" class="headerlink" title="权限控制 (待补充)"></a>权限控制 (待补充)</h2><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。</p>
<p>决不要检索比需求还要多的数据。换言之，不要用SELECT *（除 非你真正需要每个列）。</p>
<p>必须索引数据库表以改善数据检索的性能。</p>
<p>索引改善数据检索的性能，但损害数据插入、删除和更新的性能</p>
<p> LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。</p>
<p>你的SELECT语句中有一系列复杂的OR条件吗？通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改进。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p>使用引号 不管使用何种形式的串数据类型，串值都必须括在<br>引号内（通常单引号更好）。</p>
<p>如果数值是计算（求和、平均等）中使 用的数值，则应该存储在数值数据类型列中。如果作为字符串（可能只包含数字）使用，则应该保存在串数据类型列中。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208193447550.png" alt="image-20211208193447550"></p>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>有符号或无符号 所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号。</p>
<p>默认情况为有符号，</p>
<p>可以使用<code>UNSIGNED</code>关键字，这样做将允许你存储两倍大小的值。</p>
<p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208193708795.png" alt="image-20211208193708795"></p>
<h3 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h3><p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208193731910.png" alt="image-20211208193731910"></p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p><img src="https://tu.yegetables.com/images/2021/12/08/image-20211208193749896.png" alt="image-20211208193749896"></p>
<p><a href="https://www.aliyundrive.com/s/xw1pPe33r4m">MySQL必知必会（文字版）.pdf</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/%E5%AD%A6%E4%B9%A0/2022-01-07-mybatis%E7%9A%84%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Mybatis的官方文档阅读理解
          
        </div>
      </a>
    
    
      <a href="/%E5%AD%A6%E4%B9%A0/2021-11-08-JavaRmi%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">JavaRmi远程方法调用</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2018-2022
        <i class="ri-heart-fill heart_icon"></i> ajian
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="https://tu.yegetables.com/images/2021/02/08/av_1607916041.jpg" alt="Copy on Write"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/feed" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>